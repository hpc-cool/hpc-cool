I"5l<p>本文告诉大家如何使用本金鱼的 MVVM 轻量框架。
一个好的框架是不需要解释就可以让大家使用，但是本金鱼没有这个能力，所以就写了这个文章告诉大家如何使用。</p>

<!--more-->

<!-- CreateTime:2019/11/29 10:16:10 -->

<!-- csdn -->

<!-- 标签：WPF,mvvm -->
<div id="toc"></div>

<p>本文的框架主要是简单，可以快速解耦 ViewModel 和 View 依赖，解耦 ViewModel 之间依赖，减少 ViewModel 的代码量。</p>

<p>具体的思想是使用消息发送的方法，多个 ViewModel 之间使用发送消息解除依赖。把原来很多需要写在 ViewModel 的代码通过发送指定的消息，在其他类处理，减少 ViewModel 代码。</p>

<p>下面来告诉大家如何使用这个框架。</p>

<p>首先是安装库</p>

<h2 id="安装">安装</h2>

<p>首先需要从 Nuget 安装两个库</p>

<ul>
  <li>
    <p>lindexi.wpf.Framework</p>
  </li>
  <li>
    <p>lindexi.MVVM.Framework</p>
  </li>
</ul>

<p>第一个库是使用 wpf 的封装，因为我还有 UWP 的封装，实际上在使用，用 WPF 或 UWP 是差不多的。只要存在 UWP 和 WPF 不相同的库，我就把这写封装在不同的库。</p>

<p>因为 Nuget 可以找到依赖库，所以只需要安装 lindexi.wpf.Framework 就会自动安装 lindexi.MVVM.Framework 。如果现在使用的是 Xarmain ，那么安装 lindexi.MVVM.Framework 就可以，这个库使用 dotnet framework 4.5 和 dotnet standard 2.0 ，所以在很多项目都可以使用。</p>

<h2 id="项目要求">项目要求</h2>

<p>安装这个库要求最低版本是 dotnet framework 4.5 以上，对于 dotnet framework 4.0 的项目无法使用。</p>

<h2 id="创建主页面">创建主页面</h2>

<p>和使用 <a href="https://lindexi.github.io/lindexi/post/win10-uwp-%E8%BD%BB%E9%87%8F%E7%BA%A7-MVVM-%E6%A1%86%E6%9E%B6%E5%85%A5%E9%97%A8-2.1.5.3199.html">win10 uwp 轻量级 MVVM 框架入门 2.1.5.3199</a> 差不多，先创建一个项目，然后在这个项目的 MainWindow.xaml 放一个 Frame 作为跳转</p>

<p>创建 ViewModel 类，并且 MainWindow 在使用 ViewModel 属性，在 MainWindow 构造函数调用下面函数</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>            <span class="n">ViewModel</span><span class="p">.</span><span class="nf">OnNavigatedTo</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="n">frame</span><span class="p">);</span>
</code></pre></div></div>

<p>这里的 frame 就是 MainWindow 创建的 Frame，需要在 ViewModel 类继承 NavigateViewModel ，然后写 OnNavigatedTo 代码</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        <span class="k">public</span> <span class="k">override</span> <span class="k">void</span> <span class="nf">OnNavigatedTo</span><span class="p">(</span><span class="kt">object</span> <span class="n">source</span><span class="p">,</span> <span class="kt">object</span> <span class="n">e</span><span class="p">)</span>
<span class="c1">// 忽略代码</span>

                    <span class="n">Content</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">NavigateFrame</span><span class="p">((</span><span class="n">Frame</span><span class="p">)</span> <span class="n">e</span><span class="p">);</span>

</code></pre></div></div>

<p>这里可以看到 NavigateFrame 在 UWP 的框架和在 WPF 框架都存在，但是两个类的实现不相同。</p>

<p>这里设置 Content 可以让之后的页面进行导航。</p>

<h2 id="找到-viewmodel">找到 ViewModel</h2>

<p>现在在创建的 ViewModel 推荐在 App.xaml 作为资源，因为 WPF 的页面跳转没有和 UWP 一样可以获得参数，需要通过自己的方式拿到。打开 App.xaml 在里面添加 ViewModel 作为静态属性</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">&lt;</span><span class="n">Application</span> <span class="n">x</span><span class="p">:</span><span class="n">Class</span><span class="p">=</span><span class="s">"lindexi.Mvvm.App"</span>
             <span class="n">xmlns</span><span class="p">=</span><span class="s">"http://schemas.microsoft.com/winfx/2006/xaml/presentation"</span>
             <span class="n">xmlns</span><span class="p">:</span><span class="n">x</span><span class="p">=</span><span class="s">"http://schemas.microsoft.com/winfx/2006/xaml"</span>
             <span class="n">xmlns</span><span class="p">:</span><span class="n">local</span><span class="p">=</span><span class="s">"clr-namespace:lindexi.Mvvm"</span>
             <span class="n">StartupUri</span><span class="p">=</span><span class="s">"MainWindow.xaml"</span><span class="p">&gt;</span>
    <span class="p">&lt;</span><span class="n">Application</span><span class="p">.</span><span class="n">Resources</span><span class="p">&gt;</span>
         <span class="p">&lt;</span><span class="n">local</span><span class="p">:</span><span class="n">ViewModel</span> <span class="n">x</span><span class="p">:</span><span class="n">Key</span><span class="p">=</span><span class="s">"ViewModel"</span><span class="p">&gt;&lt;/</span><span class="n">local</span><span class="p">:</span><span class="n">ViewModel</span><span class="p">&gt;</span>
    <span class="p">&lt;/</span><span class="n">Application</span><span class="p">.</span><span class="n">Resources</span><span class="p">&gt;</span>
<span class="p">&lt;/</span><span class="n">Application</span><span class="p">&gt;</span>
</code></pre></div></div>

<p>现在打开 MainWindow.xaml 绑定 DataContext</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        <span class="n">DataContext</span><span class="p">=</span><span class="s">"{StaticResource ViewModel}"</span>
</code></pre></div></div>

<p>在 MainWindow 的构造函数拿到 ViewModel ，需要强转</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        <span class="k">public</span> <span class="nf">MainWindow</span><span class="p">()</span>
        <span class="p">{</span>
            <span class="nf">InitializeComponent</span><span class="p">();</span>
            <span class="n">ViewModel</span> <span class="p">=</span> <span class="p">(</span><span class="n">ViewModel</span><span class="p">)</span> <span class="n">DataContext</span><span class="p">;</span>
            <span class="n">ViewModel</span><span class="p">.</span><span class="nf">OnNavigatedTo</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="n">frame</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="k">public</span> <span class="n">ViewModel</span> <span class="n">ViewModel</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
</code></pre></div></div>

<p>这样在被跳转的页面就可以通过 ` var viewModel = ViewModel[“xx”];` 获得 ViewModel 。</p>

<h2 id="通过附加属性找到-viewmodel">通过附加属性找到 ViewModel</h2>

<p>第二个方法是通过附加属性的方法找到 ViewModel ，因为在 WPF 是可以定义可继承的附加属性，而在 UWP 是不可以自己定义可以继承的附加属性。在 WPF 可以通过定义附加属性的方式让页面拿到上一级的 ViewModel ，那么两个方法的不同在哪？如果定义为资源，那么使用比较简单。如果定义为附加属性，可以在相同的 ViewModel 被不同的地方使用，支持一个程序有多个可跳转的 ViewModel 可以做出比较复杂的程序。</p>

<p>打开 MainWindow.xaml.cs 定义一个附加属性</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        <span class="k">public</span> <span class="nf">MainWindow</span><span class="p">()</span>
        <span class="p">{</span>
            <span class="nf">InitializeComponent</span><span class="p">();</span>
        
            <span class="n">ViewModel</span> <span class="p">=</span> <span class="p">(</span><span class="n">ViewModel</span><span class="p">)</span> <span class="nf">GetValue</span><span class="p">(</span><span class="n">ViewModelProperty</span><span class="p">);</span>
            <span class="n">ViewModel</span><span class="p">.</span><span class="nf">OnNavigatedTo</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="n">frame</span><span class="p">);</span>
            <span class="n">DataContext</span> <span class="p">=</span> <span class="n">ViewModel</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">public</span> <span class="n">ViewModel</span> <span class="n">ViewModel</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>

        <span class="k">public</span> <span class="k">static</span> <span class="k">readonly</span> <span class="n">DependencyProperty</span> <span class="n">ViewModelProperty</span> <span class="p">=</span> <span class="n">DependencyProperty</span><span class="p">.</span><span class="nf">RegisterAttached</span><span class="p">(</span>
            <span class="s">"ViewModel"</span><span class="p">,</span> <span class="k">typeof</span><span class="p">(</span><span class="n">NavigateViewModel</span><span class="p">),</span> <span class="k">typeof</span><span class="p">(</span><span class="n">MainWindow</span><span class="p">),</span>
            <span class="k">new</span> <span class="nf">FrameworkPropertyMetadata</span><span class="p">(</span><span class="k">new</span> <span class="nf">ViewModel</span><span class="p">(),</span> <span class="n">FrameworkPropertyMetadataOptions</span><span class="p">.</span><span class="n">Inherits</span><span class="p">));</span>
</code></pre></div></div>

<p>这样被跳转的页面就可以通过附加属性拿到值，可以通过 ` var viewModel = ViewModel[“xx”];` 获得</p>

<h2 id="跳转页面">跳转页面</h2>

<p>现在来多创建两个页面 A 页面和 B 页面，并且创建两个页面的 ViewModel 添加到 ViewModel 的列表。</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   <span class="k">public</span> <span class="k">class</span> <span class="nc">ViewModel</span> <span class="p">:</span> <span class="n">NavigateViewModel</span>
    <span class="p">{</span>
        <span class="c1">/// &lt;inheritdoc /&gt;</span>
        <span class="k">public</span> <span class="k">override</span> <span class="k">void</span> <span class="nf">OnNavigatedTo</span><span class="p">(</span><span class="kt">object</span> <span class="n">sender</span><span class="p">,</span> <span class="kt">object</span> <span class="n">obj</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">ViewModelPage</span> <span class="p">=</span> <span class="k">new</span> <span class="n">List</span><span class="p">&lt;</span><span class="n">ViewModelPage</span><span class="p">&gt;()</span>
            <span class="p">{</span>
                <span class="k">new</span> <span class="nf">ViewModelPage</span><span class="p">(</span><span class="k">new</span> <span class="n">NavigatableViewModel</span><span class="p">&lt;</span><span class="n">AModel</span><span class="p">&gt;(),</span> <span class="k">new</span> <span class="n">NavigatablePage</span><span class="p">&lt;</span><span class="n">A</span><span class="p">&gt;()),</span>
                <span class="k">new</span> <span class="nf">ViewModelPage</span><span class="p">(</span><span class="k">new</span> <span class="n">NavigatableViewModel</span><span class="p">&lt;</span><span class="n">BModel</span><span class="p">&gt;(),</span> <span class="k">new</span> <span class="n">NavigatablePage</span><span class="p">&lt;</span><span class="n">B</span><span class="p">&gt;())</span>
            <span class="p">};</span>

            <span class="n">Content</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">NavigateFrame</span><span class="p">((</span><span class="n">Frame</span><span class="p">)</span> <span class="n">obj</span><span class="p">);</span>

            <span class="nf">Navigate</span><span class="p">(</span><span class="s">"AModel"</span><span class="p">,</span> <span class="k">null</span><span class="p">);</span>
        <span class="p">}</span>


    <span class="p">}</span>

    <span class="k">public</span> <span class="k">class</span> <span class="nc">AModel</span> <span class="p">:</span> <span class="n">ViewModelMessage</span>
    <span class="p">{</span>
        <span class="c1">/// &lt;inheritdoc /&gt;</span>
        <span class="k">public</span> <span class="k">override</span> <span class="k">void</span> <span class="nf">OnNavigatedFrom</span><span class="p">(</span><span class="kt">object</span> <span class="n">sender</span><span class="p">,</span> <span class="kt">object</span> <span class="n">obj</span><span class="p">)</span>
        <span class="p">{</span>
        <span class="p">}</span>

        <span class="c1">/// &lt;inheritdoc /&gt;</span>
        <span class="k">public</span> <span class="k">override</span> <span class="k">void</span> <span class="nf">OnNavigatedTo</span><span class="p">(</span><span class="kt">object</span> <span class="n">sender</span><span class="p">,</span> <span class="kt">object</span> <span class="n">obj</span><span class="p">)</span>
        <span class="p">{</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">public</span> <span class="k">class</span> <span class="nc">BModel</span> <span class="p">:</span> <span class="n">ViewModelMessage</span>
    <span class="p">{</span>
        <span class="c1">/// &lt;inheritdoc /&gt;</span>
        <span class="k">public</span> <span class="k">override</span> <span class="k">void</span> <span class="nf">OnNavigatedFrom</span><span class="p">(</span><span class="kt">object</span> <span class="n">sender</span><span class="p">,</span> <span class="kt">object</span> <span class="n">obj</span><span class="p">)</span>
        <span class="p">{</span>
        <span class="p">}</span>

        <span class="c1">/// &lt;inheritdoc /&gt;</span>
        <span class="k">public</span> <span class="k">override</span> <span class="k">void</span> <span class="nf">OnNavigatedTo</span><span class="p">(</span><span class="kt">object</span> <span class="n">sender</span><span class="p">,</span> <span class="kt">object</span> <span class="n">obj</span><span class="p">)</span>
        <span class="p">{</span>
        <span class="p">}</span>
    <span class="p">}</span>
</code></pre></div></div>

<p>添加 ViewModel 到 ViewModelPage 的方法就是通过创建 ViewModelPage 合并，创建的时候提供两个方法，一个是输入 Type 的方法，另一个是泛型。输入 Type 的方法是用来反射，很少推荐使用。</p>

<p>修改 A 页面的背景，可以用来看到被跳转到 A 页面</p>

<!-- ![](image/WPF 轻量级 MVVM 框架入门 2.1.2/WPF 轻量级 MVVM 框架入门 2.1.20.png) -->

<p><img src="http://image.acmx.xyz/lindexi%2F2018630153375515.jpg" alt="" /></p>

<p>本文使用的是上面的第一个方式拿到 ViewModel 所以需要在 A 页面添加一些代码获得 ViewModel 。</p>

<p>在 A 页面的 xaml 添加下面代码</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>      <span class="n">DataContext</span><span class="p">=</span><span class="s">"{Binding Source={StaticResource ViewModel},Path=[AModel]}"</span>

</code></pre></div></div>

<p>这样就可以通过 <code class="language-plaintext highlighter-rouge">NavigateViewModel["xx"]</code> 的方法获得 ViewModel</p>

<h2 id="跳转命令">跳转命令</h2>

<p>可以看到在　Ａ 页面有跳转按钮，点击这个按钮可以用来跳转到 B 页面</p>

<p>因为界面很简单，我就不告诉大家了。</p>

<p>打开 AModel 添加一个函数，在这个函数就是按钮点击下去调用的函数</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>            <span class="nf">Send</span><span class="p">(</span><span class="k">new</span> <span class="nf">NavigateMessage</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="k">nameof</span><span class="p">(</span><span class="n">BModel</span><span class="p">)));</span>

</code></pre></div></div>

<p>从代码可以看到跳转到 B 页面只需要发送一个 NavigateMessage ，具体怎么跳转是不需要写的</p>

<h2 id="自定义命令">自定义命令</h2>

<p>现在可以尝试使用框架的用法，自己定义消息和处理</p>

<p>在 B 页面发送文字到 MainWindow 显示，不让 BModel 和 ViewModel 有耦合，减少在 BModel 和在 ViewModel 的代码。</p>

<p>如果 ViewModel 要让 MainWindows 显示文字，就需要在 ViewModel 添加属性</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code> 	        <span class="k">public</span> <span class="kt">string</span> <span class="n">SawbelChaceredis</span>
        <span class="p">{</span>
            <span class="k">get</span> <span class="p">=&gt;</span> <span class="n">_sawbelChaceredis</span><span class="p">;</span>
            <span class="k">set</span>
            <span class="p">{</span>
                <span class="n">_sawbelChaceredis</span> <span class="p">=</span> <span class="k">value</span><span class="p">;</span>
                <span class="nf">OnPropertyChanged</span><span class="p">();</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="k">private</span> <span class="kt">string</span> <span class="n">_sawbelChaceredis</span><span class="p">;</span>
</code></pre></div></div>

<p>这个属性是我随意定义，因为也不知道这个属性叫什么</p>

<p>在 ViewModel 有特殊的属性，可以定义一个接口，表示这个 ViewModel 有 属性 SawbelChaceredis ，定义的代码</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="k">public</span> <span class="k">interface</span> <span class="nc">ISawbelChaceredisModel</span> <span class="p">:</span> <span class="n">IViewModel</span>
    <span class="p">{</span>
        <span class="kt">string</span> <span class="n">SawbelChaceredis</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
    <span class="p">}</span>
</code></pre></div></div>

<p>在 MainWindow 绑定这个属性</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        <span class="p">&lt;</span><span class="n">TextBlock</span> <span class="n">Margin</span><span class="p">=</span><span class="s">"10,200,10,10"</span> <span class="n">Text</span><span class="p">=</span><span class="s">"{Binding SawbelChaceredis,Mode=OneWay}"</span> <span class="p">/&gt;</span>

</code></pre></div></div>

<p>已经让 ViewModel 绑定了页面，这时的 ViewModel 和界面没有耦合</p>

<p>定义消息用来发送字符串到 ISawbelChaceredisModel ，定义的方法请看代码</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="k">public</span> <span class="k">class</span> <span class="nc">TextMessage</span> <span class="p">:</span> <span class="n">Message</span>
    <span class="p">{</span>
        <span class="c1">/// &lt;inheritdoc /&gt;</span>
        <span class="k">public</span> <span class="nf">TextMessage</span><span class="p">(</span><span class="n">ViewModelBase</span> <span class="n">source</span><span class="p">,</span> <span class="kt">string</span> <span class="n">str</span><span class="p">)</span> <span class="p">:</span> <span class="k">base</span><span class="p">(</span><span class="n">source</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">SawbelChaceredis</span> <span class="p">=</span> <span class="n">str</span><span class="p">;</span>
            <span class="n">Goal</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">PredicateInheritViewModel</span><span class="p">(</span><span class="k">typeof</span><span class="p">(</span><span class="n">ISawbelChaceredisModel</span><span class="p">));</span>
        <span class="p">}</span>

        <span class="k">public</span> <span class="kt">string</span> <span class="n">SawbelChaceredis</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="p">}</span>
    <span class="p">}</span>
</code></pre></div></div>

<p>定义的消息使用了 PredicateInheritViewModel 表示这个消息会发送到 ISawbelChaceredisModel ，如果没有找到 ISawbelChaceredisModel 就没有处理消息</p>

<p>定义了消息还需要定一个类告诉如何处理这个消息</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="k">public</span> <span class="k">class</span> <span class="nc">SawbelChaceredisComposite</span> <span class="p">:</span> <span class="n">Composite</span>
    <span class="p">{</span>
        <span class="c1">/// &lt;inheritdoc /&gt;</span>
        <span class="k">public</span> <span class="nf">SawbelChaceredisComposite</span><span class="p">()</span>
        <span class="p">{</span>
            <span class="n">Message</span> <span class="p">=</span> <span class="k">typeof</span><span class="p">(</span><span class="n">TextMessage</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="c1">/// &lt;inheritdoc /&gt;</span>
        <span class="k">public</span> <span class="k">override</span> <span class="k">void</span> <span class="nf">Run</span><span class="p">(</span><span class="n">IViewModel</span> <span class="n">source</span><span class="p">,</span> <span class="n">IMessage</span> <span class="n">message</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="kt">var</span> <span class="n">viewModel</span> <span class="p">=</span> <span class="p">(</span><span class="n">ISawbelChaceredisModel</span><span class="p">)</span> <span class="n">source</span><span class="p">;</span>
            <span class="n">viewModel</span><span class="p">.</span><span class="n">SawbelChaceredis</span> <span class="p">=</span> <span class="p">((</span><span class="n">TextMessage</span><span class="p">)</span> <span class="n">message</span><span class="p">).</span><span class="n">SawbelChaceredis</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
</code></pre></div></div>

<p>定义了这个类就告诉哪个消息可以处理，在构造函数的代码。然后使用 Run 处理这个消息。因为 SawbelChaceredisComposite 和消息是耦合的，只有处理知道消息，所以这里可以转换 ViewModel 因为这时知道是哪个收到</p>

<p>这里的处理还可以继承<code class="language-plaintext highlighter-rouge">Composite&lt;T&gt;</code> 这里的泛型就是消息的类型，可以把上面的代码减小，不需要写构造函数</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="k">public</span> <span class="k">class</span> <span class="nc">SawbelChaceredisComposite</span> <span class="p">:</span> <span class="n">Composite</span><span class="p">&lt;</span><span class="n">TextMessage</span><span class="p">&gt;</span>
    <span class="p">{</span>
        <span class="c1">/// &lt;inheritdoc /&gt;</span>
        <span class="k">protected</span> <span class="k">override</span> <span class="k">void</span> <span class="nf">Run</span><span class="p">(</span><span class="n">IViewModel</span> <span class="n">source</span><span class="p">,</span> <span class="n">TextMessage</span> <span class="n">message</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="kt">var</span> <span class="n">viewModel</span> <span class="p">=</span> <span class="p">(</span><span class="n">ISawbelChaceredisModel</span><span class="p">)</span> <span class="n">source</span><span class="p">;</span>
            <span class="n">viewModel</span><span class="p">.</span><span class="n">SawbelChaceredis</span> <span class="p">=</span> <span class="n">message</span><span class="p">.</span><span class="n">SawbelChaceredis</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
</code></pre></div></div>

<p>在 B 页面点击时，发送消息</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="k">public</span> <span class="k">class</span> <span class="nc">BModel</span> <span class="p">:</span> <span class="n">ViewModelMessage</span>
    <span class="p">{</span>
        <span class="c1">/// &lt;inheritdoc /&gt;</span>
        <span class="k">public</span> <span class="k">override</span> <span class="k">void</span> <span class="nf">OnNavigatedFrom</span><span class="p">(</span><span class="kt">object</span> <span class="n">sender</span><span class="p">,</span> <span class="kt">object</span> <span class="n">obj</span><span class="p">)</span>
        <span class="p">{</span>
        <span class="p">}</span>

        <span class="c1">/// &lt;inheritdoc /&gt;</span>
        <span class="k">public</span> <span class="k">override</span> <span class="k">void</span> <span class="nf">OnNavigatedTo</span><span class="p">(</span><span class="kt">object</span> <span class="n">sender</span><span class="p">,</span> <span class="kt">object</span> <span class="n">obj</span><span class="p">)</span>
        <span class="p">{</span>
        <span class="p">}</span>

        <span class="k">public</span> <span class="k">void</span> <span class="nf">SendText</span><span class="p">()</span>
        <span class="p">{</span>
            <span class="nf">Send</span><span class="p">(</span><span class="k">new</span> <span class="nf">TextMessage</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="s">"欢迎来我博客 https://lindexi.github.io/lindexi/ 有很多无聊博客"</span><span class="p">));</span>
        <span class="p">}</span>
    <span class="p">}</span>
</code></pre></div></div>

<p>通过发送消息就可以把消息发送到界面</p>

<p>代码：<a href="https://download.csdn.net/download/lindexi_gd/10510505">WPF 轻量级 MVVM 框架入门 2.1.2-CSDN下载</a></p>

<p>参见：</p>

<p><a href="https://blog.lindexi.com/post/win10-uwp-MVVM%E5%85%A5%E9%97%A8.html">win10 uwp MVVM入门</a></p>

<p><a href="https://lindexi.gitee.io/post/win10-uwp-MVVM-%E8%BD%BB%E9%87%8F%E6%A1%86%E6%9E%B6.html">win10 uwp MVVM 轻量框架</a></p>

<p><a href="https://lindexi.gitee.io/post/win10-uwp-MVVM-%E8%AF%AD%E4%B9%89%E8%80%A6%E5%90%88.html">win10 uwp MVVM 语义耦合</a></p>

<p><img src="https://i.loli.net/2018/07/01/5b38378f43731.jpg" alt="" /></p>

:ET