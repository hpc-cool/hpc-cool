I"W<!-- 下面说的C# 7.0功能将在未来发布，首先需要安装Visual Studio 15 Preview 4，听说这个版本安装很快。 -->
<p>C# 7.0 可以在 VS 17 使用，这个版本我下载企业版上传百度云，有需要可以到文章最后去<a href="#VS 17 下载">下载</a>。
本文主要：C# 7.0 带来的新功能</p>
<ul>
  <li>out 返回值定义</li>
  <li>Tuples</li>
  <li>模式匹配</li>
  <li>ref 返回本地值</li>
  <li>内部函数</li>
  <li>全部地方可以支持辣么大</li>
  <li>在表达式扔异常</li>
  <li>广义异步返回类型</li>
  <li>数值常量语法 
顺便告诉大家 7.1 的新特性</li>
  <li>支持 async 的主函数</li>
  <li>默认值不需要写类型</li>
  <li>自动推断 Tuple 的名称</li>
  <li>值引用</li>
  <li>指定位置命名参数</li>
  <li>private protected 访问修饰</li>
  <li>字符常量下划线可以放在最前</li>
</ul>

<!--more-->

<!-- CreateTime:2018/11/24 16:32:58 -->

<div id="toc"></div>

<p>C# 7.0的功能主要是数据处理，让代码更简洁，让代码性能更高</p>

<p>让代码简单这个我觉得不如6.0，性能WR为了Iot做的。C#速度差，垃圾wr就让C#可以直接访问内存，让速度变快，这个下面没有说</p>

<p>C# 7.0 最好的是 使用 Tuple 。虽然之前也有，但是现在版本比较好用。实际抄袭了某脚本。</p>

<!-- 比较大修改是可以使用Tuples 来多个返回，其实是抄袭了某脚本 -->

<!-- 多返回这个在之前也有做，他这样就是小改。 -->

<p>修改大的有 Case 。模式匹配，可以判断类型，其实这个使用是我们有类 a，类b、c继承a，这时使用就比较好，如何使用在下面会说。</p>

<p>如果觉得这个功能没有用，可以去 Visual studio 按反馈喷</p>

<!-- 如果觉得这个和我一样觉得没用，可以去Visual studio 按反馈喷 -->

<p>如果好奇他是怎么弄，可以查看https://github.com/dotnet/roslyn</p>

<h2 id="out-返回值定义">out 返回值定义</h2>

<p>我们以前要使用 out 总是需要在外面定义我们变量。</p>

<p>首先定义一个 变量，使用函数，这样觉得需要多写代码</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="k">public</span> <span class="k">void</span> <span class="nf">PrintCoordinates</span><span class="p">(</span><span class="n">Point</span> <span class="n">p</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">;</span> <span class="c1">// 在外面定义</span>
    <span class="n">p</span><span class="p">.</span><span class="nf">GetCoordinates</span><span class="p">(</span><span class="k">out</span> <span class="n">x</span><span class="p">,</span> <span class="k">out</span> <span class="n">y</span><span class="p">);</span>
    <span class="nf">WriteLine</span><span class="p">(</span><span class="s">$"(</span><span class="p">{</span><span class="n">x</span><span class="p">}</span><span class="s">, </span><span class="p">{</span><span class="n">y</span><span class="p">}</span><span class="s">)"</span><span class="p">);</span>
  <span class="p">}</span>
</code></pre></div></div>

<p>在7.0我们可以使用在 out 定义我们变量，这样看起来不是在一个区域，但是可以减少我的代码</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="k">void</span> <span class="nf">PrintCoordinates</span><span class="p">(</span><span class="n">Point</span> <span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">p</span><span class="p">.</span><span class="nf">GetCoordinates</span><span class="p">(</span><span class="k">out</span> <span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="k">out</span> <span class="kt">int</span> <span class="n">y</span><span class="p">);</span>
    <span class="nf">WriteLine</span><span class="p">(</span><span class="s">$"(</span><span class="p">{</span><span class="n">x</span><span class="p">}</span><span class="s">, </span><span class="p">{</span><span class="n">y</span><span class="p">}</span><span class="s">)"</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>在 out 定义类型，定义可以用var</p>

<p>看到这我才说这样有用，如果我们开始没有确定我们返回的是什么，然后直接定义，需要修改地方多，但是如果我们使用Var就可以让我们定义修改少，一般在写就需要先想我们需要用什么，不要总是改</p>

<p>如果我们使用一个返回为bool，那么可以在{使用out的值</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="k">public</span> <span class="k">void</span> <span class="nf">PrintStars</span><span class="p">(</span><span class="kt">string</span> <span class="n">s</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">//转换，可以是数字，显示</span>
    <span class="k">if</span> <span class="p">(</span><span class="kt">int</span><span class="p">.</span><span class="nf">TryParse</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="k">out</span> <span class="kt">var</span> <span class="n">i</span><span class="p">))</span> <span class="p">{</span> <span class="nf">WriteLine</span><span class="p">(</span><span class="k">new</span> <span class="kt">string</span><span class="p">(</span><span class="sc">'*'</span><span class="p">,</span> <span class="n">i</span><span class="p">));</span> <span class="p">}</span>
    <span class="k">else</span> <span class="p">{</span> <span class="nf">WriteLine</span><span class="p">(</span><span class="s">"Cloudy - no stars tonight!"</span><span class="p">);</span> <span class="p">}</span>
<span class="p">}</span>

</code></pre></div></div>

<p>== 下面代码被WR删了，以前有说到，现实wr没有做</p>

<p>如果有返回值我们不需要，可以out *，这样我们就不用知道这个返回值，原先不需要使用我还要想一个变量，然后vs说我这个没有使用，现在我们直接就不给他名</p>

<p>在我们下面有返回多个，这时不需要的可以用*</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="k">public</span> <span class="k">void</span> <span class="nf">PrintStars</span><span class="p">(</span><span class="kt">string</span> <span class="n">s</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">//转换，可以是数字，显示</span>
    <span class="k">if</span> <span class="p">(</span><span class="kt">int</span><span class="p">.</span><span class="nf">TryParse</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="k">out</span> <span class="p">*))</span> <span class="p">{</span> <span class="nf">WriteLine</span><span class="p">(</span><span class="s">"转换成功"</span><span class="p">);</span> <span class="p">}</span>
    <span class="k">else</span> <span class="p">{</span> <span class="nf">WriteLine</span><span class="p">(</span><span class="s">"转换失败"</span><span class="p">);</span> <span class="p">}</span>
<span class="p">}</span>

</code></pre></div></div>

<p>== 上面代码WR没有做，不需要的返回值是可以使用<code class="language-plaintext highlighter-rouge">_</code></p>

<h2 id="模式匹配">模式匹配</h2>

<p>模式匹配是包括 is 和 switch ，下面先说 is</p>

<p>C# 7.0可以使用 is 一部分代替 as</p>

<p>我们需要判断一个值是否是一个类型，如果是那么赋值，在以前，使用的代码需要两行</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="k">if</span><span class="p">(</span><span class="n">o</span> <span class="k">is</span> <span class="kt">int</span><span class="p">)</span>
    <span class="p">{</span>

        <span class="kt">int</span> <span class="n">i</span><span class="p">=(</span><span class="kt">int</span><span class="p">)</span> <span class="n">o</span><span class="p">;</span>
    <span class="p">}</span>
</code></pre></div></div>

<p>还可以使用 as</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="kt">int</span><span class="p">?</span> <span class="n">i</span> <span class="p">=</span> <span class="n">o</span> <span class="k">as</span> <span class="kt">int</span><span class="p">;</span>
</code></pre></div></div>

<p>但是在新的C#，可以使用</p>

<p><code class="language-plaintext highlighter-rouge">o is int i</code></p>

<p>那么我们就可以直接使用i</p>

<p>在我们一个判断，如果我们存在了object o是int，那么我们就使用<code class="language-plaintext highlighter-rouge">int i=(int)o;</code></p>

<p>如果我们object不是int，那么转换object o是string，<code class="language-plaintext highlighter-rouge">string s=(string)o;</code></p>

<p>这也就是对下面的语句</p>

<p><code class="language-plaintext highlighter-rouge">int.TryParse(s,out i);</code></p>

<p>我们可以简化，判断是不是int，如果是给i，这时就返回true</p>

<p>然后判断是不是string，是就转，成功使用i</p>

<p><code class="language-plaintext highlighter-rouge">if (o is int i || (o is string s &amp;&amp; int.TryParse(s, out i)) { /* use i */ }</code></p>

<p>但是 is 的用法在于 switch</p>

<p>我们在Case可以选择类型</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">switch</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span> 
<span class="p">{</span>
    <span class="k">case</span> <span class="n">Circle</span> <span class="n">c</span><span class="p">:</span>
        <span class="nf">WriteLine</span><span class="p">(</span><span class="s">$"circle with radius </span><span class="p">{</span><span class="n">c</span><span class="p">.</span><span class="n">Radius</span><span class="p">}</span><span class="s">"</span><span class="p">);</span>
        <span class="k">break</span><span class="p">;</span>
    <span class="k">case</span> <span class="n">Rectangle</span> <span class="n">s</span> <span class="nf">when</span> <span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="n">Length</span> <span class="p">==</span> <span class="n">s</span><span class="p">.</span><span class="n">Height</span><span class="p">):</span>
        <span class="nf">WriteLine</span><span class="p">(</span><span class="s">$"</span><span class="p">{</span><span class="n">s</span><span class="p">.</span><span class="n">Length</span><span class="p">}</span><span class="s"> x </span><span class="p">{</span><span class="n">s</span><span class="p">.</span><span class="n">Height</span><span class="p">}</span><span class="s"> square"</span><span class="p">);</span>
        <span class="k">break</span><span class="p">;</span>
    <span class="k">case</span> <span class="n">Rectangle</span> <span class="n">r</span><span class="p">:</span>
        <span class="nf">WriteLine</span><span class="p">(</span><span class="s">$"</span><span class="p">{</span><span class="n">r</span><span class="p">.</span><span class="n">Length</span><span class="p">}</span><span class="s"> x </span><span class="p">{</span><span class="n">r</span><span class="p">.</span><span class="n">Height</span><span class="p">}</span><span class="s"> rectangle"</span><span class="p">);</span>
        <span class="k">break</span><span class="p">;</span>
    <span class="k">default</span><span class="p">:</span>
        <span class="nf">WriteLine</span><span class="p">(</span><span class="s">"&lt;unknown shape&gt;"</span><span class="p">);</span>
        <span class="k">break</span><span class="p">;</span>
    <span class="k">case</span> <span class="k">null</span><span class="p">:</span>
        <span class="k">throw</span> <span class="k">new</span> <span class="nf">ArgumentNullException</span><span class="p">(</span><span class="k">nameof</span><span class="p">(</span><span class="n">shape</span><span class="p">));</span>
<span class="p">}</span>
</code></pre></div></div>

<p>case 顺序很重要，可以看到可以判断类型，但是 case 还可以混合判断。</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>                <span class="k">switch</span> <span class="p">(</span><span class="n">item</span><span class="p">)</span>
                <span class="p">{</span>
                    <span class="k">default</span><span class="p">:</span>
                        <span class="k">throw</span> <span class="k">new</span> <span class="nf">InvalidOperationException</span><span class="p">(</span><span class="s">"unknown item type"</span><span class="p">);</span> 

                    <span class="k">case</span> <span class="m">0</span><span class="p">:</span>
                        <span class="k">break</span><span class="p">;</span>

                    <span class="k">case</span> <span class="kt">int</span> <span class="n">val</span><span class="p">:</span>
                        <span class="n">sum</span> <span class="p">+=</span> <span class="n">val</span><span class="p">;</span>
                        <span class="k">break</span><span class="p">;</span>

                    <span class="k">case</span> <span class="kt">var</span> <span class="n">@var</span> <span class="nf">when</span> <span class="p">(</span><span class="n">@var</span> <span class="p">!=</span> <span class="k">null</span> <span class="p">&amp;&amp;</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="p">(</span><span class="n">@var</span><span class="p">)</span> <span class="p">==</span> <span class="m">45</span><span class="p">):</span>
                        <span class="k">break</span><span class="p">;</span>

                    <span class="c1">//  The order of case clauses now matters!</span>
                    <span class="k">case</span> <span class="n">IEnumerable</span><span class="p">&lt;</span><span class="kt">object</span><span class="p">&gt;</span> <span class="n">subList</span> <span class="n">when</span> <span class="n">subList</span><span class="p">.</span><span class="nf">Any</span><span class="p">():</span>
                        <span class="n">sum</span> <span class="p">+=</span> <span class="nf">Sum</span><span class="p">(</span><span class="n">subList</span><span class="p">);</span>
                        <span class="k">break</span><span class="p">;</span>

                    <span class="k">case</span> <span class="n">IEnumerable</span><span class="p">&lt;</span><span class="kt">object</span><span class="p">&gt;</span> <span class="n">subList</span><span class="p">:</span>
                        <span class="k">break</span><span class="p">;</span>

                    <span class="k">case</span> <span class="k">null</span><span class="p">:</span>
                        <span class="k">break</span><span class="p">;</span>
                <span class="p">}</span>
</code></pre></div></div>

<p>注意 default 在最后，即使他后面有语句，除非存在语句识别，那么最后会执行他。</p>

<h2 id="tuples">Tuples</h2>

<p>以前我们需要返回多个有点难，可以使用out参数，可以<code class="language-plaintext highlighter-rouge">Tuples&lt;string,double&gt;</code></p>

<p>我们做了修改，可以使用新的方法，这样我们返回多个就可以直接和某垃圾语言那返回</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="p">(</span><span class="kt">string</span><span class="p">,</span> <span class="kt">string</span><span class="p">,</span> <span class="kt">string</span><span class="p">)</span> <span class="nf">LookupName</span><span class="p">(</span><span class="kt">long</span> <span class="n">id</span><span class="p">)</span> <span class="c1">// tuple return type</span>
<span class="p">{</span>
    <span class="p">...</span> <span class="c1">// 返回多个数据，我们在数据拿到多个数据</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">first</span><span class="p">,</span> <span class="n">middle</span><span class="p">,</span> <span class="n">last</span><span class="p">);</span> <span class="c1">// tuple literal</span>
<span class="p">}</span>

</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">var names = LookupName(id);</code></p>

<p>我们这样用第一返回值：<code class="language-plaintext highlighter-rouge">names.Item1</code>和原来几乎没有修改，这样对于返回值不好，因为我们难以去记，哪个返回值是什么</p>

<p>我们要给他一个好记的 变量，可以写在函数定义</p>

<p><code class="language-plaintext highlighter-rouge">(string first, string middle, string last) LookupName(long id)</code></p>

<p>我们使用第一个<code class="language-plaintext highlighter-rouge">names.first</code>，这样使用就容易，原因是可以给一个表达他是意思的变量。</p>

<p>返回可以使用<code class="language-plaintext highlighter-rouge">return (first, middle, last);</code>，必须和之前定义顺序一样，但如果定义了名称，可以使用</p>

<p><code class="language-plaintext highlighter-rouge">return last:last,first:first</code></p>

<p>这个方法是很好的，不需要和定义的顺序那样。</p>

<p>对于调用函数，可以使用一个变量，可以使用多个变量</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="p">(</span><span class="kt">string</span> <span class="n">first</span><span class="p">,</span> <span class="kt">string</span> <span class="n">middle</span><span class="p">,</span> <span class="kt">string</span> <span class="n">last</span><span class="p">)</span> <span class="p">=</span> <span class="nf">LookupName</span><span class="p">(</span><span class="n">id1</span><span class="p">);</span>
    <span class="kt">var</span> <span class="n">name</span> <span class="p">=</span> <span class="nf">LookupName</span><span class="p">(</span><span class="n">id1</span><span class="p">);</span>
</code></pre></div></div>

<p>可以看到两个代码，作用一样，但是第一个代码除了使用变量类型，同样可以使用 <code class="language-plaintext highlighter-rouge">var</code></p>

<!-- 第一个first就是返回的第一个，我们可以使用var ，因为我们不需要定义类型 -->

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="p">(</span><span class="kt">var</span> <span class="n">fist</span><span class="p">,</span><span class="kt">var</span> <span class="n">midd</span><span class="p">)=</span><span class="nf">Lookup</span><span class="p">(</span><span class="n">id</span><span class="p">);</span>

</code></pre></div></div>

<p>如果我们有多个var，那么我们可以简单<code class="language-plaintext highlighter-rouge">var (first, middle, last) = LookupName(id1);</code>定义所有变量</p>

<!-- 我们不关系第二个返回值，可以使用`（var first,*)=Lookup(id);` -->

<p>除了方法使用，可以在变量使用</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>                <span class="kt">var</span> <span class="n">sumNew</span> <span class="p">=</span> <span class="p">(</span><span class="n">first</span><span class="p">:</span> <span class="m">1</span><span class="p">,</span> <span class="n">count</span><span class="p">:</span> <span class="m">20</span><span class="p">);</span>

</code></pre></div></div>
<p>这样就定义了一个，可以使用他的名称，不使用 <code class="language-plaintext highlighter-rouge">item</code>原先的，也就是在定义，给他变量。</p>

<p>上面代码的意思：可以定义一个包括每项名称的变量，可以在使用时，用定义的变量</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>            <span class="kt">var</span> <span class="n">sumNew</span> <span class="p">=</span> <span class="p">(</span><span class="n">first</span><span class="p">:</span> <span class="m">1</span><span class="p">,</span> <span class="n">count</span><span class="p">:</span> <span class="m">20</span><span class="p">);</span>
            <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="s">$"first </span><span class="p">{</span><span class="n">sumNew</span><span class="p">.</span><span class="n">first</span><span class="p">}</span><span class="s">  count </span><span class="p">{</span><span class="n">sumNew</span><span class="p">.</span><span class="n">count</span><span class="p">}</span><span class="s">"</span><span class="p">);</span>
</code></pre></div></div>

<p>如果不想在定义写变量，那么可以修改<code class="language-plaintext highlighter-rouge">var</code>，作为变量</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>      <span class="p">(</span><span class="kt">int</span> <span class="n">first</span><span class="p">,</span> <span class="kt">int</span> <span class="n">count</span><span class="p">)</span> <span class="n">sum</span> <span class="p">=</span> <span class="p">(</span> <span class="m">1</span><span class="p">,</span>  <span class="m">20</span><span class="p">);</span>
      <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="s">$"first </span><span class="p">{</span><span class="n">sum</span><span class="p">.</span><span class="n">first</span><span class="p">}</span><span class="s">  count </span><span class="p">{</span><span class="n">sum</span><span class="p">.</span><span class="n">count</span><span class="p">}</span><span class="s">"</span><span class="p">);</span>
</code></pre></div></div>

<p>这里，类型<code class="language-plaintext highlighter-rouge">int</code>不能写 <code class="language-plaintext highlighter-rouge">var</code></p>

<p>如果想不到变量，那么只能使用</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>            <span class="p">(</span><span class="kt">int</span> <span class="p">,</span> <span class="kt">int</span> <span class="p">)</span> <span class="n">sum</span> <span class="p">=</span> <span class="p">(</span> <span class="m">1</span><span class="p">,</span>  <span class="m">20</span><span class="p">);</span>
            <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="s">$"first </span><span class="p">{</span><span class="n">sum</span><span class="p">.</span><span class="n">Item1</span><span class="p">}</span><span class="s">  count </span><span class="p">{</span><span class="n">sum</span><span class="p">.</span><span class="n">Item2</span><span class="p">}</span><span class="s">"</span><span class="p">);</span>
</code></pre></div></div>

<p>如果使用的不是 .net Framework 4.7 那么引用 ValueTuple 才可以。除了支持多个返回值，实际 ValueTuple 可以作为附加在类的新字段，一般在列表使用。</p>

<p>例如我有一个类 Foo 里面只有一个属性 Name ，但是在 ViewModel 需要他有 Check 属性表示是否选中。那么可以使用 ValueTuple 添加这个属性。</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">List</span><span class="p">&lt;(</span><span class="n">Foo</span> <span class="n">foo</span><span class="p">,</span><span class="kt">bool</span> <span class="n">check</span><span class="p">)&gt;</span> <span class="n">Foo</span>
</code></pre></div></div>

<h2 id="本地函数">本地函数</h2>

<p>我们可以在函数里面定义函数，这是本地函数</p>

<!-- 这个在很多垃圾语言都有 -->

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="kt">int</span> <span class="nf">Fibonacci</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">x</span> <span class="p">&lt;</span> <span class="m">0</span><span class="p">)</span> <span class="k">throw</span> <span class="k">new</span> <span class="nf">ArgumentException</span><span class="p">(</span><span class="s">"Less negativity please!"</span><span class="p">,</span> <span class="k">nameof</span><span class="p">(</span><span class="n">x</span><span class="p">));</span>
    <span class="k">return</span> <span class="nf">Fib</span><span class="p">(</span><span class="n">x</span><span class="p">).</span><span class="n">current</span><span class="p">;</span>
    <span class="c1">//下面 本地函数</span>
    <span class="p">(</span><span class="kt">int</span> <span class="n">current</span><span class="p">,</span> <span class="kt">int</span> <span class="n">previous</span><span class="p">)</span> <span class="nf">Fib</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="p">==</span> <span class="m">0</span><span class="p">)</span> <span class="k">return</span> <span class="p">(</span><span class="m">1</span><span class="p">,</span> <span class="m">0</span><span class="p">);</span>
        <span class="kt">var</span> <span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">pp</span><span class="p">)</span> <span class="p">=</span> <span class="nf">Fib</span><span class="p">(</span><span class="n">i</span> <span class="p">-</span> <span class="m">1</span><span class="p">);</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">p</span> <span class="p">+</span> <span class="n">pp</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>以前有些函数只会使用一次，但是他的功能多，所以就把它写成方法，于是一个类就很多这种方法，只会在一个函数使用，但是写成方法，有时候开始看他，会觉得方法很多，不知道哪个方法在哪使用。</p>

<p>上面说的是那些没使用 vs 企业版的兄弟，其实有了企业版，没有这问题。</p>

<p>现在可以使用内部函数，在一个函数里定义函数，看上面的代码，写一个斐波纳算法，可以直接使用函数里函数，不需要定义方法。</p>

<p>这个用法在：迭代，异步</p>

<p>对于迭代器，抛出异常在使用，不是创建。</p>

<p>看下这代码</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="k">static</span> <span class="n">IEnumerable</span><span class="p">&lt;</span><span class="kt">char</span><span class="p">&gt;</span> <span class="nf">AlphabetSubset</span><span class="p">(</span><span class="kt">char</span> <span class="n">start</span><span class="p">,</span> <span class="kt">char</span> <span class="n">end</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">((</span><span class="n">start</span> <span class="p">&lt;</span> <span class="sc">'a'</span><span class="p">)</span> <span class="p">||</span> <span class="p">(</span><span class="n">start</span> <span class="p">&gt;</span> <span class="sc">'z'</span><span class="p">))</span>
        <span class="k">throw</span> <span class="k">new</span> <span class="nf">ArgumentOutOfRangeException</span><span class="p">(</span><span class="n">paramName</span><span class="p">:</span> <span class="k">nameof</span><span class="p">(</span><span class="n">start</span><span class="p">),</span> <span class="n">message</span><span class="p">:</span> <span class="s">"start must be a letter"</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">((</span><span class="n">end</span> <span class="p">&lt;</span> <span class="sc">'a'</span><span class="p">)</span> <span class="p">||</span> <span class="p">(</span><span class="n">end</span> <span class="p">&gt;</span> <span class="sc">'z'</span><span class="p">))</span>
        <span class="k">throw</span> <span class="k">new</span> <span class="nf">ArgumentOutOfRangeException</span><span class="p">(</span><span class="n">paramName</span><span class="p">:</span> <span class="k">nameof</span><span class="p">(</span><span class="n">end</span><span class="p">),</span> <span class="n">message</span><span class="p">:</span> <span class="s">"end must be a letter"</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">end</span> <span class="p">&lt;=</span> <span class="n">start</span><span class="p">)</span>
        <span class="k">throw</span> <span class="k">new</span> <span class="nf">ArgumentException</span><span class="p">(</span><span class="s">$"</span><span class="p">{</span><span class="k">nameof</span><span class="p">(</span><span class="n">end</span><span class="p">)}</span><span class="s"> must be greater than </span><span class="p">{</span><span class="k">nameof</span><span class="p">(</span><span class="n">start</span><span class="p">)}</span><span class="s">"</span><span class="p">);</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">var</span> <span class="n">c</span> <span class="p">=</span> <span class="n">start</span><span class="p">;</span> <span class="n">c</span> <span class="p">&lt;</span> <span class="n">end</span><span class="p">;</span> <span class="n">c</span><span class="p">++)</span>
        <span class="k">yield</span> <span class="k">return</span> <span class="n">c</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>在输入不合法，就会抛出异常，那么抛出异常的时候是什么</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="kt">var</span> <span class="n">resultSet</span> <span class="p">=</span> <span class="n">Iterator</span><span class="p">.</span><span class="nf">AlphabetSubset</span><span class="p">(</span><span class="sc">'f'</span><span class="p">,</span> <span class="sc">'a'</span><span class="p">);</span>
<span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="s">"iterator created"</span><span class="p">);</span>
<span class="k">foreach</span> <span class="p">(</span><span class="kt">var</span> <span class="n">thing</span> <span class="k">in</span> <span class="n">resultSet</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">Console</span><span class="p">.</span><span class="nf">Write</span><span class="p">(</span><span class="s">$"</span><span class="p">{</span><span class="n">thing</span><span class="p">}</span><span class="s">, "</span><span class="p">);</span>
  <span class="p">}</span>
</code></pre></div></div>
<p>可以看到在 <code class="language-plaintext highlighter-rouge">var resultSet = Iterator.AlphabetSubset('f', 'a');</code>不会抛出异常，在 <code class="language-plaintext highlighter-rouge">Console.Write($"{thing}, ");</code>抛出异常。</p>

<p>很难定位到是在哪的异常，出现异常和知道异常的，不在一个地方，这就是之前使用迭代的一个比较难发现的。</p>

<p>所以做法是新建一个方法迭代</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="k">public</span> <span class="k">static</span> <span class="n">IEnumerable</span><span class="p">&lt;</span><span class="kt">char</span><span class="p">&gt;</span> <span class="nf">AlphabetSubset2</span><span class="p">(</span><span class="kt">char</span> <span class="n">start</span><span class="p">,</span> <span class="kt">char</span> <span class="n">end</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">((</span><span class="n">start</span> <span class="p">&lt;</span> <span class="sc">'a'</span><span class="p">)</span> <span class="p">||</span> <span class="p">(</span><span class="n">start</span> <span class="p">&gt;</span> <span class="sc">'z'</span><span class="p">))</span>
        <span class="k">throw</span> <span class="k">new</span> <span class="nf">ArgumentOutOfRangeException</span><span class="p">(</span><span class="n">paramName</span><span class="p">:</span> <span class="k">nameof</span><span class="p">(</span><span class="n">start</span><span class="p">),</span> <span class="n">message</span><span class="p">:</span> <span class="s">"start must be a letter"</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">((</span><span class="n">end</span> <span class="p">&lt;</span> <span class="sc">'a'</span><span class="p">)</span> <span class="p">||</span> <span class="p">(</span><span class="n">end</span> <span class="p">&gt;</span> <span class="sc">'z'</span><span class="p">))</span>
        <span class="k">throw</span> <span class="k">new</span> <span class="nf">ArgumentOutOfRangeException</span><span class="p">(</span><span class="n">paramName</span><span class="p">:</span> <span class="k">nameof</span><span class="p">(</span><span class="n">end</span><span class="p">),</span> <span class="n">message</span><span class="p">:</span> <span class="s">"end must be a letter"</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">end</span> <span class="p">&lt;=</span> <span class="n">start</span><span class="p">)</span>
        <span class="k">throw</span> <span class="k">new</span> <span class="nf">ArgumentException</span><span class="p">(</span><span class="s">$"</span><span class="p">{</span><span class="k">nameof</span><span class="p">(</span><span class="n">end</span><span class="p">)}</span><span class="s"> must be greater than </span><span class="p">{</span><span class="k">nameof</span><span class="p">(</span><span class="n">start</span><span class="p">)}</span><span class="s">"</span><span class="p">);</span>
    <span class="k">return</span> <span class="nf">alphabetSubsetImplementation</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">private</span> <span class="k">static</span> <span class="n">IEnumerable</span><span class="p">&lt;</span><span class="kt">char</span><span class="p">&gt;</span> <span class="nf">alphabetSubsetImplementation</span><span class="p">(</span><span class="kt">char</span> <span class="n">start</span><span class="p">,</span> <span class="kt">char</span> <span class="n">end</span><span class="p">)</span>
<span class="p">{</span> 
    <span class="k">for</span> <span class="p">(</span><span class="kt">var</span> <span class="n">c</span> <span class="p">=</span> <span class="n">start</span><span class="p">;</span> <span class="n">c</span> <span class="p">&lt;</span> <span class="n">end</span><span class="p">;</span> <span class="n">c</span><span class="p">++)</span>
        <span class="k">yield</span> <span class="k">return</span> <span class="n">c</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>这样就可以定位，但是问题是，可能错误调用 alphabetSubsetImplementation ，直接使用 他，不是使用 AlphabetSubset2 ，所以在新的C#，可以使用内部方法</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="k">static</span> <span class="n">IEnumerable</span><span class="p">&lt;</span><span class="kt">char</span><span class="p">&gt;</span> <span class="nf">AlphabetSubset3</span><span class="p">(</span><span class="kt">char</span> <span class="n">start</span><span class="p">,</span> <span class="kt">char</span> <span class="n">end</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">((</span><span class="n">start</span> <span class="p">&lt;</span> <span class="sc">'a'</span><span class="p">)</span> <span class="p">||</span> <span class="p">(</span><span class="n">start</span> <span class="p">&gt;</span> <span class="sc">'z'</span><span class="p">))</span>
        <span class="k">throw</span> <span class="k">new</span> <span class="nf">ArgumentOutOfRangeException</span><span class="p">(</span><span class="n">paramName</span><span class="p">:</span> <span class="k">nameof</span><span class="p">(</span><span class="n">start</span><span class="p">),</span> <span class="n">message</span><span class="p">:</span> <span class="s">"start must be a letter"</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">((</span><span class="n">end</span> <span class="p">&lt;</span> <span class="sc">'a'</span><span class="p">)</span> <span class="p">||</span> <span class="p">(</span><span class="n">end</span> <span class="p">&gt;</span> <span class="sc">'z'</span><span class="p">))</span>
        <span class="k">throw</span> <span class="k">new</span> <span class="nf">ArgumentOutOfRangeException</span><span class="p">(</span><span class="n">paramName</span><span class="p">:</span> <span class="k">nameof</span><span class="p">(</span><span class="n">end</span><span class="p">),</span> <span class="n">message</span><span class="p">:</span> <span class="s">"end must be a letter"</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">end</span> <span class="p">&lt;=</span> <span class="n">start</span><span class="p">)</span>
        <span class="k">throw</span> <span class="k">new</span> <span class="nf">ArgumentException</span><span class="p">(</span><span class="s">$"</span><span class="p">{</span><span class="k">nameof</span><span class="p">(</span><span class="n">end</span><span class="p">)}</span><span class="s"> must be greater than </span><span class="p">{</span><span class="k">nameof</span><span class="p">(</span><span class="n">start</span><span class="p">)}</span><span class="s">"</span><span class="p">);</span>

    <span class="k">return</span> <span class="nf">alphabetSubsetImplementation</span><span class="p">();</span>

    <span class="n">IEnumerable</span><span class="p">&lt;</span><span class="kt">char</span><span class="p">&gt;</span> <span class="nf">alphabetSubsetImplementation</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">var</span> <span class="n">c</span> <span class="p">=</span> <span class="n">start</span><span class="p">;</span> <span class="n">c</span> <span class="p">&lt;</span> <span class="n">end</span><span class="p">;</span> <span class="n">c</span><span class="p">++)</span>
            <span class="k">yield</span> <span class="k">return</span> <span class="n">c</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>同时，在异步，如果出现异常，也是难以定位，所以可以用内部方法在异步前判断异常</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="k">public</span> <span class="n">Task</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">&gt;</span> <span class="nf">PerformLongRunningWork</span><span class="p">(</span><span class="kt">string</span> <span class="n">address</span><span class="p">,</span> <span class="kt">int</span> <span class="n">index</span><span class="p">,</span> <span class="kt">string</span> <span class="n">name</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="kt">string</span><span class="p">.</span><span class="nf">IsNullOrWhiteSpace</span><span class="p">(</span><span class="n">address</span><span class="p">))</span>
        <span class="k">throw</span> <span class="k">new</span> <span class="nf">ArgumentException</span><span class="p">(</span><span class="n">message</span><span class="p">:</span> <span class="s">"An address is required"</span><span class="p">,</span> <span class="n">paramName</span><span class="p">:</span> <span class="k">nameof</span><span class="p">(</span><span class="n">address</span><span class="p">));</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">index</span> <span class="p">&lt;</span> <span class="m">0</span><span class="p">)</span>
        <span class="k">throw</span> <span class="k">new</span> <span class="nf">ArgumentOutOfRangeException</span><span class="p">(</span><span class="n">paramName</span><span class="p">:</span> <span class="k">nameof</span><span class="p">(</span><span class="n">index</span><span class="p">),</span> <span class="n">message</span><span class="p">:</span> <span class="s">"The index must be non-negative"</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="kt">string</span><span class="p">.</span><span class="nf">IsNullOrWhiteSpace</span><span class="p">(</span><span class="n">name</span><span class="p">))</span>
        <span class="k">throw</span> <span class="k">new</span> <span class="nf">ArgumentException</span><span class="p">(</span><span class="n">message</span><span class="p">:</span> <span class="s">"You must supply a name"</span><span class="p">,</span> <span class="n">paramName</span><span class="p">:</span> <span class="k">nameof</span><span class="p">(</span><span class="n">name</span><span class="p">));</span>

    <span class="k">return</span> <span class="nf">longRunningWorkImplementation</span><span class="p">();</span>

    <span class="k">async</span> <span class="n">Task</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">&gt;</span> <span class="nf">longRunningWorkImplementation</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="kt">var</span> <span class="n">interimResult</span> <span class="p">=</span> <span class="k">await</span> <span class="nf">FirstWork</span><span class="p">(</span><span class="n">address</span><span class="p">);</span>
        <span class="kt">var</span> <span class="n">secondResult</span> <span class="p">=</span> <span class="k">await</span> <span class="nf">SecondStep</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">name</span><span class="p">);</span>
        <span class="k">return</span> <span class="s">$"The results are </span><span class="p">{</span><span class="n">interimResult</span><span class="p">}</span><span class="s"> and </span><span class="p">{</span><span class="n">secondResult</span><span class="p">}</span><span class="s">. Enjoy."</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>在使用异步函数前异常，不让开发者使用没有校验的 longRunningWorkImplementation ，这就是内部方法的使用。</p>

<p>但是可能有兄弟这样写，让我觉得这个语言太垃圾</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        <span class="k">public</span> <span class="k">static</span> <span class="k">void</span> <span class="nf">A</span><span class="p">()</span>
        <span class="p">{</span>
            <span class="nf">A1</span><span class="p">();</span>
            <span class="k">void</span> <span class="nf">A1</span><span class="p">()</span>
            <span class="p">{</span>
                <span class="k">void</span> <span class="nf">A2</span><span class="p">()</span>
                <span class="p">{</span>
                    <span class="k">void</span> <span class="nf">A3</span><span class="p">()</span>
                    <span class="p">{</span>
                        
                    <span class="p">}</span>
                <span class="p">}</span>

                <span class="nf">A2</span><span class="p">();</span>
                <span class="c1">//A3();</span>
            <span class="p">}</span>

            <span class="nf">A1</span><span class="p">();</span>
        <span class="p">}</span>
</code></pre></div></div>

<h2 id="改进常量">改进常量</h2>

<p>我们有比较长数字，那么我们在定义比较难知道他是否写对，这导致第一次阅读代码容易误解。特别是当数值没有规律的时候。C# 7.0包含两个新功能：二进制常量和数值分割。</p>

<p>C# 7.0现在做了改进，可以使用下划线，下划线可以分割常量。这样做的目的是看起来比较好看，容易数我们写了多少数字，可以看我们是不是写错。</p>

<!-- 我们可以使用，下划线。这样是分割，可以数我们写了多少数字，可以看我们是不是写错 -->

<p>例如对于二进制数值的定义</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="k">public</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">One</span> <span class="p">=</span>  <span class="m">0</span><span class="n">b0001</span><span class="p">;</span>
<span class="k">public</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">Two</span> <span class="p">=</span>  <span class="m">0</span><span class="n">b0010</span><span class="p">;</span>
<span class="k">public</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">Four</span> <span class="p">=</span> <span class="m">0</span><span class="n">b0100</span><span class="p">;</span>
<span class="k">public</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">Eight</span> <span class="p">=</span> <span class="m">0</span><span class="n">b1000</span><span class="p">;</span>
</code></pre></div></div>
<p>定义的开始是<code class="language-plaintext highlighter-rouge">0b</code>这个字符，之后就是二进制的0、1两个字符组成的数值。</p>

<p>不仅可以定义二进制数值，还可以添加下划线，下划线可以分割字符数值，如下代码所示。</p>

<p>public const int Sixteen =   0b0001_0000;
public const int ThirtyTwo = 0b0010_0000;
public const int SixtyFour = 0b0100_0000;
public const int OneHundredTwentyEight = 0b1000_0000;</p>

<p>数值分割下划线可以出现在除了字符串开始的任何位置，如定义一个比较大的整数，可以这样写</p>

<p>public const long BillionsAndBillions = 100_000_000_000;</p>

<p>同样，数值分割下划线支持decimal， float 和 double，对于浮点数值，可以在小数点之后任意位置添加。</p>

<p>public const double AvogadroConstant = 6.022_140_857_747_474e23;
public const decimal GoldenRatio = 1.618_033_988_749_894_848_204_586_834_365_638_117_720_309_179M;</p>

<p>总之，你可以定义出你觉得比较容易阅读的数值。</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="kt">var</span> <span class="n">d</span> <span class="p">=</span> <span class="m">123</span><span class="n">_456</span><span class="p">;</span>
<span class="kt">var</span> <span class="n">x</span> <span class="p">=</span> <span class="m">0xAB</span><span class="n">_CD_EF</span><span class="p">;</span>

</code></pre></div></div>

<p>我们还可以定义2进制，原来是无法定义，但是所有的二进制还是存储用int，不是一个类型。</p>

<p><code class="language-plaintext highlighter-rouge">var b = 0b1010_1011_1100_1101_1110_1111;</code></p>

<!-- 这个主要在二进制好，原先的使用true和false，如果还要使用，是用byte转换，如果Iot，我们需要定义二进制，要是使用原的还是难，我就觉得这个功能好。可以分割，我们二进制容易打着就不对，有了分割可以看出没几个，这样看代码简单，这个功能应该是原先` `就可得到，现在使用`_`觉得还是没有用。 -->

<p>这个功能在 Iot 经常需要使用二进制，如果是以前，可以使用 true 和 false、byte互转，写起来反人类，现在用这个方法就比较简单。二进制容易写错，所以上面的功能，可能是因为二进制做的。</p>

<h2 id="ref-returns-返回值">ref returns 返回值</h2>

<p>我们返回的是引用，现在返回可以是值，我们返回数组中的一个值，那么修改这个值，因为放进引用，我们输出数组是修改的值</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>

<span class="k">public</span> <span class="k">ref</span> <span class="kt">int</span> <span class="nf">Find</span><span class="p">(</span><span class="kt">int</span> <span class="n">number</span><span class="p">,</span> <span class="kt">int</span><span class="p">[]</span> <span class="n">numbers</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="p">&lt;</span> <span class="n">numbers</span><span class="p">.</span><span class="n">Length</span><span class="p">;</span> <span class="n">i</span><span class="p">++)</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">numbers</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="p">==</span> <span class="n">number</span><span class="p">)</span> 
        <span class="p">{</span>
            <span class="k">return</span> <span class="k">ref</span> <span class="n">numbers</span><span class="p">[</span><span class="n">i</span><span class="p">];</span> <span class="c1">// return the storage location, not the value</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">throw</span> <span class="k">new</span> <span class="nf">IndexOutOfRangeException</span><span class="p">(</span><span class="s">$"</span><span class="p">{</span><span class="k">nameof</span><span class="p">(</span><span class="n">number</span><span class="p">)}</span><span class="s"> not found"</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span><span class="p">[]</span> <span class="n">array</span> <span class="p">=</span> <span class="p">{</span> <span class="m">1</span><span class="p">,</span> <span class="m">15</span><span class="p">,</span> <span class="p">-</span><span class="m">39</span><span class="p">,</span> <span class="m">0</span><span class="p">,</span> <span class="m">7</span><span class="p">,</span> <span class="m">14</span><span class="p">,</span> <span class="p">-</span><span class="m">12</span> <span class="p">};</span>
<span class="k">ref</span> <span class="kt">int</span> <span class="n">place</span> <span class="p">=</span> <span class="k">ref</span> <span class="nf">Find</span><span class="p">(</span><span class="m">7</span><span class="p">,</span> <span class="n">array</span><span class="p">);</span> 
<span class="n">place</span> <span class="p">=</span> <span class="m">9</span><span class="p">;</span> <span class="c1">// 修改</span>
<span class="nf">WriteLine</span><span class="p">(</span><span class="n">array</span><span class="p">[</span><span class="m">4</span><span class="p">]);</span> <span class="c1">// 9</span>

</code></pre></div></div>

<h2 id="全部地方可以支持辣么大">全部地方可以支持辣么大</h2>

<p>以前支持辣么大的地方很少，关于辣么大，参见 https://docs.microsoft.com/en-us/dotnet/articles/csharp/lambda-expressions</p>

<p>现在可以在所有地方使用辣么大</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="c1">// Expression-bodied constructor</span>
<span class="k">public</span> <span class="nf">ExpressionMembersExample</span><span class="p">(</span><span class="kt">string</span> <span class="n">label</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="k">this</span><span class="p">.</span><span class="n">Label</span> <span class="p">=</span> <span class="n">label</span><span class="p">;</span>

<span class="k">private</span> <span class="kt">string</span> <span class="n">label</span><span class="p">;</span>

<span class="c1">// Expression-bodied get / set accessors.</span>
<span class="k">public</span> <span class="kt">string</span> <span class="n">Label</span>
<span class="p">{</span>
    <span class="k">get</span> <span class="p">=&gt;</span> <span class="n">label</span><span class="p">;</span>
    <span class="k">set</span> <span class="p">=&gt;</span> <span class="k">this</span><span class="p">.</span><span class="n">label</span> <span class="p">=</span> <span class="k">value</span> <span class="p">??</span> <span class="s">"Default label"</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="在表达式扔异常">在表达式扔异常</h2>

<p>以前，异常是定义，不可以放在表达式，所以下面代码出错</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>            <span class="k">private</span> <span class="kt">string</span> <span class="n">_name</span><span class="p">;</span>

        <span class="k">public</span> <span class="kt">string</span> <span class="n">Name</span>
        <span class="p">{</span>
            <span class="k">set</span>
            <span class="p">{</span>
                <span class="n">_name</span> <span class="p">=</span> <span class="k">value</span><span class="p">??</span><span class="k">throw</span> <span class="k">new</span> <span class="nf">ArgumentException</span><span class="p">();</span>
                
            <span class="p">}</span>
            <span class="k">get</span> <span class="p">{</span> <span class="k">return</span> <span class="n">Name</span><span class="p">;</span> <span class="p">}</span>
        <span class="p">}</span>
</code></pre></div></div>

<p>不能通过判断 value 是空，抛出异常，可以看到我的代码红了</p>

<p><img src="http://image.acmx.xyz/AwCCAwMAItoFAMV+BQA28wYAAQAEAK4+AQBmQwIAaOgJAOjZ/2017310112328.jpg" alt="" /></p>

<p>现在可以把异常放在表达式，下面代码在vs17可以运行</p>

<p><img src="http://image.acmx.xyz/AwCCAwMAItoFAMV+BQA28wYAAQAEAK4+AQBmQwIAaOgJAOjZ/201731011252.jpg" alt="" /></p>

<p>同时可以写在字段定义</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="k">private</span> <span class="n">ConfigResource</span> <span class="n">loadedConfig</span> <span class="p">=</span> <span class="nf">LoadConfigResourceOrDefault</span><span class="p">()</span> <span class="p">??</span> 
    <span class="k">throw</span> <span class="k">new</span> <span class="nf">InvalidOperationException</span><span class="p">(</span><span class="s">"Could not load config"</span><span class="p">);</span>
</code></pre></div></div>

<h2 id="广义异步返回类型">广义异步返回类型</h2>

<p>以前 <code class="language-plaintext highlighter-rouge">Task&lt;&gt;</code>只能在方法使用，必须返回引用类型，也会出现新建线程或构造的性能问题，请看下面的代码，虽然已经有了cache，但是还是需要进入新的task。</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="k">private</span> <span class="k">async</span> <span class="n">Task</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">&gt;</span> <span class="nf">loadCache</span><span class="p">()</span>
<span class="p">{</span>
    <span class="c1">// simulate async work:</span>
    <span class="k">await</span> <span class="n">Task</span><span class="p">.</span><span class="nf">Delay</span><span class="p">(</span><span class="m">100</span><span class="p">);</span>
    <span class="n">cache</span> <span class="p">=</span> <span class="k">true</span><span class="p">;</span>
    <span class="n">cacheResult</span> <span class="p">=</span> <span class="m">100</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">cacheResult</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>现在可以使用 <code class="language-plaintext highlighter-rouge">ValueTask&lt;&gt;</code> 返回数值，减少构造Task的性能问题，在ValueTask可以判断是否已经缓存，如果有就直接返回，这个的主要用法是减少task的使用，但是不修改方法，还是异步。</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="k">public</span> <span class="n">ValueTask</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">&gt;</span> <span class="nf">CachedFunc</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">cache</span><span class="p">)</span> <span class="p">?</span> <span class="k">new</span> <span class="n">ValueTask</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">&gt;(</span><span class="n">cacheResult</span><span class="p">)</span> <span class="p">:</span> <span class="k">new</span> <span class="n">ValueTask</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">&gt;(</span><span class="nf">loadCache</span><span class="p">());</span>
<span class="p">}</span>
<span class="k">private</span> <span class="kt">bool</span> <span class="n">cache</span> <span class="p">=</span> <span class="k">false</span><span class="p">;</span>
<span class="k">private</span> <span class="kt">int</span> <span class="n">cacheResult</span><span class="p">;</span>
<span class="k">private</span> <span class="k">async</span> <span class="n">Task</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">&gt;</span> <span class="nf">loadCache</span><span class="p">()</span>
<span class="p">{</span>
    <span class="c1">// simulate async work:</span>
    <span class="k">await</span> <span class="n">Task</span><span class="p">.</span><span class="nf">Delay</span><span class="p">(</span><span class="m">100</span><span class="p">);</span>
    <span class="n">cache</span> <span class="p">=</span> <span class="k">true</span><span class="p">;</span>
    <span class="n">cacheResult</span> <span class="p">=</span> <span class="m">100</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">cacheResult</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>注意使用<code class="language-plaintext highlighter-rouge">System.Threading.Tasks.Extension</code></p>

<p>这个方法可以直接把数值转<code class="language-plaintext highlighter-rouge">ValueTask</code></p>

<p>虽然没有用，和之前的看不出有什么用，但是这个一个很大的工程。</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>            <span class="k">public</span> <span class="k">static</span> <span class="k">async</span> <span class="n">ValueTask</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">&gt;</span> <span class="nf">ValueTask</span><span class="p">(</span><span class="kt">int</span><span class="p">[]</span> <span class="n">numbers</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">if</span> <span class="p">(!</span><span class="n">numbers</span><span class="p">.</span><span class="nf">Any</span><span class="p">())</span>
            <span class="p">{</span>
                <span class="k">return</span> <span class="m">0</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="k">else</span>
            <span class="p">{</span>
                <span class="k">return</span> <span class="k">await</span> <span class="n">Task</span><span class="p">.</span><span class="nf">Run</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="n">numbers</span><span class="p">.</span><span class="nf">Sum</span><span class="p">());</span>
            <span class="p">}</span>
        <span class="p">}</span>
</code></pre></div></div>

<p>上面代码其实无法体现出实际用处，在 http://www.cnblogs.com/GuZhenYin/p/6526041.html 博客，<a href="http://www.cnblogs.com/FishTank/">笑对当空</a> 说 这样可以在高频调用异步时不再花费更多的线程重复运行结果</p>

<h2 id="支持-async-的主函数">支持 async 的主函数</h2>

<p>这个特性需要使用 7.1 是支持异步的主函数。</p>

<p>如果需要使用最新的，那么可以右击项目属性，点击高级，可以看到下面的页面</p>

<p><img src="http://image.acmx.xyz/34fdad35-5dfe-a75b-2b4b-8c5e313038e2%2F20171215172352017121520151.jpg" alt="" /></p>

<p>选择最新的版本</p>

<p>以前的命令行主函数都是使用 void ，现在支持使用 async</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="k">async</span> <span class="n">Task</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">&gt;</span> <span class="nf">Main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="c1">// This could also be replaced with the body</span>
    <span class="c1">// DoAsyncWork, including its await expressions:</span>
    <span class="k">return</span> <span class="k">await</span> <span class="nf">DoAsyncWork</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div></div>

<p>如果 Main 不需要返回，那么可以直接使用下面代码</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="k">async</span> <span class="n">Task</span> <span class="nf">Main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">await</span> <span class="nf">SomeAsyncMethod</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="默认值不需要写类型">默认值不需要写类型</h2>

<p>以前需要写一个类型的默认值，一般都是比较长的，如下面的代码</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Func</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">,</span> <span class="kt">bool</span><span class="p">&gt;</span> <span class="n">whereClause</span> <span class="p">=</span> <span class="k">default</span><span class="p">(</span><span class="n">Func</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">,</span> <span class="kt">bool</span><span class="p">&gt;);</span>
</code></pre></div></div>

<p>如果使用的是 ValueTuple ，那么看到的代码会比上面的长，但是 default 是可以在使用就知道类型，所以现在可以直接写 default 就好，请看下面</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Func</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">,</span> <span class="kt">bool</span><span class="p">&gt;</span> <span class="n">whereClause</span> <span class="p">=</span> <span class="k">default</span><span class="p">;</span>
</code></pre></div></div>

<p>感觉这个功能是 ValueTuple 很好用，大家都使用这个东西，然后发现这个不能直接给 null 所以需要写 default ，所以就必须弄这个东西，看来微软很注重用户体验。</p>

<h2 id="自动推断-tuple-的名称">自动推断 Tuple 的名称</h2>

<p>以前的 ValueTuple 不能自动推断自己的名称，请看下面</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">count</span> <span class="p">=</span> <span class="m">5</span><span class="p">;</span>
<span class="kt">string</span> <span class="n">label</span> <span class="p">=</span> <span class="s">"Colors used in the map"</span><span class="p">;</span>
<span class="kt">var</span> <span class="n">pair</span> <span class="p">=</span> <span class="p">(</span><span class="n">count</span><span class="p">:</span> <span class="n">count</span><span class="p">,</span> <span class="n">label</span><span class="p">:</span> <span class="n">label</span><span class="p">);</span>
</code></pre></div></div>

<p>虽然已经有了两个变量，但是需要自己写名称，新的就可以自己获得名称</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">count</span> <span class="p">=</span> <span class="m">5</span><span class="p">;</span>
<span class="kt">string</span> <span class="n">label</span> <span class="p">=</span> <span class="s">"Colors used in the map"</span><span class="p">;</span>
<span class="kt">var</span> <span class="n">pair</span> <span class="p">=</span> <span class="p">(</span><span class="n">count</span><span class="p">,</span> <span class="n">label</span><span class="p">);</span> <span class="c1">// element names are "count" and "label"</span>
</code></pre></div></div>

<h2 id="值引用">值引用</h2>

<p>现在支持使用 in 写在函数的参数，参数是让结构体可以直接传引用。以前如果在参数写结构体，那么结构体是复制的，如果一个软件有很多参数都是使用结构体，那么结构体就需要很多复制，于是这样的内存性能比较差。</p>

<p>现在支持下面的写法</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">private</span> <span class="k">static</span> <span class="kt">double</span> <span class="nf">CalculateDistance2</span><span class="p">(</span><span class="k">in</span> <span class="n">Point3D</span> <span class="n">point1</span><span class="p">,</span> <span class="k">in</span> <span class="n">Point3D</span> <span class="n">point2</span> <span class="p">=</span> <span class="k">default</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">double</span> <span class="n">xDifference</span> <span class="p">=</span> <span class="n">point1</span><span class="p">.</span><span class="n">X</span> <span class="p">-</span> <span class="n">point2</span><span class="p">.</span><span class="n">X</span><span class="p">;</span>
    <span class="kt">double</span> <span class="n">yDifference</span> <span class="p">=</span> <span class="n">point1</span><span class="p">.</span><span class="n">Y</span> <span class="p">-</span> <span class="n">point2</span><span class="p">.</span><span class="n">Y</span><span class="p">;</span>
    <span class="kt">double</span> <span class="n">zDifference</span> <span class="p">=</span> <span class="n">point1</span><span class="p">.</span><span class="n">Z</span> <span class="p">-</span> <span class="n">point2</span><span class="p">.</span><span class="n">Z</span><span class="p">;</span>

    <span class="k">return</span> <span class="n">Math</span><span class="p">.</span><span class="nf">Sqrt</span><span class="p">(</span><span class="n">xDifference</span> <span class="p">*</span> <span class="n">xDifference</span> <span class="p">+</span> <span class="n">yDifference</span> <span class="p">*</span> <span class="n">yDifference</span> <span class="p">+</span> <span class="n">zDifference</span> <span class="p">*</span> <span class="n">zDifference</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>于是所有调用 CalculateDistance2 函数就不需要重新去复制 Point3D 的值，如果调用很多，那么就可以减少很多的内存，使用这个关键字就可以和引用类型一样，不需要复制值。</p>

<p>于是下面微软还用了更好的功能 ref readonly ，这是对属性和字段。如果有一个字段是 Origin 那么在使用他，用一个变量去拿，那么就会复制值，所以拿到的就和原来的不是一个对象，内存使用比较多。</p>

<p>现在可以使用下面代码，所有拿到的变量和原来都是一个值，不需要复制，虽然看起来没有优化很多，但是如果框架使用了，那么很多地方使用就可以看到减少很多内存。</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">private</span> <span class="k">static</span> <span class="n">Point3D</span> <span class="n">_origin</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">Point3D</span><span class="p">();</span>
<span class="k">public</span> <span class="k">static</span> <span class="k">ref</span> <span class="k">readonly</span> <span class="n">Point3D</span> <span class="n">Origin</span> <span class="p">=&gt;</span> <span class="k">ref</span> <span class="n">_origin</span><span class="p">;</span>

<span class="c1">// 方法</span>
<span class="kt">var</span> <span class="n">originValue</span> <span class="p">=</span> <span class="n">Point3D</span><span class="p">.</span><span class="n">Origin</span><span class="p">;</span>
<span class="k">ref</span> <span class="k">readonly</span> <span class="kt">var</span> <span class="n">originReference</span> <span class="p">=</span> <span class="k">ref</span> <span class="n">Point3D</span><span class="p">.</span><span class="n">Origin</span><span class="p">;</span>
</code></pre></div></div>

<p>上面的 originValue 是原来的方法，这样还是需要复制，但是 originReference 是直接拿引用。</p>

<p>但是对于结构体，是不是拿到了引用就可以修改里面的属性？因为有很多智障的人都会去修改结构体的属性，所以微软就给一个结构体也使用这个方法，只能读</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">readonly</span> <span class="k">public</span> <span class="k">struct</span> <span class="nc">ReadonlyPoint3D</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="nf">ReadonlyPoint3D</span><span class="p">(</span><span class="kt">double</span> <span class="n">x</span><span class="p">,</span> <span class="kt">double</span> <span class="n">y</span><span class="p">,</span> <span class="kt">double</span> <span class="n">z</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">this</span><span class="p">.</span><span class="n">X</span> <span class="p">=</span> <span class="n">x</span><span class="p">;</span>
        <span class="k">this</span><span class="p">.</span><span class="n">Y</span> <span class="p">=</span> <span class="n">y</span><span class="p">;</span>
        <span class="k">this</span><span class="p">.</span><span class="n">Z</span> <span class="p">=</span> <span class="n">z</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">public</span> <span class="kt">double</span> <span class="n">X</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="p">}</span>
    <span class="k">public</span> <span class="kt">double</span> <span class="n">Y</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="p">}</span>
    <span class="k">public</span> <span class="kt">double</span> <span class="n">Z</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="p">}</span>

    <span class="k">private</span> <span class="k">static</span> <span class="k">readonly</span> <span class="n">ReadonlyPoint3D</span> <span class="n">origin</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">ReadonlyPoint3D</span><span class="p">();</span>
    <span class="k">public</span> <span class="k">static</span> <span class="k">ref</span> <span class="k">readonly</span> <span class="n">ReadonlyPoint3D</span> <span class="n">Origin</span> <span class="p">=&gt;</span> <span class="k">ref</span> <span class="n">origin</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="指定位置命名参数">指定位置命名参数</h2>

<p>很多人都不知道，方法可以指定命名，请看下面的代码</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">PrintOrderDetails</span><span class="p">(</span><span class="s">"Gift Shop"</span><span class="p">,</span> <span class="m">31</span><span class="p">,</span> <span class="s">"Red Mug"</span><span class="p">);</span>

<span class="nf">PrintOrderDetails</span><span class="p">(</span><span class="n">orderNum</span><span class="p">:</span> <span class="m">31</span><span class="p">,</span> <span class="n">productName</span><span class="p">:</span> <span class="s">"Red Mug"</span><span class="p">,</span> <span class="n">sellerName</span><span class="p">:</span> <span class="s">"Gift Shop"</span><span class="p">);</span>
</code></pre></div></div>

<p>但是写了命名参数，就不能就写其中的几个，如下面的代码在以前是无法编译，因为不能找到参数对应的</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">PrintOrderDetails</span><span class="p">(</span><span class="n">sellerName</span><span class="p">:</span> <span class="s">"Gift Shop"</span><span class="p">,</span> <span class="m">31</span><span class="p">,</span> <span class="n">productName</span><span class="p">:</span> <span class="s">"Red Mug"</span><span class="p">);</span>
</code></pre></div></div>

<p>但是现在可以编译通过了，但是需要写的位置和函数的一样，如上面的 31 如何和后面的名称位置换了，那么无法编译。</p>

<p>如果写了三个参数，其中两个用了命名，一个没有，为什么微软不自动找到位置？因为有一些重载是参数的位置不相同，如果使用自动判断，那么就不知道使用哪个函数，请看下面的代码</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">void</span> <span class="nf">PrintOrderDetails</span><span class="p">(</span><span class="kt">string</span> <span class="n">sellerName</span><span class="p">,</span><span class="kt">int</span> <span class="n">orderNum</span><span class="p">,</span><span class="kt">string</span> <span class="n">productName</span><span class="p">)</span>
<span class="p">{</span>

<span class="p">}</span>

<span class="k">void</span> <span class="nf">PrintOrderDetails</span><span class="p">(</span><span class="kt">string</span> <span class="n">sellerName</span><span class="p">,</span><span class="kt">string</span> <span class="n">productName</span><span class="p">,</span><span class="kt">int</span> <span class="n">orderNum</span><span class="p">)</span>
<span class="p">{</span>

<span class="p">}</span>
</code></pre></div></div>

<p>写了一个 <code class="language-plaintext highlighter-rouge">PrintOrderDetails(31,sellerName: "Gift Shop", productName: "Red Mug")</code>那么是需要使用上面哪个函数</p>

<h2 id="private-protected-访问修饰">private protected 访问修饰</h2>

<p>以前的 protected 只能指定在继承类可以使用，如果类在其他程序集，那么他还是可以使用，请看下面的代码</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="k">class</span> <span class="nc">BaseClass</span>
<span class="p">{</span>
    <span class="k">protected</span> <span class="kt">int</span> <span class="n">myValue</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">public</span> <span class="k">class</span> <span class="nc">DerivedClass1</span> <span class="p">:</span> <span class="n">BaseClass</span>
<span class="p">{</span>
    <span class="k">void</span> <span class="nf">Access</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="n">BaseClass</span> <span class="n">baseObject</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">BaseClass</span><span class="p">();</span>

        <span class="c1">// 下面代码出现错误，只有继承的类可以使用，在类外面不能使用</span>
        <span class="c1">// baseObject.myValue = 5;  </span>

        <span class="c1">// OK, 这个可以使用</span>
        <span class="n">myValue</span> <span class="p">=</span> <span class="m">5</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>无论 DerivedClass1 是写在其他程序集都可以使用。</p>

<p>那么 protected internal 是做什么？</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="k">class</span> <span class="nc">BaseClass</span>   
<span class="p">{</span>  
   <span class="k">protected</span> <span class="k">internal</span> <span class="kt">int</span> <span class="n">myValue</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span>  
<span class="p">}</span>

<span class="k">class</span> <span class="nc">TestAccess</span> 
<span class="p">{</span>
    <span class="k">void</span> <span class="nf">Access</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="n">BaseClass</span> <span class="n">baseObject</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">BaseClass</span><span class="p">();</span>
        <span class="n">baseObject</span><span class="p">.</span><span class="n">myValue</span> <span class="p">=</span> <span class="m">5</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>  
</code></pre></div></div>

<p>可以和上面的看，上面的代码可以直接使用<code class="language-plaintext highlighter-rouge">baseObject.myValue</code>在相同的程序集外面可以直接使用这个属性。但是在其他程序集就不能这样写。</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//另一个程序集</span>
<span class="k">class</span> <span class="nc">DerivedClass</span> <span class="p">:</span> <span class="n">BaseClass</span>   
<span class="p">{</span>  
    <span class="k">static</span> <span class="k">void</span> <span class="nf">Main</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="n">BaseClass</span> <span class="n">baseObject</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">BaseClass</span><span class="p">();</span>
        <span class="n">DerivedClass</span> <span class="n">derivedObject</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">DerivedClass</span><span class="p">();</span>

        <span class="c1">// 下面的代码就报错了，因为没有权限</span>
        <span class="c1">// baseObject.myValue = 10; </span>

        <span class="c1">// OK, 可以使用</span>
        <span class="n">derivedObject</span><span class="p">.</span><span class="n">myValue</span> <span class="p">=</span> <span class="m">10</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span> 
</code></pre></div></div>

<p>那么 private protected 是做什么？</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="k">class</span> <span class="nc">BaseClass</span>
<span class="p">{</span>
    <span class="k">private</span> <span class="k">protected</span> <span class="kt">int</span> <span class="n">myValue</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">public</span> <span class="k">class</span> <span class="nc">DerivedClass1</span> <span class="p">:</span> <span class="n">BaseClass</span>
<span class="p">{</span>
    <span class="k">void</span> <span class="nf">Access</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="n">BaseClass</span> <span class="n">baseObject</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">BaseClass</span><span class="p">();</span>

        <span class="c1">// 下面的代码无法访问</span>
        <span class="c1">// baseObject.myValue = 5;  </span>

        <span class="c1">// OK, 可以使用</span>
        <span class="n">myValue</span> <span class="p">=</span> <span class="m">5</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>在其他程序集无法使用这个属性，无论使用的是继承这个类拿到属性</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="c1">// 另一个程序</span>
 <span class="k">class</span> <span class="nc">DerivedClass2</span> <span class="p">:</span> <span class="n">BaseClass</span>
 <span class="p">{</span>
     <span class="k">void</span> <span class="nf">Access</span><span class="p">()</span>
     <span class="p">{</span>
         <span class="c1">// 下面的代码无法访问</span>
         <span class="c1">// myValue = 10;</span>
     <span class="p">}</span>
 <span class="p">}</span>
</code></pre></div></div>

<p>实际上这样写就是在其他的程序集无法访问这个属性，但是在一个程序级可以继承访问这个属性</p>

<p>推荐一个写很好的博客<a href="https://www.cnblogs.com/daxnet/archive/2018/03/19/8604801.html">解析Visual C# 7.2中的private protected访问修饰符 - dax.net - 博客园</a></p>

<h2 id="字符常量下划线可以放在最前">字符常量下划线可以放在最前</h2>

<p>以前的字符常量不能使用下划线开始，现在可以使用下划线开始</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">n</span> <span class="p">=</span> <span class="n">_00_001</span><span class="p">;</span>
</code></pre></div></div>

<p>https://docs.microsoft.com/en-us/dotnet/articles/csharp/csharp-7</p>

<p>https://blogs.msdn.microsoft.com/dotnet/2016/08/24/whats-new-in-csharp-7-0/</p>

<h2 id="vs-17-下载">VS 17 下载</h2>

<p>VS 17 企业版</p>

<p>链接：http://pan.baidu.com/s/1skXDc3z 密码：70d6</p>

<p>秘钥 Njvyc-bmhx2-g77mm-4xjmr-6q8qf</p>

<p>如果度盘链接没法使用，请联系我。</p>

<p>btsync：BTZR4YIPCLUUEL2BKDACVGLC3473MEWDN</p>

<p>代码 https://github.com/alugili/CSharp7Features</p>

<p>如果自己想下载离线包，可以到官网去下载一个应用，也就是在线安装版本。</p>

<p>然后使用 cmd 打开，假如我下载的是 vs_community.exe，那么我想安装语言为中文的包，包括常用开发，可以使用下面代码</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="n">vs_community</span><span class="p">.</span><span class="n">exe</span> <span class="p">--</span><span class="n">layout</span> <span class="n">E</span><span class="p">:</span><span class="err">\</span><span class="n">vs2017</span><span class="err">离线</span>  <span class="p">--</span><span class="n">lang</span> <span class="n">zh</span><span class="p">-</span><span class="n">CN</span>  <span class="p">--</span><span class="k">add</span> <span class="n">Component</span><span class="p">.</span><span class="n">GitHub</span><span class="p">.</span><span class="n">VisualStudio</span>  <span class="p">--</span><span class="k">add</span> <span class="n">Microsoft</span><span class="p">.</span><span class="n">VisualStudio</span><span class="p">.</span><span class="n">Component</span><span class="p">.</span><span class="n">CoreEditor</span> <span class="p">--</span><span class="k">add</span> <span class="n">Microsoft</span><span class="p">.</span><span class="n">VisualStudio</span><span class="p">.</span><span class="n">Workload</span><span class="p">.</span><span class="n">ManagedDesktop</span>
</code></pre></div></div>

<p>需要解释上面的代码</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="n">vs_community</span><span class="p">.</span><span class="n">exe</span> <span class="p">--</span><span class="n">layout</span> <span class="err">下载地址</span> <span class="p">--</span><span class="n">lang</span> <span class="err">语言，如果有多个，使用空格</span>  <span class="p">--</span><span class="k">add</span> <span class="err">添加工作空间</span>  <span class="p">--</span><span class="k">add</span> <span class="n">Microsoft</span><span class="p">.</span><span class="n">VisualStudio</span><span class="p">.</span><span class="n">Component</span><span class="p">.</span><span class="n">CoreEditor</span> <span class="p">--</span><span class="k">add</span> <span class="n">Microsoft</span><span class="p">.</span><span class="n">VisualStudio</span><span class="p">.</span><span class="n">Workload</span><span class="p">.</span><span class="n">ManagedDesktop</span>
</code></pre></div></div>

<p>语言参见：https://docs.microsoft.com/en-us/visualstudio/install/use-command-line-parameters-to-install-visual-studio#list-of-language-locales</p>

<p>工作空间可以到 https://docs.microsoft.com/en-us/visualstudio/install/workload-and-component-ids 查看，对不同的vs，需要使用不同的工作空间</p>

<p><a href="https://docs.microsoft.com/en-us/visualstudio/install/install-vs-inconsistent-quality-network">Install on low bandwidth or unreliable network environments </a></p>

:ET