I"o<p>我们在UWP，经常使用的图片，数据结构就是 BitmapImage 和 WriteableBitmap。关于 BitmapImage 和 WriteableBitmap 区别，我就不在这里说。主要说的是 BitmapImage 和 WriteableBitmap 、二进制 byte 的互转。</p>

<!--more-->

<!-- CreateTime:2018/8/10 19:16:51 -->

<div id="toc"></div>

<p>我们先写一个简单的xaml</p>

<div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code>       <span class="nt">&lt;Image</span> <span class="na">x:Name=</span><span class="s">"Img"</span> <span class="na">Height=</span><span class="s">"200"</span> <span class="na">Width=</span><span class="s">"200"</span> 
              <span class="na">HorizontalAlignment=</span><span class="s">"Center"</span> <span class="na">Source=</span><span class="s">"Assets/SplashScreen.png"</span> <span class="nt">&gt;&lt;/Image&gt;</span>
        
        <span class="nt">&lt;Button</span> <span class="na">Margin=</span><span class="s">"10,300,10,10"</span> <span class="na">Content=</span><span class="s">"确定"</span> <span class="na">Click=</span><span class="s">"Button_OnClick"</span> <span class="nt">&gt;&lt;/Button&gt;</span>
   
</code></pre></div></div>

<p><img src="http://image.acmx.xyz/fc7733af-8526-44d2-84b9-99b41ef99f4a2016121293717.jpg" alt="" /></p>

<p>用到的图片是我新建自带的。</p>

<h2 id="保存-writeablebitmap-到文件">保存 WriteableBitmap 到文件</h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    private static async Task SaveWriteableBitmapImageFile(WriteableBitmap image, StorageFile file)
    {
        //BitmapEncoder 存放格式
        Guid bitmapEncoderGuid = BitmapEncoder.JpegEncoderId;
        string filename = file.Name;
        if (filename.EndsWith("jpg"))
        {
            bitmapEncoderGuid = BitmapEncoder.JpegEncoderId;
        }
        else if (filename.EndsWith("png"))
        {
            bitmapEncoderGuid = BitmapEncoder.PngEncoderId;
        }
        else if (filename.EndsWith("bmp"))
        {
            bitmapEncoderGuid = BitmapEncoder.BmpEncoderId;
        }
        else if (filename.EndsWith("tiff"))
        {
            bitmapEncoderGuid = BitmapEncoder.TiffEncoderId;
        }
        else if (filename.EndsWith("gif"))
        {
            bitmapEncoderGuid = BitmapEncoder.GifEncoderId;
        }
        using (IRandomAccessStream stream = await file.OpenAsync(FileAccessMode.ReadWrite, StorageOpenOptions.None))
        {
            BitmapEncoder encoder = await BitmapEncoder.CreateAsync(bitmapEncoderGuid, stream);
            Stream pixelStream = image.PixelBuffer.AsStream();
            byte[] pixels = new byte[pixelStream.Length];
            await pixelStream.ReadAsync(pixels, 0, pixels.Length);
            
            encoder.SetPixelData(BitmapPixelFormat.Bgra8, BitmapAlphaMode.Ignore,
                      (uint)image.PixelWidth,
                      (uint)image.PixelHeight,
                      96.0,
                      96.0,
                      pixels);
            //Windows.Graphics.Imaging.BitmapDecoder decoder = await Windows.Graphics.Imaging.BitmapDecoder.CreateAsync(imgstream);
            //Windows.Graphics.Imaging.PixelDataProvider pxprd = await decoder.GetPixelDataAsync(Windows.Graphics.Imaging.BitmapPixelFormat.Bgra8, Windows.Graphics.Imaging.BitmapAlphaMode.Straight, new Windows.Graphics.Imaging.BitmapTransform(), Windows.Graphics.Imaging.ExifOrientationMode.RespectExifOrientation, Windows.Graphics.Imaging.ColorManagementMode.DoNotColorManage);

            await encoder.FlushAsync();
        }
    }
</code></pre></div></div>

<h2 id="从文件读-writeablebitmap">从文件读 WriteableBitmap</h2>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        <span class="k">private</span> <span class="k">static</span> <span class="k">async</span> <span class="n">Task</span><span class="p">&lt;</span><span class="n">WriteableBitmap</span><span class="p">&gt;</span> <span class="nf">OpenWriteableBitmapFile</span><span class="p">(</span><span class="n">StorageFile</span> <span class="n">file</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">using</span> <span class="p">(</span><span class="n">IRandomAccessStream</span> <span class="n">stream</span> <span class="p">=</span> <span class="k">await</span> <span class="n">file</span><span class="p">.</span><span class="nf">OpenAsync</span><span class="p">(</span><span class="n">FileAccessMode</span><span class="p">.</span><span class="n">Read</span><span class="p">))</span>
            <span class="p">{</span>
                <span class="n">BitmapDecoder</span> <span class="n">decoder</span> <span class="p">=</span> <span class="k">await</span> <span class="n">BitmapDecoder</span><span class="p">.</span><span class="nf">CreateAsync</span><span class="p">(</span><span class="n">stream</span><span class="p">);</span>
                <span class="n">WriteableBitmap</span> <span class="n">image</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">WriteableBitmap</span><span class="p">((</span><span class="kt">int</span><span class="p">)</span><span class="n">decoder</span><span class="p">.</span><span class="n">PixelWidth</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">decoder</span><span class="p">.</span><span class="n">PixelHeight</span><span class="p">);</span>
                <span class="n">image</span><span class="p">.</span><span class="nf">SetSource</span><span class="p">(</span><span class="n">stream</span><span class="p">);</span>

                <span class="k">return</span> <span class="n">image</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
</code></pre></div></div>

<h2 id="imagesource-转byte">ImageSource 转byte[]</h2>

<p>ImageSource可以是 BitmapImage 、WriteableBitmap，如果是WriteableBitmap ，那么直接转换</p>

<p>WriteableBitmap  转byte[]</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">bitmap</span><span class="p">.</span><span class="n">PixelBuffer</span><span class="p">.</span><span class="nf">ToArray</span><span class="p">();</span>
</code></pre></div></div>

<h2 id="image-转byte">Image 转byte[]</h2>

<p>如果我们的 ImageSource 是 BitmapImage ,那么我们不能使用上面的办法，直接保存 WriteableBitmap  ，我们可以使用截图</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">private</span> <span class="k">async</span> <span class="n">Task</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">&gt;</span> <span class="nf">ToBase64</span><span class="p">(</span><span class="n">Image</span> <span class="n">control</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">var</span> <span class="n">bitmap</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">RenderTargetBitmap</span><span class="p">();</span>
    <span class="k">await</span> <span class="n">bitmap</span><span class="p">.</span><span class="nf">RenderAsync</span><span class="p">(</span><span class="n">control</span><span class="p">);</span>
    <span class="k">return</span> <span class="k">await</span> <span class="nf">ToBase64</span><span class="p">(</span><span class="n">bitmap</span><span class="p">);</span>
<span class="p">}</span>


</code></pre></div></div>

<p>如果 ImageSource 是 WriteableBitmap  ，直接保存</p>

<p>我们使用 byte[] 在传输时不好，不能用在 http 传输上（不是一定的不能），所以我们就把它转为base64，我提供了很多方法把数组转 base64 ,把文件转为 base64 。代码是 https://codepaste.net/ijx28i 抄的。</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1">//WriteableBitmap 转 byte[]</span>
<span class="k">private</span> <span class="k">async</span> <span class="n">Task</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">&gt;</span> <span class="nf">ToBase64</span><span class="p">(</span><span class="n">WriteableBitmap</span> <span class="n">bitmap</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">var</span> <span class="n">bytes</span> <span class="p">=</span> <span class="n">bitmap</span><span class="p">.</span><span class="n">PixelBuffer</span><span class="p">.</span><span class="nf">ToArray</span><span class="p">();</span>
    <span class="k">return</span> <span class="k">await</span> <span class="nf">ToBase64</span><span class="p">(</span><span class="n">bytes</span><span class="p">,</span> <span class="p">(</span><span class="kt">uint</span><span class="p">)</span><span class="n">bitmap</span><span class="p">.</span><span class="n">PixelWidth</span><span class="p">,</span> <span class="p">(</span><span class="kt">uint</span><span class="p">)</span><span class="n">bitmap</span><span class="p">.</span><span class="n">PixelHeight</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">private</span> <span class="k">async</span> <span class="n">Task</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">&gt;</span> <span class="nf">ToBase64</span><span class="p">(</span><span class="n">StorageFile</span> <span class="n">bitmap</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">var</span> <span class="n">stream</span> <span class="p">=</span> <span class="k">await</span> <span class="n">bitmap</span><span class="p">.</span><span class="nf">OpenAsync</span><span class="p">(</span><span class="n">Windows</span><span class="p">.</span><span class="n">Storage</span><span class="p">.</span><span class="n">FileAccessMode</span><span class="p">.</span><span class="n">Read</span><span class="p">);</span>
    <span class="kt">var</span> <span class="n">decoder</span> <span class="p">=</span> <span class="k">await</span> <span class="n">BitmapDecoder</span><span class="p">.</span><span class="nf">CreateAsync</span><span class="p">(</span><span class="n">stream</span><span class="p">);</span>
    <span class="kt">var</span> <span class="n">pixels</span> <span class="p">=</span> <span class="k">await</span> <span class="n">decoder</span><span class="p">.</span><span class="nf">GetPixelDataAsync</span><span class="p">();</span>
    <span class="kt">var</span> <span class="n">bytes</span> <span class="p">=</span> <span class="n">pixels</span><span class="p">.</span><span class="nf">DetachPixelData</span><span class="p">();</span>
    <span class="k">return</span> <span class="k">await</span> <span class="nf">ToBase64</span><span class="p">(</span><span class="n">bytes</span><span class="p">,</span> <span class="p">(</span><span class="kt">uint</span><span class="p">)</span><span class="n">decoder</span><span class="p">.</span><span class="n">PixelWidth</span><span class="p">,</span> <span class="p">(</span><span class="kt">uint</span><span class="p">)</span><span class="n">decoder</span><span class="p">.</span><span class="n">PixelHeight</span><span class="p">,</span> <span class="n">decoder</span><span class="p">.</span><span class="n">DpiX</span><span class="p">,</span> <span class="n">decoder</span><span class="p">.</span><span class="n">DpiY</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">private</span> <span class="k">async</span> <span class="n">Task</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">&gt;</span> <span class="nf">ToBase64</span><span class="p">(</span><span class="n">RenderTargetBitmap</span> <span class="n">bitmap</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">var</span> <span class="n">bytes</span> <span class="p">=</span> <span class="p">(</span><span class="k">await</span> <span class="n">bitmap</span><span class="p">.</span><span class="nf">GetPixelsAsync</span><span class="p">()).</span><span class="nf">ToArray</span><span class="p">();</span>
    <span class="k">return</span> <span class="k">await</span> <span class="nf">ToBase64</span><span class="p">(</span><span class="n">bytes</span><span class="p">,</span> <span class="p">(</span><span class="kt">uint</span><span class="p">)</span><span class="n">bitmap</span><span class="p">.</span><span class="n">PixelWidth</span><span class="p">,</span> <span class="p">(</span><span class="kt">uint</span><span class="p">)</span><span class="n">bitmap</span><span class="p">.</span><span class="n">PixelHeight</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">private</span> <span class="k">async</span> <span class="n">Task</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">&gt;</span> <span class="nf">ToBase64</span><span class="p">(</span><span class="kt">byte</span><span class="p">[]</span> <span class="n">image</span><span class="p">,</span> <span class="kt">uint</span> <span class="n">height</span><span class="p">,</span> <span class="kt">uint</span> <span class="n">width</span><span class="p">,</span> <span class="kt">double</span> <span class="n">dpiX</span> <span class="p">=</span> <span class="m">96</span><span class="p">,</span> <span class="kt">double</span> <span class="n">dpiY</span> <span class="p">=</span> <span class="m">96</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// encode image</span>
    <span class="kt">var</span> <span class="n">encoded</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">InMemoryRandomAccessStream</span><span class="p">();</span>
    <span class="kt">var</span> <span class="n">encoder</span> <span class="p">=</span> <span class="k">await</span> <span class="n">BitmapEncoder</span><span class="p">.</span><span class="nf">CreateAsync</span><span class="p">(</span><span class="n">BitmapEncoder</span><span class="p">.</span><span class="n">PngEncoderId</span><span class="p">,</span> <span class="n">encoded</span><span class="p">);</span>
    <span class="n">encoder</span><span class="p">.</span><span class="nf">SetPixelData</span><span class="p">(</span><span class="n">BitmapPixelFormat</span><span class="p">.</span><span class="n">Bgra8</span><span class="p">,</span> <span class="n">BitmapAlphaMode</span><span class="p">.</span><span class="n">Straight</span><span class="p">,</span> <span class="n">height</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">dpiX</span><span class="p">,</span> <span class="n">dpiY</span><span class="p">,</span> <span class="n">image</span><span class="p">);</span>
    <span class="k">await</span> <span class="n">encoder</span><span class="p">.</span><span class="nf">FlushAsync</span><span class="p">();</span>
    <span class="n">encoded</span><span class="p">.</span><span class="nf">Seek</span><span class="p">(</span><span class="m">0</span><span class="p">);</span>

    <span class="c1">// read bytes</span>
    <span class="kt">var</span> <span class="n">bytes</span> <span class="p">=</span> <span class="k">new</span> <span class="kt">byte</span><span class="p">[</span><span class="n">encoded</span><span class="p">.</span><span class="n">Size</span><span class="p">];</span>
    <span class="k">await</span> <span class="n">encoded</span><span class="p">.</span><span class="nf">AsStream</span><span class="p">().</span><span class="nf">ReadAsync</span><span class="p">(</span><span class="n">bytes</span><span class="p">,</span> <span class="m">0</span><span class="p">,</span> <span class="n">bytes</span><span class="p">.</span><span class="n">Length</span><span class="p">);</span>

    <span class="c1">// create base64</span>
    <span class="k">return</span> <span class="n">Convert</span><span class="p">.</span><span class="nf">ToBase64String</span><span class="p">(</span><span class="n">bytes</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">private</span> <span class="k">async</span> <span class="n">Task</span><span class="p">&lt;</span><span class="n">ImageSource</span><span class="p">&gt;</span> <span class="nf">FromBase64</span><span class="p">(</span><span class="kt">string</span> <span class="n">base64</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// read stream</span>
    <span class="kt">var</span> <span class="n">bytes</span> <span class="p">=</span> <span class="n">Convert</span><span class="p">.</span><span class="nf">FromBase64String</span><span class="p">(</span><span class="n">base64</span><span class="p">);</span>
    <span class="kt">var</span> <span class="n">image</span> <span class="p">=</span> <span class="n">bytes</span><span class="p">.</span><span class="nf">AsBuffer</span><span class="p">().</span><span class="nf">AsStream</span><span class="p">().</span><span class="nf">AsRandomAccessStream</span><span class="p">();</span>

    <span class="c1">// decode image</span>
    <span class="kt">var</span> <span class="n">decoder</span> <span class="p">=</span> <span class="k">await</span> <span class="n">BitmapDecoder</span><span class="p">.</span><span class="nf">CreateAsync</span><span class="p">(</span><span class="n">image</span><span class="p">);</span>
    <span class="n">image</span><span class="p">.</span><span class="nf">Seek</span><span class="p">(</span><span class="m">0</span><span class="p">);</span>

    <span class="c1">// create bitmap</span>
    <span class="kt">var</span> <span class="n">output</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">WriteableBitmap</span><span class="p">((</span><span class="kt">int</span><span class="p">)</span><span class="n">decoder</span><span class="p">.</span><span class="n">PixelHeight</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">decoder</span><span class="p">.</span><span class="n">PixelWidth</span><span class="p">);</span>
    <span class="k">await</span> <span class="n">output</span><span class="p">.</span><span class="nf">SetSourceAsync</span><span class="p">(</span><span class="n">image</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">output</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>上面代码出处：https://codepaste.net/ijx28i</p>

<h2 id="从文件读-bitmapimage">从文件读 BitmapImage</h2>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        <span class="k">private</span> <span class="k">async</span> <span class="n">Task</span><span class="p">&lt;</span><span class="n">BitmapImage</span><span class="p">&gt;</span> <span class="nf">OpenBitmapImageFile</span><span class="p">(</span><span class="n">StorageFile</span> <span class="n">file</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="kt">var</span> <span class="n">fileStream</span> <span class="p">=</span> <span class="k">await</span> <span class="n">file</span><span class="p">.</span><span class="nf">OpenReadAsync</span><span class="p">();</span>
            <span class="kt">var</span> <span class="n">bitmap</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">BitmapImage</span><span class="p">();</span>
            <span class="k">await</span> <span class="n">bitmap</span><span class="p">.</span><span class="nf">SetSourceAsync</span><span class="p">(</span><span class="n">fileStream</span><span class="p">);</span>
            <span class="k">return</span> <span class="n">bitmap</span><span class="p">;</span>
        <span class="p">}</span>
</code></pre></div></div>

<h2 id="bitmapimage-转-writeablebitmap">BitmapImage 转 WriteableBitmap</h2>

<p>我使用http://www.cnblogs.com/cjw1115/p/5164327.html 大神的，直接转<code class="language-plaintext highlighter-rouge">WriteableBitmap bitmap = imageSource as WriteableBitmap;</code>bitmap为null，于是我在网上继续找，好像没看到 UWP 的可以转，只有win7的</p>

<p>其实大神有说，Image的 Source是 WriteableBitmap ，于是他就能转。</p>

<p>UWP的 BitmapImage 不能转换为 byte[] 或 WriteableBitmap 。这句话是错的。</p>

<hr />

<p>2017年1月4日21:45:37</p>

<hr />

<p>我后来过了几个月，发现我们的 BitmapImage 可以转 byte[]</p>

<p>我们可以通过拿 BitmapImage 的 UriSource 把它转为 WriteableBitmap ，可以使用截图获得 BitmapImage。</p>

<p>如果想要使用  BitmapImage 的 UriSource 转为 WriteableBitmap，需要 WriteableBitmapEx 。他是在 WPF 就被大家喜欢的库。如何安装 WriteableBitmapEx ，其实有了Nuget 基本没问题。</p>

<p>搜索 WriteableBitmapEx  Nuget</p>

<p>然后搜索到了，我们要什么，好像我也不知道。</p>

<p>我就知道可以使用 `  WriteableBitmap image = await BitmapFactory.New(1, 1).FromContent((BitmapImage).UriSource);`</p>

<p>那么转 byte[] 如何做，有了 WriteableBitmap ，下面的我也不知道，不要问我。</p>

<p>如果使用 BitmapImage 图片是 SetSource，那么我也不会。</p>

<h2 id="获取图片中鼠标点击的颜色">获取图片中鼠标点击的颜色</h2>

<p>获取鼠标点击的那个点，图片的颜色。那么图片之外，界面呢？其实我们还可以把界面截图，然后获取。</p>

<p>那么我们需要首先在 Image 使用 Tap ，假如图片 source 是 BitmapImage</p>

<p>前提安装 WriteableBitmapEx ，假如我们的 ViewModel有一个 BitmapImage 的图片 Image ，于是我们可以使用</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>            <span class="kt">var</span> <span class="n">position</span> <span class="p">=</span> <span class="n">e</span><span class="p">.</span><span class="nf">GetPosition</span><span class="p">(</span><span class="n">sender</span> <span class="k">as</span> <span class="n">UIElement</span><span class="p">);</span> <span class="c1">//鼠标点击的在哪</span>

            <span class="n">WriteableBitmap</span> <span class="n">image</span> <span class="p">=</span> <span class="k">await</span> <span class="n">BitmapFactory</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="m">1</span><span class="p">,</span> <span class="m">1</span><span class="p">).</span><span class="nf">FromContent</span><span class="p">((</span><span class="n">View</span><span class="p">.</span><span class="n">Image</span><span class="p">).</span><span class="n">UriSource</span><span class="p">);</span> <span class="c1">//我上面说的如何把 BitmapImage 转 WriteableBitmapEx</span>
            
            <span class="kt">var</span> <span class="n">temp</span> <span class="p">=</span> <span class="n">image</span><span class="p">.</span><span class="nf">GetPixel</span><span class="p">((</span><span class="kt">int</span><span class="p">)</span> <span class="n">position</span><span class="p">.</span><span class="n">X</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="n">position</span><span class="p">.</span><span class="n">Y</span><span class="p">);</span>

            <span class="kt">string</span> <span class="n">str</span> <span class="p">=</span> <span class="s">$"R: </span><span class="p">{</span><span class="n">temp</span><span class="p">.</span><span class="n">R</span><span class="p">}</span><span class="s"> G: </span><span class="p">{</span><span class="n">temp</span><span class="p">.</span><span class="n">G</span><span class="p">}</span><span class="s"> B: </span><span class="p">{</span><span class="n">temp</span><span class="p">.</span><span class="n">B</span><span class="p">}</span><span class="s"> "</span><span class="p">;</span>

</code></pre></div></div>

<p>获得图片中鼠标点击的颜色。这个方法有时炸了，都是 255 。</p>

<!-- 

如果想要使用  BitmapImage 的 UriSource 转为 WriteableBitmap，需要 WriteableBitmapEx 。他是在 WPF 就被大家喜欢的库。如何安装 WriteableBitmapEx ，其实有了Nuget 基本没问题。

搜索 WriteableBitmapEx  Nuget

然后搜索到了，我们要什么，好像我也不知道。

我就知道可以使用 `  WriteableBitmap image = await BitmapFactory.New(1, 1).FromContent((BitmapImage).UriSource);`

那么转 byte[] 如何做，有了 WriteableBitmap ，下面的我也不知道，不要问我。

如果使用 BitmapImage 图片是 SetSource，那么我也不会。

## 获取图片中鼠标点击的颜色

获取鼠标点击的那个点，图片的颜色。那么图片之外，界面呢？其实我们还可以把界面截图，然后获取。

那么我们需要首先在 Image 使用 Tap ，假如图片 source 是 BitmapImage

前提安装 WriteableBitmapEx ，假如我们的 ViewModel有一个 BitmapImage 的图片 Image ，于是我们可以使用
        
```csharp
            var position = e.GetPosition(sender as UIElement); //鼠标点击的在哪

            WriteableBitmap image = await BitmapFactory.New(1, 1).FromContent((View.Image).UriSource); //我上面说的如何把 BitmapImage 转 WriteableBitmapEx
            
            var temp = image.GetPixel((int) position.X, (int) position.Y);

            string str = $"R: {temp.R} G: {temp.G} B: {temp.B} ";

```

获得图片中鼠标点击的颜色。这个方法有时炸了，都是 255 。

 -->
<p>代码：https://github.com/lindexi/UWP/tree/master/uwp/src/ImageMoseClick</p>

<h2 id="获取dpi">获取Dpi</h2>

<p>可以使用下面代码获取图片DPI。</p>

<p>我的图片从解决方案获得，大家可以从任意的位置获取，只要可以转换为 IRandomAccessStream</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">var</span> <span class="n">file</span> <span class="p">=</span> <span class="k">await</span> <span class="n">StorageFile</span><span class="p">.</span><span class="nf">GetFileFromApplicationUriAsync</span><span class="p">(</span><span class="k">new</span> <span class="nf">Uri</span><span class="p">(</span><span class="s">"ms-appx:///Assets/lindexi.png"</span><span class="p">));</span>
 <span class="k">using</span> <span class="p">(</span><span class="n">IRandomAccessStream</span> <span class="n">stream</span> <span class="p">=</span> <span class="k">await</span> <span class="n">file</span><span class="p">.</span><span class="nf">OpenReadAsync</span><span class="p">())</span>
 <span class="p">{</span>                
     <span class="n">BitmapDecoder</span> <span class="n">decoder</span> <span class="p">=</span> <span class="k">await</span> <span class="n">BitmapDecoder</span><span class="p">.</span><span class="nf">CreateAsync</span><span class="p">(</span><span class="n">BitmapDecoder</span><span class="p">.</span><span class="n">PngDecoderId</span><span class="p">,</span> <span class="n">stream</span><span class="p">);</span> 
     <span class="kt">var</span> <span class="n">DpiX</span> <span class="p">=</span> <span class="n">decoder</span><span class="p">.</span><span class="n">DpiX</span><span class="p">;</span>
     <span class="kt">var</span> <span class="n">DpiY</span> <span class="p">=</span> <span class="n">decoder</span><span class="p">.</span><span class="n">DpiY</span><span class="p">;</span>                 
 <span class="p">}</span>

</code></pre></div></div>

<p>如果需要保存网络图片到本地，请到<a href="https://blog.lindexi.com/post/win10-uwp-%E5%AD%98%E6%94%BE%E7%BD%91%E7%BB%9C%E5%9B%BE%E7%89%87%E5%88%B0%E6%9C%AC%E5%9C%B0.html">win10 uwp 存放网络图片到本地</a></p>

<p>参见：http://www.cnblogs.com/cjw1115/p/5164327.html</p>

<p>http://www.cnblogs.com/yuanforprogram/p/4819307.html</p>

<p>http://stackoverflow.com/questions/41439543/how-can-i-get-the-pixel-color-of-an-image-at-the-current-pointer-position-in-a-u</p>

<p>http://www.cnblogs.com/mqxs/p/5707620.html</p>

:ET