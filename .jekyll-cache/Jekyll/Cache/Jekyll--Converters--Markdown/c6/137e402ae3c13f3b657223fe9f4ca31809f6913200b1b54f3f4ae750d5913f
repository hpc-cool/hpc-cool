I"s<<p>本文告诉大家 WPF 的 StylusPlugIn 为什么能做高性能书写，在我的上一篇博客和大家介绍了 WPF 的触摸原理，但是没有详细告诉大家如何通过触摸原理知道如何去做一个高速获得触摸的应用，所以本文就在上一篇博客的基础继续告诉大家底层的原理
如果觉得原理很无聊，就直接关闭本文，因为本文都是理论，不会告诉大家如何做高性能书写</p>

<!--more-->

<!-- CreateTime:2019/11/29 10:20:39 -->

<!-- csdn -->

<!-- 标签：WPF，源代码分析，笔迹 -->

<p>在 WPF 如果想要做高性能的书写，就需要足够快获得用户的触摸输入，而如果直接拿到的是路由的输入就会存在下面的问题</p>

<ul>
  <li>
    <p>主线程卡住了</p>
  </li>
  <li>
    <p>主线程没有全力处理触摸笔迹</p>
  </li>
  <li>
    <p>路由事件本身的耗时</p>
  </li>
  <li>
    <p>元素多了路由事件就需要经过很多的元素</p>
  </li>
</ul>

<p>在用户触摸屏幕的时候，会在 <code class="language-plaintext highlighter-rouge">PenThreadWorker.ThreadProc</code> 里面的 <code class="language-plaintext highlighter-rouge">UnsafeNativeMethods.GetPenEvent</code> 或 <code class="language-plaintext highlighter-rouge">UnsafeNativeMethods.GetPenEventMultiple</code> 拿到触摸的消息，从而调用 <code class="language-plaintext highlighter-rouge">PenThreadWorker.FireEvent</code> 调用 <code class="language-plaintext highlighter-rouge">PenContext</code> 的对应的方法，从 <a href="https://blog.lindexi.com/post/WPF-%E8%A7%A6%E6%91%B8%E5%88%B0%E4%BA%8B%E4%BB%B6.html">WPF 触摸到事件</a> 可以看到，从 <code class="language-plaintext highlighter-rouge">PenThreadWorker.ThreadProc</code> 到 <code class="language-plaintext highlighter-rouge">PenThreadWorker.FireEvent</code>  的过程</p>

<!-- ![](image/WPF 触摸到事件/WPF 触摸到事件4.png) -->

<p><img src="http://image.acmx.xyz/lindexi%2F2018815111230935" alt="" /></p>

<p>这里需要补充一下，从  <code class="language-plaintext highlighter-rouge">PenThreadWorker.FireEvent</code> 可以调用 PenContext 三个不同的方法，分别是 FirePenDown 、FirePackets、FirePenUp 而这几个方法最后都会调用到 <code class="language-plaintext highlighter-rouge">WispLogic.ProcessInput</code> 方法。在 <code class="language-plaintext highlighter-rouge">WispLogic.ProcessInput</code> 经过封装调用 <code class="language-plaintext highlighter-rouge">WispLogic.ProcessInputReport</code>  在这个函数里面就会执行所有的 StylusPlugin 请看代码</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>		<span class="k">private</span> <span class="k">void</span> <span class="nf">ProcessInputReport</span><span class="p">(</span><span class="n">RawStylusInputReport</span> <span class="n">inputReport</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="n">WispStylusDevice</span> <span class="n">wispStylusDevice</span> <span class="p">=</span> <span class="k">this</span><span class="p">.</span><span class="nf">FindStylusDeviceWithLock</span><span class="p">(</span><span class="n">inputReport</span><span class="p">.</span><span class="n">StylusDeviceId</span><span class="p">);</span>
			<span class="n">inputReport</span><span class="p">.</span><span class="n">StylusDevice</span> <span class="p">=</span> <span class="p">((</span><span class="n">wispStylusDevice</span> <span class="p">!=</span> <span class="k">null</span><span class="p">)</span> <span class="p">?</span> <span class="n">wispStylusDevice</span><span class="p">.</span><span class="n">StylusDevice</span> <span class="p">:</span> <span class="k">null</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(!</span><span class="k">this</span><span class="p">.</span><span class="n">_inDragDrop</span> <span class="p">||</span> <span class="p">!</span><span class="n">inputReport</span><span class="p">.</span><span class="n">PenContext</span><span class="p">.</span><span class="n">Contexts</span><span class="p">.</span><span class="n">IsWindowDisabled</span><span class="p">)</span>
			<span class="p">{</span>
				<span class="k">this</span><span class="p">.</span><span class="nf">InvokeStylusPluginCollection</span><span class="p">(</span><span class="n">inputReport</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="k">this</span><span class="p">.</span><span class="nf">CoalesceAndQueueStylusEvent</span><span class="p">(</span><span class="n">inputReport</span><span class="p">);</span>
		<span class="p">}</span>
</code></pre></div></div>

<p>从上面代码可以看到 <code class="language-plaintext highlighter-rouge">InvokeStylusPluginCollection</code> 就是运行 StylusPlugin 集合，这里会调用所有的 StylusPlugin 类</p>

<p>那么 WPF 怎么知道当前的程序有哪些 StylusPlugin 可以被调用，下面先从如何寻找开始说</p>

<p>在 <code class="language-plaintext highlighter-rouge">PenContexts.InvokeStylusPluginCollection</code> 函数会调用 <code class="language-plaintext highlighter-rouge">PenContexts.TargetPlugInCollection</code> 函数拿到所有可以调用的 <code class="language-plaintext highlighter-rouge">StylusPlugInCollection</code> 进行运行。</p>

<p>在 <code class="language-plaintext highlighter-rouge">PenContexts.TargetPlugInCollection</code> 会先尝试拿到已经捕获的 PlugInCollection 进行返回，只有在没有拿到的时候才会执行 <code class="language-plaintext highlighter-rouge">HittestPlugInCollection</code> 先来看一下 TargetPlugInCollection 的代码，下面的代码被我删除了大部分无关的代码</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>		<span class="k">internal</span> <span class="n">StylusPlugInCollection</span> <span class="nf">TargetPlugInCollection</span><span class="p">(</span><span class="n">RawStylusInputReport</span> <span class="n">inputReport</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="kt">var</span> <span class="n">wispStylusDevice</span> <span class="p">=</span> <span class="n">inputReport</span><span class="p">.</span><span class="n">StylusDevice</span><span class="p">.</span><span class="n">As</span><span class="p">&lt;</span><span class="n">WispStylusDevice</span><span class="p">&gt;();</span>
			
			<span class="c1">// We're on the pen thread so can't touch visual tree.  Use capturedPlugIn (if capture on) or cached rects.</span>
			<span class="c1">// 现在是 Pen 的线程不在主线程，无法直接访问到视觉树</span>
			<span class="n">StylusPlugInCollection</span> <span class="n">stylusPlugInCollection</span> <span class="p">=</span> <span class="n">wispStylusDevice</span><span class="p">.</span><span class="nf">GetCapturedPlugInCollection</span><span class="p">(</span><span class="n">our</span> <span class="kt">bool</span> <span class="n">elementHasCapture</span><span class="p">);</span>

			<span class="c1">// 没有拿到值的时候就使用 HittestPlugInCollection 函数</span>
			<span class="k">if</span> <span class="p">(!</span><span class="n">elementHasCapture</span><span class="p">)</span>
			<span class="p">{</span>
				<span class="kt">int</span><span class="p">[]</span> <span class="n">data</span> <span class="p">=</span> <span class="n">inputReport</span><span class="p">.</span><span class="n">Data</span><span class="p">;</span>
				<span class="c1">// 下面这句话是被简化，会在本文下面仔细说明</span>
				<span class="n">Point</span> <span class="n">point</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">Point</span><span class="p">((</span><span class="kt">double</span><span class="p">)</span><span class="n">data</span><span class="p">[</span><span class="n">xx</span><span class="p">],</span> <span class="p">(</span><span class="kt">double</span><span class="p">)</span><span class="n">data</span><span class="p">[</span><span class="n">xx</span><span class="p">]);</span>

				<span class="n">stylusPlugInCollection</span> <span class="p">=</span> <span class="k">this</span><span class="p">.</span><span class="nf">HittestPlugInCollection</span><span class="p">(</span><span class="n">point</span><span class="p">);</span>
			<span class="p">}</span>
			
			<span class="k">return</span> <span class="n">stylusPlugInCollection</span><span class="p">;</span>
		<span class="p">}</span>
</code></pre></div></div>

<p>那么 <code class="language-plaintext highlighter-rouge">WispStylusDevice.GetCapturedPlugInCollection</code> 是如何寻找可以返回的 StylusPlugInCollection 的值，下面请看 GetCapturedPlugInCollection 代码</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="k">internal</span> <span class="k">override</span> <span class="n">StylusPlugInCollection</span> <span class="nf">GetCapturedPlugInCollection</span><span class="p">(</span><span class="k">ref</span> <span class="kt">bool</span> <span class="n">elementHasCapture</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">elementHasCapture</span> <span class="p">=</span> <span class="n">_stylusCapture</span> <span class="p">!=</span> <span class="k">null</span><span class="p">;</span>
        <span class="k">return</span> <span class="n">_stylusCapturePlugInCollection</span><span class="p">;</span>
    <span class="p">}</span>
</code></pre></div></div>

<p>可以看到 GetCapturedPlugInCollection 的代码非常简单，只是返回 <code class="language-plaintext highlighter-rouge">_stylusCapturePlugInCollection</code> 的值，关于 <code class="language-plaintext highlighter-rouge">_stylusCapturePlugInCollection</code> 的设置是在  <code class="language-plaintext highlighter-rouge">WispStylusDevice.ChangeStylusCapture</code> 函数进行设置，至于是什么时候才进行设置，就暂时跳过</p>

<p>这个做法是因为用户可以设置 xx 元素捕获输入，于是无论在哪里按下都需要触发捕获的元素，而忽略了命中到的元素。</p>

<p>一般是无法从 <code class="language-plaintext highlighter-rouge">WispStylusDevice.GetCapturedPlugInCollection</code> 返回值的，所以就需要使用 <code class="language-plaintext highlighter-rouge">inputReport.Data</code> 转换点，通过点来做命中测试，找到命中的元素</p>

<p>从 TargetPlugInCollection 方法可以看到如何转换  inputReport.Data 为点，这里的  inputReport.Data 是 <code class="language-plaintext highlighter-rouge">int[]</code> 类，通过下面的方法可以转换为点，也就是替换上面的 <code class="language-plaintext highlighter-rouge">Point point = new Point((double)data[xx], (double)data[xx]);</code> 方法</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">inputArrayLengthPerPoint</span> <span class="p">=</span> <span class="n">inputReport</span><span class="p">.</span><span class="n">PenContext</span><span class="p">.</span><span class="n">StylusPointDescription</span><span class="p">.</span><span class="nf">GetInputArrayLengthPerPoint</span><span class="p">();</span>
<span class="kt">int</span><span class="p">[]</span> <span class="n">data</span> <span class="p">=</span> <span class="n">inputReport</span><span class="p">.</span><span class="n">Data</span><span class="p">;</span>
<span class="n">Point</span> <span class="n">point</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">Point</span><span class="p">((</span><span class="kt">double</span><span class="p">)</span><span class="n">data</span><span class="p">[</span><span class="n">data</span><span class="p">.</span><span class="n">Length</span> <span class="p">-</span> <span class="n">inputArrayLengthPerPoint</span><span class="p">],</span> <span class="p">(</span><span class="kt">double</span><span class="p">)</span><span class="n">data</span><span class="p">[</span><span class="n">data</span><span class="p">.</span><span class="n">Length</span> <span class="p">-</span> <span class="n">inputArrayLengthPerPoint</span> <span class="p">+</span> <span class="m">1</span><span class="p">]);</span>
</code></pre></div></div>

<p>大概 GetInputArrayLengthPerPoint 的代码是</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        <span class="c1">/// &lt;summary&gt;</span>
        <span class="c1">/// Internal helper for determining how many ints in a raw int array </span>
        <span class="c1">/// correspond to one point we get from the input system</span>
        <span class="c1">/// &lt;/summary&gt;</span>
        <span class="k">internal</span> <span class="kt">int</span> <span class="nf">GetInputArrayLengthPerPoint</span><span class="p">()</span>
        <span class="p">{</span> 
            <span class="kt">int</span> <span class="n">buttonLength</span> <span class="p">=</span> <span class="n">_buttonCount</span> <span class="p">&gt;</span> <span class="m">0</span> <span class="p">?</span> <span class="m">1</span> <span class="p">:</span> <span class="m">0</span><span class="p">;</span>
            <span class="kt">int</span> <span class="n">propertyLength</span> <span class="p">=</span> <span class="p">(</span><span class="n">_stylusPointPropertyInfos</span><span class="p">.</span><span class="n">Length</span> <span class="p">-</span> <span class="n">_buttonCount</span><span class="p">)</span> <span class="p">+</span> <span class="n">buttonLength</span><span class="p">;</span> 
            <span class="k">if</span> <span class="p">(!</span><span class="k">this</span><span class="p">.</span><span class="n">ContainsTruePressure</span><span class="p">)</span> 
            <span class="p">{</span>
                <span class="n">propertyLength</span><span class="p">--;</span> 
            <span class="p">}</span>
            <span class="k">return</span> <span class="n">propertyLength</span><span class="p">;</span>
        <span class="p">}</span>
</code></pre></div></div>

<p>暂时就认为通过这个方法可以将转换为点，但是在转换之后需要将这个点换为 WPF 坐标，转为 WPF 坐标之前需要先将点转屏幕坐标，通过屏幕坐标转 WPF 坐标</p>

<!-- ![](image/WPF 高速书写 StylusPlugIn 原理/WPF 高速书写 StylusPlugIn 原理0.png) -->

<!-- ![](http://image.acmx.xyz/lindexi%2F2018930203356206) -->

<!-- ![](image/WPF 高速书写 StylusPlugIn 原理/WPF 高速书写 StylusPlugIn 原理2.png) -->

<p><img src="http://image.acmx.xyz/lindexi%2F2018108203514549" alt="" /></p>

<p>然后调用 HittestPlugInCollection 找到命中的 stylusPlugInCollection 这里的命中测试和 WPF 的元素命中测试不相同，在于即使有元素挡住也会命中</p>

<!-- ![](image/WPF 高速书写 StylusPlugIn 原理/WPF 高速书写 StylusPlugIn 原理1.png) -->

<p><img src="http://image.acmx.xyz/lindexi%2F201810220224112" alt="" /></p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        <span class="n">StylusPlugInCollection</span> <span class="nf">HittestPlugInCollection</span><span class="p">(</span><span class="n">Point</span> <span class="n">pt</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">foreach</span> <span class="p">(</span><span class="n">StylusPlugInCollection</span> <span class="n">plugInCollection</span> <span class="k">in</span> <span class="n">_plugInCollectionList</span><span class="p">)</span>
            <span class="p">{</span> 
                <span class="k">if</span> <span class="p">(</span><span class="n">plugInCollection</span><span class="p">.</span><span class="nf">IsHit</span><span class="p">(</span><span class="n">pt</span><span class="p">))</span> 
                <span class="p">{</span>
                    <span class="k">return</span> <span class="n">plugInCollection</span><span class="p">;</span> 
                <span class="p">}</span>
            <span class="p">}</span>
 
            <span class="k">return</span> <span class="k">null</span><span class="p">;</span> 
        <span class="p">}</span>
</code></pre></div></div>

<p>这里的 <code class="language-plaintext highlighter-rouge">_plugInCollectionList</code> 就是 PenContexts 收集到的所有添加到 UIElement 的 StylusPlugIn 列表，这个值在 <code class="language-plaintext highlighter-rouge">PenContexts.AddStylusPlugInCollection</code> 添加了所有添加在 UIElement 的元素</p>

<p>关于 <code class="language-plaintext highlighter-rouge">PenContexts.AddStylusPlugInCollection</code> 在什么时候被调用，请看下面，这里的调用逻辑还是比较复杂，现在先假设已经添加了 <code class="language-plaintext highlighter-rouge">_plugInCollectionList</code> 只需要对里面的元素计算</p>

<p>从上面代码可以看到判断是否某个 <code class="language-plaintext highlighter-rouge">StylusPlugInCollection</code> 可以使用的方式是判断对应的第一个找到命中测试成功的元素。从上面的代码可以知道，一个 UIElement 可以对应一个 StylusPlugInCollection 而在本文下一节将会告诉大家的添加 StylusPlugIn 到输入就会讲到，在添加 StylusPlugInCollection 的时候就会进行一次层级排序，保证最前面的 StylusPlugInCollection 对应的 UIElement 是层级最高的，但因为 AddStylusPlugInCollection 的时机和布局时机不相同，所以相对层级最高的也只能做容器的层级。也就是容器里面包含其他元素，那么其他元素的层级就比容器高。而如果在同一容器放多个元素，那么是无法判断哪个元素层级更高，就按照加入的先后顺序</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        <span class="k">internal</span> <span class="k">void</span> <span class="nf">AddStylusPlugInCollection</span><span class="p">(</span><span class="n">StylusPlugInCollection</span> <span class="n">pic</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">this</span><span class="p">.</span><span class="n">_plugInCollectionList</span><span class="p">.</span><span class="nf">Insert</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nf">FindZOrderIndex</span><span class="p">(</span><span class="n">pic</span><span class="p">),</span> <span class="n">pic</span><span class="p">);</span>
        <span class="p">}</span>
</code></pre></div></div>

<p>这里的 AddStylusPlugInCollection 函数将会在窗口的 VisibleChanged 事件被调用到。而 FindZOrderIndex 的逻辑其实上对于同一容器的多个元素是依靠加入顺序决定，而不是层级关系</p>

<p>也就是如果存在两个元素，这两个元素都有 StylusPlugInCollection 而且两个元素重叠，那么点击到元素重叠的部分就会返回层级高的元素对应的 StylusPlugInCollection 而不会使用层级低的</p>

<p>在 StylusPlugInCollection 的 IsHit 方法是通过先转换点到相同的变换，然后判断是否在元素的矩形内。</p>

<p>这里的 <code class="language-plaintext highlighter-rouge">_rc</code> 是使用窗口的测量单位 In window root measured units</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        <span class="c1">/// &lt;summary&gt; </span>
        <span class="c1">/// Check whether a point hits the element</span>
        <span class="c1">/// This method is called from the real-time context. </span>
        <span class="c1">/// &lt;/summary&gt; </span>
        <span class="c1">/// &lt;param name="pt"&gt;a point to check</span>
        <span class="c1">/// &lt;returns&gt;true if the point is within the bound of the element; false otherwise&lt;/returns&gt; </span>
        <span class="k">internal</span> <span class="kt">bool</span> <span class="nf">IsHit</span><span class="p">(</span><span class="n">Point</span> <span class="n">pt</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">Point</span> <span class="n">ptElement</span> <span class="p">=</span> <span class="n">pt</span><span class="p">;</span>
            <span class="n">_viewToElement</span><span class="p">.</span><span class="nf">TryTransform</span><span class="p">(</span><span class="n">ptElement</span><span class="p">,</span> <span class="k">out</span> <span class="n">ptElement</span><span class="p">);</span> 
            <span class="k">return</span> <span class="n">_rc</span><span class="p">.</span><span class="nf">Contains</span><span class="p">(</span><span class="n">ptElement</span><span class="p">);</span>
        <span class="p">}</span> 
</code></pre></div></div>

<p>这里的 <code class="language-plaintext highlighter-rouge">_rc</code> 是在 UpdateRect 函数拿元素的 RenderSize 请看代码</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>            <span class="k">if</span> <span class="p">(</span><span class="n">_element</span><span class="p">.</span><span class="n">IsArrangeValid</span> <span class="p">&amp;&amp;</span> <span class="n">_element</span><span class="p">.</span><span class="n">IsEnabled</span> <span class="p">&amp;&amp;</span> <span class="n">_element</span><span class="p">.</span><span class="n">IsVisible</span> <span class="p">&amp;&amp;</span> <span class="n">_element</span><span class="p">.</span><span class="n">IsHitTestVisible</span><span class="p">)</span> 
            <span class="p">{</span>
                <span class="n">_rc</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">Rect</span><span class="p">(</span><span class="k">new</span> <span class="nf">Point</span><span class="p">(),</span> <span class="n">_element</span><span class="p">.</span><span class="n">RenderSize</span><span class="p">);</span><span class="c1">// _element.GetContentBoundingBox(); </span>
            <span class="p">}</span>
            <span class="k">else</span>
            <span class="p">{</span>
            	<span class="n">_rc</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">Rect</span><span class="p">();</span> <span class="c1">// empty rect so we don't hittest it.</span>
            <span class="p">}</span>
</code></pre></div></div>

<p>从上面的代码可以看到判断的方法很简单，所以性能很好</p>

<p>在获得 StylusPlugInCollection 之后返回 InvokeStylusPluginCollection 函数</p>

<!-- ![](image/WPF 高速书写 StylusPlugIn 原理/WPF 高速书写 StylusPlugIn 原理3.png) -->

<p><img src="http://image.acmx.xyz/lindexi%2F2018108203932919" alt="" /></p>

<p>如果找到了 StylusPlugInCollection 而且 <code class="language-plaintext highlighter-rouge">wispStylusDevice.CurrentNonVerifiedTarget</code> 不存在，就创建 RawStylusInput 然后调用 <code class="language-plaintext highlighter-rouge">StylusPlugInCollection.FireRawStylusInput</code> 请看代码</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">internal</span> <span class="k">void</span> <span class="nf">InvokeStylusPluginCollection</span><span class="p">(</span><span class="n">RawStylusInputReport</span> <span class="n">inputReport</span><span class="p">)</span> 
<span class="p">{</span>
	<span class="n">StylusPlugInCollection</span> <span class="n">pic</span> <span class="p">=</span> <span class="nf">TargetPlugInCollection</span><span class="p">(</span><span class="n">inputReport</span><span class="p">);</span> 
	<span class="k">if</span> <span class="p">(</span><span class="n">pic</span> <span class="p">!=</span> <span class="k">null</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">RawStylusInput</span> <span class="n">rawStylusInput</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">RawStylusInput</span><span class="p">(</span><span class="n">inputReport</span><span class="p">,</span> <span class="n">pic</span><span class="p">);</span>
		<span class="c1">// We are on the pen thread, just call directly</span>
		<span class="n">pic</span><span class="p">.</span><span class="nf">FireRawStylusInput</span><span class="p">(</span><span class="n">rawStylusInput</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>如果是在第一次进入，也就是在 Down 的时候还会在 InvokeStylusPluginCollection 进入额外的代码，但是本文这里忽略掉第一次进入</p>

<p>调用 FireRawStylusInput 传入 RawStylusInput 就会自动在 StylusPlugInCollection 找到对应的 StylusPlugIn 调用 StylusPlugIn 的 RawStylusInput 方法</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>                        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="p">&lt;</span> <span class="k">this</span><span class="p">.</span><span class="n">Count</span><span class="p">;</span> <span class="n">i</span><span class="p">++)</span> 
                        <span class="p">{</span>
                            <span class="n">StylusPlugIn</span> <span class="n">plugIn</span> <span class="p">=</span> <span class="k">base</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
                            <span class="c1">// set current plugin so any callback data gets an owner.</span>
                            <span class="n">args</span><span class="p">.</span><span class="n">CurrentNotifyPlugIn</span> <span class="p">=</span> <span class="n">plugIn</span><span class="p">;</span> 
                            <span class="n">plugIn</span><span class="p">.</span><span class="nf">RawStylusInput</span><span class="p">(</span><span class="n">args</span><span class="p">);</span>
                        <span class="p">}</span> 
</code></pre></div></div>

<p>不要看在 plugIn 是调用一个方法 RawStylusInput 传入参数，需要知道在 PenThreadWorker 的 FireEvent 方法就转换了参数，在 PenThreadWorker 的 ProcessInput 方法传入了 RawStylusActions 对应按下和移动</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>		<span class="k">internal</span> <span class="k">void</span> <span class="nf">OnPenDown</span><span class="p">(</span><span class="n">PenContext</span> <span class="n">penContext</span><span class="p">,</span> <span class="kt">int</span> <span class="n">tabletDeviceId</span><span class="p">,</span> <span class="kt">int</span> <span class="n">stylusPointerId</span><span class="p">,</span> <span class="kt">int</span><span class="p">[]</span> <span class="n">data</span><span class="p">,</span> <span class="kt">int</span> <span class="n">timestamp</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="k">this</span><span class="p">.</span><span class="nf">ProcessInput</span><span class="p">(</span><span class="n">RawStylusActions</span><span class="p">.</span><span class="n">Down</span><span class="p">,</span> <span class="n">penContext</span><span class="p">,</span> <span class="n">tabletDeviceId</span><span class="p">,</span> <span class="n">stylusPointerId</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">timestamp</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="k">internal</span> <span class="k">void</span> <span class="nf">OnPenUp</span><span class="p">(</span><span class="n">PenContext</span> <span class="n">penContext</span><span class="p">,</span> <span class="kt">int</span> <span class="n">tabletDeviceId</span><span class="p">,</span> <span class="kt">int</span> <span class="n">stylusPointerId</span><span class="p">,</span> <span class="kt">int</span><span class="p">[]</span> <span class="n">data</span><span class="p">,</span> <span class="kt">int</span> <span class="n">timestamp</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="k">this</span><span class="p">.</span><span class="nf">ProcessInput</span><span class="p">(</span><span class="n">RawStylusActions</span><span class="p">.</span><span class="n">Up</span><span class="p">,</span> <span class="n">penContext</span><span class="p">,</span> <span class="n">tabletDeviceId</span><span class="p">,</span> <span class="n">stylusPointerId</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">timestamp</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="k">internal</span> <span class="k">void</span> <span class="nf">OnPackets</span><span class="p">(</span><span class="n">PenContext</span> <span class="n">penContext</span><span class="p">,</span> <span class="kt">int</span> <span class="n">tabletDeviceId</span><span class="p">,</span> <span class="kt">int</span> <span class="n">stylusPointerId</span><span class="p">,</span> <span class="kt">int</span><span class="p">[]</span> <span class="n">data</span><span class="p">,</span> <span class="kt">int</span> <span class="n">timestamp</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="k">this</span><span class="p">.</span><span class="nf">ProcessInput</span><span class="p">(</span><span class="n">RawStylusActions</span><span class="p">.</span><span class="n">Move</span><span class="p">,</span> <span class="n">penContext</span><span class="p">,</span> <span class="n">tabletDeviceId</span><span class="p">,</span> <span class="n">stylusPointerId</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">timestamp</span><span class="p">);</span>
		<span class="p">}</span>
</code></pre></div></div>

<p>所以传入了 RawStylusInput 可以通过 RawStylusActions 判断调用的方法</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1">// StylusPlugIn</span>
       <span class="k">internal</span> <span class="k">void</span> <span class="nf">RawStylusInput</span><span class="p">(</span><span class="n">RawStylusInput</span> <span class="n">rawStylusInput</span><span class="p">)</span> 
        <span class="p">{</span>
            <span class="c1">// Only fire if plugin is enabled and hooked up to plugincollection. </span>
            
            <span class="k">switch</span><span class="p">(</span> <span class="n">rawStylusInput</span><span class="p">.</span><span class="n">Report</span><span class="p">.</span><span class="n">Actions</span> <span class="p">)</span> 
            <span class="p">{</span>
                <span class="k">case</span> <span class="n">RawStylusActions</span><span class="p">.</span><span class="n">Down</span><span class="p">:</span>
                    <span class="nf">OnStylusDown</span><span class="p">(</span><span class="n">rawStylusInput</span><span class="p">);</span>
                    <span class="k">break</span><span class="p">;</span> 
                <span class="k">case</span> <span class="n">RawStylusActions</span><span class="p">.</span><span class="n">Move</span><span class="p">:</span>
                    <span class="nf">OnStylusMove</span><span class="p">(</span><span class="n">rawStylusInput</span><span class="p">);</span> 
                    <span class="k">break</span><span class="p">;</span> 
                <span class="k">case</span> <span class="n">RawStylusActions</span><span class="p">.</span><span class="n">Up</span><span class="p">:</span>
                    <span class="nf">OnStylusUp</span><span class="p">(</span><span class="n">rawStylusInput</span><span class="p">);</span> 
                    <span class="k">break</span><span class="p">;</span>
            <span class="p">}</span>
            
        <span class="p">}</span> 
</code></pre></div></div>

<p>这样就调用了对应的方法，重写的时候就会发现，可以重写上面的几个方法，在 StylusPlugIn 类的 OnStylusDown 三个方法都是虚方法</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        <span class="k">protected</span> <span class="k">virtual</span> <span class="k">void</span> <span class="nf">OnStylusDown</span><span class="p">(</span><span class="n">RawStylusInput</span> <span class="n">rawStylusInput</span><span class="p">)</span>
        <span class="p">{</span> 
        <span class="p">}</span>
        
        <span class="k">protected</span> <span class="k">virtual</span> <span class="k">void</span> <span class="nf">OnStylusMove</span><span class="p">(</span><span class="n">RawStylusInput</span> <span class="n">rawStylusInput</span><span class="p">)</span> 
        <span class="p">{</span>
        <span class="p">}</span> 
        
        <span class="k">protected</span> <span class="k">virtual</span> <span class="k">void</span> <span class="nf">OnStylusUp</span><span class="p">(</span><span class="n">RawStylusInput</span> <span class="n">rawStylusInput</span><span class="p">)</span> 
        <span class="p">{</span> 
        <span class="p">}</span>
</code></pre></div></div>

<!-- ![](image/WPF 高速书写 StylusPlugIn 原理/WPF 高速书写 StylusPlugIn 原理4.png) -->

<p><img src="http://image.acmx.xyz/lindexi%2F2018108212117763" alt="" /></p>

<p>从上面的调用可以看到 StylusPlugIn 从触摸到调用的函数很少，如果要做到高性能就需要使用这个方法</p>

<h2 id="添加-stylusplugin-到输入">添加 StylusPlugIn 到输入</h2>

<p>在默认的 UIElement 是不创建 StylusPlugInCollection 的，只有在第一次使用 StylusPlugInCollection 的时候才会创建，创建的时候 StylusPlugInCollection 的构造函数需要传入创建的 UIElement 而添加对应的  StylusPlugIn 就是在对应的 UIElement 的创建的构造函数添加记录本地的 <code class="language-plaintext highlighter-rouge">_element = element</code> 这里还不添加事件</p>

<p>因为可能有无聊的用户只是拿一下 <code class="language-plaintext highlighter-rouge">UIElement.StylusPlugInCollection</code> 这里是不需要做什么只是创建一个类记录对应的元素</p>

<p>而实际上在加入到 <code class="language-plaintext highlighter-rouge">PenContexts._plugInCollectionList</code> 的过程还不是直接的添加，在用户调用 <code class="language-plaintext highlighter-rouge">StylusPlugIns.Add(new StylusPlugIn());</code> 的时候，调用 StylusPlugInCollection 重写的 InsertItem 函数</p>

<p>这个函数有一个很重要的是，虽然在使用 <code class="language-plaintext highlighter-rouge">StylusPlugIn</code> 是在另一个线程，但是在添加到元素的时候必须在主线程，因为在 InsertItem 的第一句就是判断元素是否在这个线程可以拿到</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="k">class</span> <span class="nc">StylusPlugInCollection</span> <span class="p">:</span> <span class="n">Collection</span><span class="p">&lt;</span><span class="n">StylusPlugIn</span><span class="p">&gt;</span>
<span class="p">{</span>
        <span class="k">protected</span> <span class="k">override</span> <span class="k">void</span> <span class="nf">InsertItem</span><span class="p">(</span><span class="kt">int</span> <span class="n">index</span><span class="p">,</span> <span class="n">StylusPlugIn</span> <span class="n">plugIn</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="k">this</span><span class="p">.</span><span class="n">_element</span><span class="p">.</span><span class="nf">VerifyAccess</span><span class="p">();</span>
            <span class="c1">// 你以为下面就没代码了？</span>
		<span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>在 InsertItem 会调用主要的函数 EnsureEventsHooked 在这个函数才是添加事件的函数，这样做是为了防止用户只是去拿 StylusPlugInCollection 就添加了事件，在主线程如果添加了很多事件，会让主线程运行被太多的事件拖慢，所以代码就在真的进行插入的时候才添加事件</p>

<p>这里为什么需要添加事件？因为在元素的可视化变化就需要修改属性，请看添加的事件</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>                <span class="n">_element</span><span class="p">.</span><span class="n">IsEnabledChanged</span> <span class="p">+=</span> <span class="n">_isEnabledChangedEventHandler</span><span class="p">;</span> 
                <span class="n">_element</span><span class="p">.</span><span class="n">IsVisibleChanged</span> <span class="p">+=</span> <span class="n">_isVisibleChangedEventHandler</span><span class="p">;</span>
                <span class="n">_element</span><span class="p">.</span><span class="n">IsHitTestVisibleChanged</span> <span class="p">+=</span> <span class="n">_isHitTestVisibleChangedEventHandler</span><span class="p">;</span> 
                <span class="n">PresentationSource</span><span class="p">.</span><span class="nf">AddSourceChangedHandler</span><span class="p">(</span><span class="n">_element</span><span class="p">,</span> <span class="n">_sourceChangedEventHandler</span><span class="p">);</span>  <span class="c1">// has a security linkdemand</span>
                <span class="n">_element</span><span class="p">.</span><span class="n">LayoutUpdated</span> <span class="p">+=</span> <span class="n">_layoutChangedEventHandler</span><span class="p">;</span>
</code></pre></div></div>

<p>监听了这么多事件是在做什么？下面一一列举出来，直接给代码</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        <span class="k">private</span> <span class="k">void</span> <span class="nf">OnIsEnabledChanged</span><span class="p">(</span><span class="kt">object</span> <span class="n">sender</span><span class="p">,</span> <span class="n">DependencyPropertyChangedEventArgs</span> <span class="n">e</span><span class="p">)</span> 
        <span class="p">{</span>
            <span class="nf">UpdatePenContextsState</span><span class="p">();</span>
        <span class="p">}</span> 
 
        <span class="k">private</span> <span class="k">void</span> <span class="nf">OnIsVisibleChanged</span><span class="p">(</span><span class="kt">object</span> <span class="n">sender</span><span class="p">,</span> <span class="n">DependencyPropertyChangedEventArgs</span> <span class="n">e</span><span class="p">)</span> 
        <span class="p">{</span> 
            <span class="nf">UpdatePenContextsState</span><span class="p">();</span> 
        <span class="p">}</span>
 
        <span class="k">private</span> <span class="k">void</span> <span class="nf">OnIsHitTestVisibleChanged</span><span class="p">(</span><span class="kt">object</span> <span class="n">sender</span><span class="p">,</span> <span class="n">DependencyPropertyChangedEventArgs</span> <span class="n">e</span><span class="p">)</span>
        <span class="p">{</span> 
            <span class="nf">UpdatePenContextsState</span><span class="p">();</span> 
        <span class="p">}</span> 
 
        <span class="k">private</span> <span class="k">void</span> <span class="nf">OnRenderTransformChanged</span><span class="p">(</span><span class="kt">object</span> <span class="n">sender</span><span class="p">,</span> <span class="n">EventArgs</span> <span class="n">e</span><span class="p">)</span> 
        <span class="p">{</span>
            <span class="nf">OnLayoutUpdated</span><span class="p">(</span><span class="n">sender</span><span class="p">,</span> <span class="n">e</span><span class="p">);</span>
        <span class="p">}</span>
  
        <span class="k">private</span> <span class="k">void</span> <span class="nf">OnSourceChanged</span><span class="p">(</span><span class="kt">object</span> <span class="n">sender</span><span class="p">,</span> <span class="n">SourceChangedEventArgs</span> <span class="n">e</span><span class="p">)</span>
        <span class="p">{</span> 
            <span class="c1">// This means that the element has been added or remvoed from its source. </span>
            <span class="nf">UpdatePenContextsState</span><span class="p">();</span>
        <span class="p">}</span> 
</code></pre></div></div>

<p>从上面可以看到是在调用 <code class="language-plaintext highlighter-rouge">UpdatePenContextsState</code> 函数，在 InsertItem 实际也是调用了这个函数，请看代码</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        <span class="k">protected</span> <span class="k">override</span> <span class="k">void</span> <span class="nf">InsertItem</span><span class="p">(</span><span class="kt">int</span> <span class="n">index</span><span class="p">,</span> <span class="n">StylusPlugIn</span> <span class="n">plugIn</span><span class="p">)</span>
        <span class="p">{</span>
        	<span class="nf">EnsureEventsHooked</span><span class="p">();</span>
        	<span class="k">base</span><span class="p">.</span><span class="nf">InsertItem</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">plugIn</span><span class="p">);</span> 
        	<span class="n">plugIn</span><span class="p">.</span><span class="nf">Added</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>
            <span class="nf">UpdatePenContextsState</span><span class="p">();</span> <span class="c1">// Add to PenContexts if element is in proper state (can fire isactiveforinput). </span>
        <span class="p">}</span>
</code></pre></div></div>

<p>在 UpdatePenContextsState 会将插入的 plugIn 放到 <code class="language-plaintext highlighter-rouge">PenContexts._plugInCollectionList</code> 但不是直接加入
，在加入之前需要从元素拿到元素的输入</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">private</span> <span class="k">void</span> <span class="nf">UpdatePenContextsState</span><span class="p">()</span>
<span class="p">{</span>
	<span class="n">PresentationSource</span> <span class="n">presentationSource</span> <span class="p">=</span> <span class="n">PresentationSource</span><span class="p">.</span><span class="nf">CriticalFromVisual</span><span class="p">(</span><span class="n">_element</span> <span class="k">as</span> <span class="n">Visual</span><span class="p">);</span>
	<span class="n">InputManager</span> <span class="n">inputManager</span> <span class="p">=</span> <span class="p">(</span><span class="n">InputManager</span><span class="p">)</span><span class="n">_element</span><span class="p">.</span><span class="n">Dispatcher</span><span class="p">.</span><span class="n">InputManager</span><span class="p">;</span>
    <span class="n">PenContexts</span> <span class="n">penContexts</span> <span class="p">=</span> <span class="n">inputManager</span><span class="p">.</span><span class="n">StylusLogic</span><span class="p">.</span><span class="nf">GetPenContextsFromHwnd</span><span class="p">(</span><span class="n">presentationSource</span><span class="p">);</span> 
    <span class="c1">// 下面还有一半</span>
<span class="p">}</span>
</code></pre></div></div>

<p>从元素拿到 inputManager 从 inputManager 拿到 PenContexts 也就是如果这个多个元素使用不同的输入是可以的，可以自己创建一个输入让元素放在创建的线程</p>

<p>需要说的是，这里的代码是 .NET 4.6.2 和之前的代码，最新的代码是将 <code class="language-plaintext highlighter-rouge">UpdatePenContextsState</code> 放在基类，原因是存在了两个 StylusPlugInCollectionBase 这里在后面会说到</p>

<p>在下面就是将 StylusPlugInCollection 加入到 penContexts 直接的代码是</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="n">penContexts</span><span class="p">.</span><span class="nf">AddStylusPlugInCollection</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>
</code></pre></div></div>

<p>实际上的代码是很多的，但是都是不需要关注的代码</p>

<p>这样在一开始添加就调用了 UpdatePenContextsState 如果在元素还没加入视觉树还没初始化，就会在元素的事件添加到 penContexts 如果元素发生了修改，也调用这个方法更新</p>

<p>这里可以学到的是，事件是只有在需要的时候才添加，而不是一开始就添加事件，然后在事件里面判断条件，这样可以防止事件因为添加太多，在做很小的事情都需要调用很多方法</p>

<h2 id="迁移的-stylusplugincollection-方法">迁移的 StylusPlugInCollection 方法</h2>

<p>如果反编译 .NET 4.7 是看不到 StylusPlugInCollection 的 UpdatePenContextsState 方法，这时不要以为我是在乱写，这里的方法是通过调用字段的方法来做</p>

<p>在 <code class="language-plaintext highlighter-rouge">_stylusPlugInCollectionImpl.UpdateState</code> 就是做原来 UpdatePenContextsState 的方法</p>

<p>在最新的代码是在 StylusPlugInCollection 需要创建 StylusPlugInCollectionBase 类</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>		<span class="k">internal</span> <span class="nf">StylusPlugInCollection</span><span class="p">(</span><span class="n">UIElement</span> <span class="n">element</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="k">this</span><span class="p">.</span><span class="n">_stylusPlugInCollectionImpl</span> <span class="p">=</span> <span class="n">StylusPlugInCollectionBase</span><span class="p">.</span><span class="nf">Create</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>
			
		<span class="p">}</span>
</code></pre></div></div>

<p>这样做是因为 .NET 4.7 可以使用 Pointer 消息需要 PointerStylusPlugInCollection 类</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>		<span class="k">internal</span> <span class="k">static</span> <span class="n">StylusPlugInCollectionBase</span> <span class="nf">Create</span><span class="p">(</span><span class="n">StylusPlugInCollection</span> <span class="n">wrapper</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="n">StylusPlugInCollectionBase</span> <span class="n">stylusPlugInCollectionBase</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">StylusLogic</span><span class="p">.</span><span class="n">IsPointerStackEnabled</span><span class="p">)</span>
			<span class="p">{</span>
				<span class="n">stylusPlugInCollectionBase</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">PointerStylusPlugInCollection</span><span class="p">();</span>
			<span class="p">}</span>
			<span class="k">else</span>
			<span class="p">{</span>
				<span class="n">stylusPlugInCollectionBase</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">WispStylusPlugInCollection</span><span class="p">();</span>
			<span class="p">}</span>
			<span class="n">stylusPlugInCollectionBase</span><span class="p">.</span><span class="n">Wrapper</span> <span class="p">=</span> <span class="n">wrapper</span><span class="p">;</span>
			<span class="k">return</span> <span class="n">stylusPlugInCollectionBase</span><span class="p">;</span>
		<span class="p">}</span>
</code></pre></div></div>

<p>将原来的 StylusPlugInCollection 的 UpdatePenContextsState 分为 stylusPlugInCollectionBase 的 UpdateState 方法</p>

<p>在 WispStylusPlugInCollection 、 PointerStylusPlugInCollection 调用 UpdateState 和  StylusPlugInCollection 的 UpdatePenContextsState 方法差不多，所以本文就使用 UpdatePenContextsState 和大家说</p>

<h2 id="使用-stylusplugin-的好处">使用 StylusPlugIn 的好处</h2>

<p>从本文可以知道，只有在使用了 StylusPlugIn 才会在触摸的时候在 <code class="language-plaintext highlighter-rouge">PenContexts.InvokeStylusPluginCollection</code> 调用对应的方法</p>

<p>这时调用 StylusPlugIn 是在触摸线程也就是 <a href="https://lindexi.gitee.io/post/WPF-%E8%A7%A6%E6%91%B8%E5%88%B0%E4%BA%8B%E4%BB%B6.html">Stylus Input</a> 线程运行，可以解决此时在主线程执行耗时的函数的时候，无法快速处理触摸</p>

<p>另一个是从命中测试上看，每次的命中测试都不需要经过复杂的视觉树，而是直接通过元素更改时，按照元素层级放在一个列表，通过判断列表每个元素的矩形判断触摸的点是否在矩形内，这里的命中测试的速度会比普通的元素的命中测试要快很多。</p>

<p>如果一个元素使用了 StylusPlugIn 会在触摸的时候最快获得触摸信息，而不需要等待路由事件。</p>

<p>这样就可以让 StylusPlugIn 在触摸被 WPF 影响的事件到最少</p>

<h2 id="代码">代码</h2>

<h3 id="pencontextstargetplugincollection">PenContexts.TargetPlugInCollection</h3>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>       <span class="c1">/// &lt;securitynote&gt;</span>
        <span class="c1">/// Critical - InputReport.InputSource has a LinkDemand so we need to be SecurityCritical. </span>
        <span class="c1">///             Called by InvokeStylusPluginCollection.</span>
        <span class="c1">///             TreatAsSafe boundary is mainly PenThread.ThreadProc and HwndWrapperHook class (via HwndSource.InputFilterMessage).</span>
        <span class="c1">///                 It can also be called via anyone with priviledge to call InputManager.ProcessInput().</span>
        <span class="c1">/// &lt;/securitynote&gt; </span>
        <span class="p">[</span><span class="n">SecurityCritical</span><span class="p">]</span>
        <span class="k">internal</span> <span class="n">StylusPlugInCollection</span> <span class="nf">TargetPlugInCollection</span><span class="p">(</span><span class="n">RawStylusInputReport</span> <span class="n">inputReport</span><span class="p">)</span> 
        <span class="p">{</span> 
            <span class="c1">// Caller must make call to this routine inside of lock(__rtiLock)!</span>
            <span class="n">StylusPlugInCollection</span> <span class="n">pic</span> <span class="p">=</span> <span class="k">null</span><span class="p">;</span> 
 
            <span class="c1">// We should only be called when not on the application thread!</span>
            <span class="n">System</span><span class="p">.</span><span class="n">Diagnostics</span><span class="p">.</span><span class="n">Debug</span><span class="p">.</span><span class="nf">Assert</span><span class="p">(!</span><span class="n">inputReport</span><span class="p">.</span><span class="n">StylusDevice</span><span class="p">.</span><span class="nf">CheckAccess</span><span class="p">());</span>
  
            <span class="c1">// We're on the pen thread so can't touch visual tree.  Use capturedPlugIn (if capture on) or cached rects.</span>
            <span class="kt">bool</span> <span class="n">elementHasCapture</span> <span class="p">=</span> <span class="k">false</span><span class="p">;</span> 
            <span class="n">pic</span> <span class="p">=</span> <span class="n">inputReport</span><span class="p">.</span><span class="n">StylusDevice</span><span class="p">.</span><span class="nf">GetCapturedPlugInCollection</span><span class="p">(</span><span class="k">ref</span> <span class="n">elementHasCapture</span><span class="p">);</span> 
            <span class="kt">int</span> <span class="n">pointLength</span> <span class="p">=</span> <span class="n">inputReport</span><span class="p">.</span><span class="n">PenContext</span><span class="p">.</span><span class="n">StylusPointDescription</span><span class="p">.</span><span class="nf">GetInputArrayLengthPerPoint</span><span class="p">();</span>
            <span class="c1">// Make sure that the captured Plugin Collection is still in the list.  CaptureChanges are </span>
            <span class="c1">// deferred so there is a window where the stylus device is not updated yet.  This protects us</span>
            <span class="c1">// from using a bogus plugin collecton for an element that is in an invalid state.</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">elementHasCapture</span> <span class="p">&amp;&amp;</span> <span class="p">!</span><span class="n">_plugInCollectionList</span><span class="p">.</span><span class="nf">Contains</span><span class="p">(</span><span class="n">pic</span><span class="p">))</span>
            <span class="p">{</span> 
                <span class="n">elementHasCapture</span> <span class="p">=</span> <span class="k">false</span><span class="p">;</span>  <span class="c1">// force true hittesting to be done!</span>
            <span class="p">}</span> 
  
            <span class="k">if</span> <span class="p">(!</span><span class="n">elementHasCapture</span> <span class="p">&amp;&amp;</span> <span class="n">inputReport</span><span class="p">.</span><span class="n">Data</span> <span class="p">!=</span> <span class="k">null</span> <span class="p">&amp;&amp;</span> <span class="n">inputReport</span><span class="p">.</span><span class="n">Data</span><span class="p">.</span><span class="n">Length</span> <span class="p">&gt;=</span> <span class="n">pointLength</span><span class="p">)</span>
            <span class="p">{</span> 
                <span class="kt">int</span><span class="p">[]</span> <span class="n">data</span> <span class="p">=</span> <span class="n">inputReport</span><span class="p">.</span><span class="n">Data</span><span class="p">;</span>
                <span class="n">System</span><span class="p">.</span><span class="n">Diagnostics</span><span class="p">.</span><span class="n">Debug</span><span class="p">.</span><span class="nf">Assert</span><span class="p">(</span><span class="n">data</span><span class="p">.</span><span class="n">Length</span> <span class="p">%</span> <span class="n">pointLength</span> <span class="p">==</span> <span class="m">0</span><span class="p">);</span>
                <span class="n">Point</span> <span class="n">ptTablet</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">Point</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">data</span><span class="p">.</span><span class="n">Length</span> <span class="p">-</span> <span class="n">pointLength</span><span class="p">],</span> <span class="n">data</span><span class="p">[</span><span class="n">data</span><span class="p">.</span><span class="n">Length</span> <span class="p">-</span> <span class="n">pointLength</span> <span class="p">+</span> <span class="m">1</span><span class="p">]);</span>
                <span class="c1">// Note: the StylusLogic data inside DeviceUnitsFromMeasurUnits is protected by __rtiLock. </span>
                <span class="n">ptTablet</span> <span class="p">=</span> <span class="n">ptTablet</span> <span class="p">*</span> <span class="n">inputReport</span><span class="p">.</span><span class="n">StylusDevice</span><span class="p">.</span><span class="n">TabletDevice</span><span class="p">.</span><span class="n">TabletToScreen</span><span class="p">;</span>
                <span class="n">ptTablet</span><span class="p">.</span><span class="n">X</span> <span class="p">=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">Math</span><span class="p">.</span><span class="nf">Round</span><span class="p">(</span><span class="n">ptTablet</span><span class="p">.</span><span class="n">X</span><span class="p">);</span> <span class="c1">// Make sure we snap to whole window pixels. </span>
                <span class="n">ptTablet</span><span class="p">.</span><span class="n">Y</span> <span class="p">=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">Math</span><span class="p">.</span><span class="nf">Round</span><span class="p">(</span><span class="n">ptTablet</span><span class="p">.</span><span class="n">Y</span><span class="p">);</span> 
                <span class="c1">// 经常这里不会对点修改，这里使用的是 measurePoint * _transformToDevice.Invert();</span>
                <span class="n">ptTablet</span> <span class="p">=</span> <span class="n">_stylusLogic</span><span class="p">.</span><span class="nf">MeasureUnitsFromDeviceUnits</span><span class="p">(</span><span class="n">ptTablet</span><span class="p">);</span> <span class="c1">// change to measured units now.</span>
  
                <span class="n">pic</span> <span class="p">=</span> <span class="nf">HittestPlugInCollection</span><span class="p">(</span><span class="n">ptTablet</span><span class="p">);</span> <span class="c1">// Use cached rectangles for UIElements.</span>
            <span class="p">}</span>
            <span class="k">return</span> <span class="n">pic</span><span class="p">;</span>
        <span class="p">}</span> 
 
</code></pre></div></div>

<h3 id="stylusplugincollectionupdatepencontextsstate">StylusPlugInCollection.UpdatePenContextsState</h3>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>       <span class="k">private</span> <span class="k">void</span> <span class="nf">UpdatePenContextsState</span><span class="p">()</span>
        <span class="p">{</span> 
            <span class="kt">bool</span> <span class="n">unhookPenContexts</span> <span class="p">=</span> <span class="k">true</span><span class="p">;</span>
  
            <span class="c1">// Disable processing of the queue during blocking operations to prevent unrelated reentrancy </span>
            <span class="c1">// which a call to Lock() can cause.</span>
            <span class="k">using</span> <span class="p">(</span><span class="n">_element</span><span class="p">.</span><span class="n">Dispatcher</span><span class="p">.</span><span class="nf">DisableProcessing</span><span class="p">())</span> 
            <span class="p">{</span>
                <span class="c1">// See if we should be enabled</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">_element</span><span class="p">.</span><span class="n">IsVisible</span> <span class="p">&amp;&amp;</span> <span class="n">_element</span><span class="p">.</span><span class="n">IsEnabled</span> <span class="p">&amp;&amp;</span> <span class="n">_element</span><span class="p">.</span><span class="n">IsHitTestVisible</span><span class="p">)</span>
                <span class="p">{</span> 
                    <span class="n">PresentationSource</span> <span class="n">presentationSource</span> <span class="p">=</span> <span class="n">PresentationSource</span><span class="p">.</span><span class="nf">CriticalFromVisual</span><span class="p">(</span><span class="n">_element</span> <span class="k">as</span> <span class="n">Visual</span><span class="p">);</span>
  
                    <span class="k">if</span> <span class="p">(</span><span class="n">presentationSource</span> <span class="p">!=</span> <span class="k">null</span><span class="p">)</span> 
                    <span class="p">{</span>
                        <span class="n">unhookPenContexts</span> <span class="p">=</span> <span class="k">false</span><span class="p">;</span> 
 
                        <span class="c1">// Are we currently hooked up?  If not then hook up.</span>
                        <span class="k">if</span> <span class="p">(</span><span class="n">_penContexts</span> <span class="p">==</span> <span class="k">null</span><span class="p">)</span>
                        <span class="p">{</span> 
                            <span class="n">InputManager</span> <span class="n">inputManager</span> <span class="p">=</span> <span class="p">(</span><span class="n">InputManager</span><span class="p">)</span><span class="n">_element</span><span class="p">.</span><span class="n">Dispatcher</span><span class="p">.</span><span class="n">InputManager</span><span class="p">;</span>
                            <span class="n">PenContexts</span> <span class="n">penContexts</span> <span class="p">=</span> <span class="n">inputManager</span><span class="p">.</span><span class="n">StylusLogic</span><span class="p">.</span><span class="nf">GetPenContextsFromHwnd</span><span class="p">(</span><span class="n">presentationSource</span><span class="p">);</span> 
  
                            <span class="c1">// _penContexts must be non null or don't do anything.</span>
                            <span class="k">if</span> <span class="p">(</span><span class="n">penContexts</span> <span class="p">!=</span> <span class="k">null</span><span class="p">)</span> 
                            <span class="p">{</span>
                                <span class="n">_penContexts</span> <span class="p">=</span> <span class="n">penContexts</span><span class="p">;</span>
 
                                <span class="k">lock</span><span class="p">(</span><span class="n">penContexts</span><span class="p">.</span><span class="n">SyncRoot</span><span class="p">)</span> 
                                <span class="p">{</span>
                                    <span class="n">penContexts</span><span class="p">.</span><span class="nf">AddStylusPlugInCollection</span><span class="p">(</span><span class="k">this</span><span class="p">);</span> 
  
                                    <span class="k">foreach</span> <span class="p">(</span><span class="n">StylusPlugIn</span> <span class="n">spi</span> <span class="k">in</span> <span class="k">this</span><span class="p">)</span>
                                    <span class="p">{</span> 
                                        <span class="n">spi</span><span class="p">.</span><span class="nf">InvalidateIsActiveForInput</span><span class="p">();</span> <span class="c1">// Uses _penContexts being set to determine active state.</span>
 
                                    <span class="p">}</span>
                                    <span class="c1">// NTRAID:WINDOWSOS#1677277-2006/06/05-WAYNEZEN, </span>
                                    <span class="c1">// Normally the Rect will be updated when we receive the LayoutUpdate.</span>
                                    <span class="c1">// However there could be a race condition which the LayoutUpdate gets received </span>
                                    <span class="c1">// before the properties like IsVisible being set. </span>
                                    <span class="c1">// So we should always force to call OnLayoutUpdated whenever the input is active.</span>
                                    <span class="nf">OnLayoutUpdated</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="n">EventArgs</span><span class="p">.</span><span class="n">Empty</span><span class="p">);</span> 
                                <span class="p">}</span>
 
                            <span class="p">}</span>
                        <span class="p">}</span> 
                    <span class="p">}</span>
                <span class="p">}</span> 
  
                <span class="k">if</span> <span class="p">(</span><span class="n">unhookPenContexts</span><span class="p">)</span>
                <span class="p">{</span> 
                    <span class="nf">UnhookPenContexts</span><span class="p">();</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span> 
</code></pre></div></div>

<h3 id="stylusplugincollectioninsertitem">StylusPlugInCollection.InsertItem</h3>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="k">public</span> <span class="k">sealed</span> <span class="k">class</span> <span class="nc">StylusPlugInCollection</span> <span class="p">:</span> <span class="n">Collection</span><span class="p">&lt;</span><span class="n">stylusplugin</span><span class="p">&gt;</span>
    <span class="p">{</span> 
        <span class="err">#</span><span class="n">region</span> <span class="n">Protected</span> <span class="n">APIs</span> 
        <span class="c1">/// &lt;summary&gt;</span>
        <span class="c1">/// Insert a StylusPlugIn in the collection at a specific index. </span>
        <span class="c1">/// This method should be called from the application context only</span>
        <span class="c1">/// &lt;/summary&gt;</span>
        <span class="c1">/// &lt;param name="index"&gt;index at which to insert the StylusPlugIn object</span>
        <span class="c1">/// &lt;param name="plugIn"&gt;StylusPlugIn object to insert, downcast to an object </span>
        <span class="k">protected</span> <span class="k">override</span> <span class="k">void</span> <span class="nf">InsertItem</span><span class="p">(</span><span class="kt">int</span> <span class="n">index</span><span class="p">,</span> <span class="n">StylusPlugIn</span> <span class="n">plugIn</span><span class="p">)</span>
        <span class="p">{</span> 
            <span class="c1">// Verify it's called from the app dispatcher </span>
            <span class="n">_element</span><span class="p">.</span><span class="nf">VerifyAccess</span><span class="p">();</span>
  
            <span class="c1">// Validate the input parameter</span>
            <span class="k">if</span> <span class="p">(</span><span class="k">null</span> <span class="p">==</span> <span class="n">plugIn</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="k">throw</span> <span class="k">new</span> <span class="nf">ArgumentNullException</span><span class="p">(</span><span class="s">"plugIn"</span><span class="p">,</span> <span class="n">SR</span><span class="p">.</span><span class="nf">Get</span><span class="p">(</span><span class="n">SRID</span><span class="p">.</span><span class="n">Stylus_PlugInIsNull</span><span class="p">));</span> 
            <span class="p">}</span>
  
            <span class="k">if</span> <span class="p">(</span><span class="nf">IndexOf</span><span class="p">(</span><span class="n">plugIn</span><span class="p">)</span> <span class="p">!=</span> <span class="p">-</span><span class="m">1</span><span class="p">)</span> 
            <span class="p">{</span>
                <span class="k">throw</span> <span class="k">new</span> <span class="nf">ArgumentException</span><span class="p">(</span><span class="n">SR</span><span class="p">.</span><span class="nf">Get</span><span class="p">(</span><span class="n">SRID</span><span class="p">.</span><span class="n">Stylus_PlugInIsDuplicated</span><span class="p">),</span> <span class="s">"plugIn"</span><span class="p">);</span> 
            <span class="p">}</span>
 
            <span class="c1">// Disable processing of the queue during blocking operations to prevent unrelated reentrancy</span>
            <span class="c1">// which a call to Lock() can cause. </span>
            <span class="k">using</span> <span class="p">(</span><span class="n">_element</span><span class="p">.</span><span class="n">Dispatcher</span><span class="p">.</span><span class="nf">DisableProcessing</span><span class="p">())</span>
            <span class="p">{</span> 
                <span class="k">if</span> <span class="p">(</span><span class="n">IsActiveForInput</span><span class="p">)</span> 
                <span class="p">{</span>
                    <span class="c1">// If we are currently active for input then we have a _penContexts that we must lock! </span>
                    <span class="k">lock</span><span class="p">(</span><span class="n">PenContextsSyncRoot</span><span class="p">)</span>
                    <span class="p">{</span>
                        <span class="n">System</span><span class="p">.</span><span class="n">Diagnostics</span><span class="p">.</span><span class="n">Debug</span><span class="p">.</span><span class="nf">Assert</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="n">Count</span> <span class="p">&gt;</span> <span class="m">0</span><span class="p">);</span> <span class="c1">// If active must have more than one plugin already</span>
                        <span class="k">base</span><span class="p">.</span><span class="nf">InsertItem</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">plugIn</span><span class="p">);</span> 
                        <span class="n">plugIn</span><span class="p">.</span><span class="nf">Added</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>
                    <span class="p">}</span> 
                <span class="p">}</span> 
                <span class="k">else</span>
                <span class="p">{</span> 
                    <span class="nf">EnsureEventsHooked</span><span class="p">();</span> <span class="c1">// Hook up events to track changes to the plugin's element</span>
                    <span class="k">base</span><span class="p">.</span><span class="nf">InsertItem</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">plugIn</span><span class="p">);</span>
                    <span class="k">try</span>
                    <span class="p">{</span> 
                        <span class="n">plugIn</span><span class="p">.</span><span class="nf">Added</span><span class="p">(</span><span class="k">this</span><span class="p">);</span> <span class="c1">// Notify plugin that it has been added to collection</span>
                    <span class="p">}</span> 
                    <span class="k">finally</span>
                    <span class="p">{</span>
                        <span class="nf">UpdatePenContextsState</span><span class="p">();</span> <span class="c1">// Add to PenContexts if element is in proper state (can fire isactiveforinput). </span>
                    <span class="p">}</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span> 
    <span class="p">}</span>
</code></pre></div></div>

<h3 id="wispstylusplugincollectionupdatestate">WispStylusPlugInCollection.UpdateState</h3>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>		<span class="k">internal</span> <span class="k">override</span> <span class="k">void</span> <span class="nf">UpdateState</span><span class="p">(</span><span class="n">UIElement</span> <span class="n">element</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="kt">bool</span> <span class="n">flag</span> <span class="p">=</span> <span class="k">true</span><span class="p">;</span>
			<span class="k">using</span> <span class="p">(</span><span class="n">element</span><span class="p">.</span><span class="n">Dispatcher</span><span class="p">.</span><span class="nf">DisableProcessing</span><span class="p">())</span>
			<span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">element</span><span class="p">.</span><span class="n">IsVisible</span> <span class="p">&amp;&amp;</span> <span class="n">element</span><span class="p">.</span><span class="n">IsEnabled</span> <span class="p">&amp;&amp;</span> <span class="n">element</span><span class="p">.</span><span class="n">IsHitTestVisible</span><span class="p">)</span>
				<span class="p">{</span>
					<span class="n">PresentationSource</span> <span class="n">presentationSource</span> <span class="p">=</span> <span class="n">PresentationSource</span><span class="p">.</span><span class="nf">CriticalFromVisual</span><span class="p">(</span><span class="n">element</span><span class="p">);</span>
					<span class="k">if</span> <span class="p">(</span><span class="n">presentationSource</span> <span class="p">!=</span> <span class="k">null</span><span class="p">)</span>
					<span class="p">{</span>
						<span class="n">flag</span> <span class="p">=</span> <span class="k">false</span><span class="p">;</span>
						<span class="k">if</span> <span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="n">_penContexts</span> <span class="p">==</span> <span class="k">null</span><span class="p">)</span>
						<span class="p">{</span>
							<span class="n">InputManager</span> <span class="n">inputManager</span> <span class="p">=</span> <span class="p">(</span><span class="n">InputManager</span><span class="p">)</span><span class="n">element</span><span class="p">.</span><span class="n">Dispatcher</span><span class="p">.</span><span class="n">InputManager</span><span class="p">;</span>
							<span class="n">PenContexts</span> <span class="n">penContextsFromHwnd</span> <span class="p">=</span> <span class="n">StylusLogic</span><span class="p">.</span><span class="n">GetCurrentStylusLogicAs</span><span class="p">&lt;</span><span class="n">WispLogic</span><span class="p">&gt;().</span><span class="nf">GetPenContextsFromHwnd</span><span class="p">(</span><span class="n">presentationSource</span><span class="p">);</span>
							<span class="k">if</span> <span class="p">(</span><span class="n">penContextsFromHwnd</span> <span class="p">!=</span> <span class="k">null</span><span class="p">)</span>
							<span class="p">{</span>
								<span class="k">this</span><span class="p">.</span><span class="n">_penContexts</span> <span class="p">=</span> <span class="n">penContextsFromHwnd</span><span class="p">;</span>
								<span class="kt">object</span> <span class="n">syncRoot</span> <span class="p">=</span> <span class="n">penContextsFromHwnd</span><span class="p">.</span><span class="n">SyncRoot</span><span class="p">;</span>
								<span class="k">lock</span> <span class="p">(</span><span class="n">syncRoot</span><span class="p">)</span>
								<span class="p">{</span>
									<span class="n">penContextsFromHwnd</span><span class="p">.</span><span class="nf">AddStylusPlugInCollection</span><span class="p">(</span><span class="k">base</span><span class="p">.</span><span class="n">Wrapper</span><span class="p">);</span>
									<span class="k">foreach</span> <span class="p">(</span><span class="n">StylusPlugIn</span> <span class="n">stylusPlugIn</span> <span class="k">in</span> <span class="k">base</span><span class="p">.</span><span class="n">Wrapper</span><span class="p">)</span>
									<span class="p">{</span>
										<span class="n">stylusPlugIn</span><span class="p">.</span><span class="nf">InvalidateIsActiveForInput</span><span class="p">();</span>
									<span class="p">}</span>
									<span class="k">base</span><span class="p">.</span><span class="n">Wrapper</span><span class="p">.</span><span class="nf">OnLayoutUpdated</span><span class="p">(</span><span class="k">base</span><span class="p">.</span><span class="n">Wrapper</span><span class="p">,</span> <span class="n">EventArgs</span><span class="p">.</span><span class="n">Empty</span><span class="p">);</span>
								<span class="p">}</span>
							<span class="p">}</span>
						<span class="p">}</span>
					<span class="p">}</span>
				<span class="p">}</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">flag</span><span class="p">)</span>
				<span class="p">{</span>
					<span class="k">this</span><span class="p">.</span><span class="nf">Unhook</span><span class="p">();</span>
				<span class="p">}</span>
			<span class="p">}</span>
		<span class="p">}</span>
</code></pre></div></div>

<h3 id="pointerstylusplugincollectionupdatestate">PointerStylusPlugInCollection.UpdateState</h3>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>		<span class="k">internal</span> <span class="k">override</span> <span class="k">void</span> <span class="nf">UpdateState</span><span class="p">(</span><span class="n">UIElement</span> <span class="n">element</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="kt">bool</span> <span class="n">flag</span> <span class="p">=</span> <span class="k">true</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">element</span><span class="p">.</span><span class="n">IsVisible</span> <span class="p">&amp;&amp;</span> <span class="n">element</span><span class="p">.</span><span class="n">IsEnabled</span> <span class="p">&amp;&amp;</span> <span class="n">element</span><span class="p">.</span><span class="n">IsHitTestVisible</span><span class="p">)</span>
			<span class="p">{</span>
				<span class="n">PresentationSource</span> <span class="n">presentationSource</span> <span class="p">=</span> <span class="n">PresentationSource</span><span class="p">.</span><span class="nf">CriticalFromVisual</span><span class="p">(</span><span class="n">element</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">presentationSource</span> <span class="p">!=</span> <span class="k">null</span><span class="p">)</span>
				<span class="p">{</span>
					<span class="n">flag</span> <span class="p">=</span> <span class="k">false</span><span class="p">;</span>
					<span class="k">if</span> <span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="n">_manager</span> <span class="p">==</span> <span class="k">null</span><span class="p">)</span>
					<span class="p">{</span>
						<span class="k">this</span><span class="p">.</span><span class="n">_manager</span> <span class="p">=</span> <span class="n">StylusLogic</span><span class="p">.</span><span class="n">GetCurrentStylusLogicAs</span><span class="p">&lt;</span><span class="n">PointerLogic</span><span class="p">&gt;().</span><span class="n">PlugInManagers</span><span class="p">[</span><span class="n">presentationSource</span><span class="p">];</span>
						<span class="k">if</span> <span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="n">_manager</span> <span class="p">!=</span> <span class="k">null</span><span class="p">)</span>
						<span class="p">{</span>
							<span class="k">this</span><span class="p">.</span><span class="n">_manager</span><span class="p">.</span><span class="nf">AddStylusPlugInCollection</span><span class="p">(</span><span class="k">base</span><span class="p">.</span><span class="n">Wrapper</span><span class="p">);</span>
							<span class="k">foreach</span> <span class="p">(</span><span class="n">StylusPlugIn</span> <span class="n">stylusPlugIn</span> <span class="k">in</span> <span class="k">base</span><span class="p">.</span><span class="n">Wrapper</span><span class="p">)</span>
							<span class="p">{</span>
								<span class="n">stylusPlugIn</span><span class="p">.</span><span class="nf">InvalidateIsActiveForInput</span><span class="p">();</span>
							<span class="p">}</span>
							<span class="k">base</span><span class="p">.</span><span class="n">Wrapper</span><span class="p">.</span><span class="nf">OnLayoutUpdated</span><span class="p">(</span><span class="k">base</span><span class="p">.</span><span class="n">Wrapper</span><span class="p">,</span> <span class="n">EventArgs</span><span class="p">.</span><span class="n">Empty</span><span class="p">);</span>
						<span class="p">}</span>
					<span class="p">}</span>
				<span class="p">}</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">flag</span><span class="p">)</span>
				<span class="p">{</span>
					<span class="k">this</span><span class="p">.</span><span class="nf">Unhook</span><span class="p">();</span>
				<span class="p">}</span>
			<span class="p">}</span>
		<span class="p">}</span>
</code></pre></div></div>

:ET