I"5t<p>在 WPF 框架提供方便进行像素读写的 WriteableBitmap 类，本文来告诉大家在咱写下像素到 WriteableBitmap 渲染，底层的逻辑</p>

<!--more-->

<!-- CreateTime:2021/4/19 8:38:27 -->

<!-- 标签：WPF，WPF源代码 -->
<!-- 发布 -->

<p>之前我使用 WriteableBitmap 进行 CPU 高性能绘图时，在性能调试遇到一个问题，写入到 WriteableBitmap 的像素会经过两次拷贝。其中一次是我自己拷贝到 WriteableBitmap 而另一次拷贝就在 WriteableBitmap 里面。无论设置 WriteableBitmap 的脏区多大，渲染的时候是整个图片渲染 。本来按照我的阅读顺序，当前还没有阅读到 WriteableBitmap 的代码，但是有小伙伴和我报告了 WriteableBitmap 的坑，因此我就开始阅读 WriteableBitmap 详细请看 <a href="https://blog.lindexi.com/post/dotnet-%E8%AF%BB-WPF-%E6%BA%90%E4%BB%A3%E7%A0%81%E7%AC%94%E8%AE%B0-%E4%BA%86%E8%A7%A3-WPF-%E5%B7%B2%E7%9F%A5%E9%97%AE%E9%A2%98-%E5%90%8E%E5%8F%B0%E7%BA%BF%E7%A8%8B%E5%88%9B%E5%BB%BA-WriteableBitmap-%E9%94%81%E4%BD%8F%E4%B8%BB%E7%BA%BF%E7%A8%8B.html">dotnet 读 WPF 源代码笔记 了解 WPF 已知问题 后台线程创建 WriteableBitmap 锁住主线程</a></p>

<p>在开始之前，先聊聊 WriteableBitmap 是什么？在 WPF 和 UWP 中提供的 WriteableBitmap 是支持对像素写入而更改渲染的图片，当然，本文只聊 WPF 的源代码，关于 UWP 部分，咱只知道使用就可以。通过 WriteableBitmap 可以用来实现高性能的 CPU 渲染，以下是我的其他 WriteableBitmap 博客</p>

<ul>
  <li><a href="https://blog.lindexi.com/post/WPF-%E4%BD%BF%E7%94%A8-Skia-%E7%BB%98%E5%88%B6-WriteableBitmap-%E5%9B%BE%E7%89%87.html">WPF 使用 Skia 绘制 WriteableBitmap 图片</a></li>
  <li><a href="https://blog.lindexi.com/post/WPF-%E5%A6%82%E4%BD%95%E5%9C%A8-WriteableBitmap-%E5%86%99%E6%96%87%E5%AD%97.html">WPF 如何在 WriteableBitmap 写文字</a></li>
  <li><a href="https://blog.lindexi.com/post/WPF-%E4%BD%BF%E7%94%A8%E4%B8%8D%E5%AE%89%E5%85%A8%E4%BB%A3%E7%A0%81%E5%BF%AB%E9%80%9F%E4%BB%8E%E6%95%B0%E7%BB%84%E8%BD%AC-WriteableBitmap.html">WPF 使用不安全代码快速从数组转 WriteableBitmap</a></li>
</ul>

<p>在 WriteableBitmap 进行绘制时，有一个重要的功能是设置 DirtyRect 来告诉 WPF 层，当前需要更新的是 WriteableBitmap 的哪个内容。在调试时，可以看到如果 DirtyRect 很小，那么 CPU 占用也将会很小，但渲染时依然是渲染整个图片。在聊到 WriteableBitmap 的渲染和更新，就一定需要先聊到 AddDirtyRect 方法，下面咱看一下 AddDirtyRect 方法的实现</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        <span class="k">public</span> <span class="k">void</span> <span class="nf">AddDirtyRect</span><span class="p">(</span><span class="n">Int32Rect</span> <span class="n">dirtyRect</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="nf">WritePreamble</span><span class="p">();</span>

            <span class="k">if</span> <span class="p">(</span><span class="n">_lockCount</span> <span class="p">==</span> <span class="m">0</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="k">throw</span> <span class="k">new</span> <span class="nf">InvalidOperationException</span><span class="p">(</span><span class="n">SR</span><span class="p">.</span><span class="nf">Get</span><span class="p">(</span><span class="n">SRID</span><span class="p">.</span><span class="n">Image_MustBeLocked</span><span class="p">));</span>
            <span class="p">}</span>

            <span class="c1">//</span>
            <span class="c1">// Sanitize the dirty rect.</span>
            <span class="c1">//</span>
            <span class="n">dirtyRect</span><span class="p">.</span><span class="nf">ValidateForDirtyRect</span><span class="p">(</span><span class="s">"dirtyRect"</span><span class="p">,</span> <span class="n">_pixelWidth</span><span class="p">,</span> <span class="n">_pixelHeight</span><span class="p">);</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">dirtyRect</span><span class="p">.</span><span class="n">HasArea</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="n">MILSwDoubleBufferedBitmap</span><span class="p">.</span><span class="nf">AddDirtyRect</span><span class="p">(</span>
                    <span class="n">_pDoubleBufferedBitmap</span><span class="p">,</span>
                    <span class="k">ref</span> <span class="n">dirtyRect</span><span class="p">);</span>

                <span class="n">_hasDirtyRects</span> <span class="p">=</span> <span class="k">true</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="c1">// Note: we do not call WritePostscript because we do not want to</span>
            <span class="c1">// raise change notifications until the writeable bitmap is unlocked.</span>
        <span class="p">}</span>
</code></pre></div></div>

<p>调用 AddDirtyRect 基本都会在 Lock 和 Unlock 方法里面，但无论是 Lock 还是 Unlock 和渲染触发其实都没有关系，咱继续回到 AddDirtyRect 方法。在这个方法里面实际的调用就是 MILSwDoubleBufferedBitmap.AddDirtyRect 方法，这是一个从 MIL 层拿到的方法</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        <span class="p">[</span><span class="nf">DllImport</span><span class="p">(</span><span class="n">DllImport</span><span class="p">.</span><span class="n">MilCore</span><span class="p">,</span> <span class="n">EntryPoint</span> <span class="p">=</span> <span class="s">"MILSwDoubleBufferedBitmapAddDirtyRect"</span><span class="p">,</span> <span class="n">PreserveSig</span> <span class="p">=</span> <span class="k">false</span><span class="p">)]</span>
        <span class="k">internal</span> <span class="k">static</span> <span class="k">extern</span> <span class="k">void</span> <span class="nf">AddDirtyRect</span><span class="p">(</span>
            <span class="n">SafeMILHandle</span> <span class="cm">/* CSwDoubleBufferedBitmap */</span> <span class="n">THIS_PTR</span><span class="p">,</span>
            <span class="k">ref</span> <span class="n">Int32Rect</span> <span class="n">dirtyRect</span>
            <span class="p">);</span>
</code></pre></div></div>

<p>从上面的注释可以看到，这里的 SafeMILHandle 的 <code class="language-plaintext highlighter-rouge">THIS_PTR</code> 就是 CSwDoubleBufferedBitmap 类型，这个类型定义在 MIL 层，代码在 <code class="language-plaintext highlighter-rouge">src\Microsoft.DotNet.Wpf\src\WpfGfx\core\sw\swlib\doublebufferedbitmap.cpp</code> 文件。通过上面代码可以看到，就是定义在字段的 <code class="language-plaintext highlighter-rouge">_pDoubleBufferedBitmap</code> 字段</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        <span class="k">private</span> <span class="n">SafeMILHandle</span> <span class="n">_pDoubleBufferedBitmap</span><span class="p">;</span>   <span class="c1">// CSwDoubleBufferedBitmap</span>
</code></pre></div></div>

<p>先忽略 <code class="language-plaintext highlighter-rouge">_pDoubleBufferedBitmap</code> 的创建，咱进入 MILSwDoubleBufferedBitmapAddDirtyRect 方法的实现。这是定义在 exports.cpp 的方法</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">HRESULT</span>
<span class="nf">MILSwDoubleBufferedBitmapAddDirtyRect</span><span class="p">(</span>
    <span class="n">__in</span> <span class="n">CSwDoubleBufferedBitmap</span> <span class="o">*</span> <span class="n">THIS_PTR</span><span class="p">,</span>
    <span class="n">__in</span> <span class="k">const</span> <span class="n">MILRect</span> <span class="o">*</span><span class="n">pRect</span>
    <span class="p">)</span>
<span class="p">{</span>
    <span class="n">HRESULT</span> <span class="n">hr</span> <span class="o">=</span> <span class="n">S_OK</span><span class="p">;</span>
    <span class="n">UINT</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">UINT</span> <span class="n">y</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">UINT</span> <span class="n">width</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">UINT</span> <span class="n">height</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">CMilRectU</span> <span class="n">rcDirty</span><span class="p">;</span>

    <span class="n">CHECKPTR</span><span class="p">(</span><span class="n">THIS_PTR</span><span class="p">);</span>
    <span class="n">CHECKPTR</span><span class="p">(</span><span class="n">pRect</span><span class="p">);</span>

    <span class="n">IFC</span><span class="p">(</span><span class="n">IntToUInt</span><span class="p">(</span><span class="n">pRect</span><span class="o">-&gt;</span><span class="n">X</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">x</span><span class="p">));</span>
    <span class="n">IFC</span><span class="p">(</span><span class="n">IntToUInt</span><span class="p">(</span><span class="n">pRect</span><span class="o">-&gt;</span><span class="n">Y</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">y</span><span class="p">));</span>
    <span class="n">IFC</span><span class="p">(</span><span class="n">IntToUInt</span><span class="p">(</span><span class="n">pRect</span><span class="o">-&gt;</span><span class="n">Width</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">width</span><span class="p">));</span>
    <span class="n">IFC</span><span class="p">(</span><span class="n">IntToUInt</span><span class="p">(</span><span class="n">pRect</span><span class="o">-&gt;</span><span class="n">Height</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">height</span><span class="p">));</span>

    <span class="c1">// Since we converted x, y, width, and height from ints, we can add them</span>
    <span class="c1">// together and remain within a UINT.</span>
    <span class="n">rcDirty</span> <span class="o">=</span> <span class="n">CMilRectU</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">,</span> <span class="n">XYWH_Parameters</span><span class="p">);</span>

    <span class="n">IFC</span><span class="p">(</span><span class="n">THIS_PTR</span><span class="o">-&gt;</span><span class="n">AddDirtyRect</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rcDirty</span><span class="p">));</span>

<span class="nl">Cleanup:</span>

    <span class="n">RRETURN</span><span class="p">(</span><span class="n">hr</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>这里的逻辑是在 MIL 层了，这一层就是实际处理多媒体的逻辑，可以看到上面代码核心的方法就是 <code class="language-plaintext highlighter-rouge">THIS_PTR-&gt;AddDirtyRect(&amp;rcDirty)</code> 调用 CSwDoubleBufferedBitmap 的 AddDirtyRect 方法。在 AddDirtyRect 方法里面实际上就是维护一个去掉重复范围的 Rect 列表而已，只是因为用了 C++ 编写，代码看起来有点杂</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">HRESULT</span>
<span class="n">CSwDoubleBufferedBitmap</span><span class="p">::</span><span class="nf">AddDirtyRect</span><span class="p">(</span><span class="n">__in</span> <span class="k">const</span> <span class="n">CMilRectU</span> <span class="p">*</span><span class="n">prcDirty</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">HRESULT</span> <span class="n">hr</span> <span class="p">=</span> <span class="n">S_OK</span><span class="p">;</span>
    <span class="n">CMilRectU</span> <span class="nf">rcBounds</span><span class="p">(</span><span class="m">0</span><span class="p">,</span> <span class="m">0</span><span class="p">,</span> <span class="n">m_width</span><span class="p">,</span> <span class="n">m_height</span><span class="p">,</span> <span class="n">XYWH_Parameters</span><span class="p">);</span>
    <span class="n">CMilRectU</span> <span class="n">rcDirty</span> <span class="p">=</span> <span class="p">*</span><span class="n">prcDirty</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(!</span><span class="n">rcDirty</span><span class="p">.</span><span class="nf">IsEmpty</span><span class="p">())</span>
    <span class="p">{</span>
        <span class="c1">// Each dirty rect will eventually be treated as a RECT, so we must</span>
        <span class="c1">// ensure that the Left, Right, Top, and Bottom values never exceed</span>
        <span class="c1">// INT_MAX.  We already restrict our dimensions to INT_MAX, so as</span>
        <span class="c1">// long as the dirty rect is fully within the bounds of the bitmap,</span>
        <span class="c1">// we are safe.</span>
        <span class="k">if</span> <span class="p">(!</span><span class="n">rcBounds</span><span class="p">.</span><span class="nf">DoesContain</span><span class="p">(</span><span class="n">rcDirty</span><span class="p">))</span>
        <span class="p">{</span>
            <span class="nf">IFC</span><span class="p">(</span><span class="n">E_INVALIDARG</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="c1">// Adding a dirty rect that spans the entire bitmap will simply</span>
        <span class="c1">// replace all existing dirty rects.</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">rcDirty</span><span class="p">.</span><span class="nf">IsEquivalentTo</span><span class="p">(</span><span class="n">rcBounds</span><span class="p">))</span>
        <span class="p">{</span>
            <span class="n">m_pDirtyRects</span><span class="p">[</span><span class="m">0</span><span class="p">]</span> <span class="p">=</span> <span class="n">rcBounds</span><span class="p">;</span>
            <span class="n">m_numDirtyRects</span> <span class="p">=</span> <span class="m">1</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">else</span>
        <span class="p">{</span>
            <span class="c1">// Check to see if one of the existing dirty rects fully contains the</span>
            <span class="c1">// new dirty rect.  If so, there is no need to add it.</span>
            <span class="k">for</span> <span class="p">(</span><span class="n">UINT</span> <span class="n">i</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="p">&lt;</span> <span class="n">m_numDirtyRects</span><span class="p">;</span> <span class="n">i</span><span class="p">++)</span>
            <span class="p">{</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">m_pDirtyRects</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="nf">DoesContain</span><span class="p">(</span><span class="n">rcDirty</span><span class="p">))</span>
                <span class="p">{</span>
                    <span class="c1">// No dirty list change - new dirty rect is already included.</span>
                    <span class="k">goto</span> <span class="n">Cleanup</span><span class="p">;</span>
                <span class="p">}</span>
            <span class="p">}</span>

            <span class="c1">// Collapse existing dirty rects if we're about to exceed our maximum.</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">m_numDirtyRects</span> <span class="p">&gt;=</span> <span class="n">c_maxBitmapDirtyListSize</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="c1">// Collapse dirty list to a single large rect (including new rect)</span>
                <span class="k">while</span> <span class="p">(</span><span class="n">m_numDirtyRects</span> <span class="p">&gt;</span> <span class="m">1</span><span class="p">)</span>
                <span class="p">{</span>
                    <span class="n">m_pDirtyRects</span><span class="p">[</span><span class="m">0</span><span class="p">].</span><span class="nf">Union</span><span class="p">(</span><span class="n">m_pDirtyRects</span><span class="p">[--</span><span class="n">m_numDirtyRects</span><span class="p">]);</span>
                <span class="p">}</span>
                <span class="n">m_pDirtyRects</span><span class="p">[</span><span class="m">0</span><span class="p">].</span><span class="nf">Union</span><span class="p">(</span><span class="n">rcDirty</span><span class="p">);</span>

                <span class="nf">Assert</span><span class="p">(</span><span class="n">m_numDirtyRects</span> <span class="p">==</span> <span class="m">1</span><span class="p">);</span>
            <span class="p">}</span>
            <span class="k">else</span>
            <span class="p">{</span>
                <span class="n">m_pDirtyRects</span><span class="p">[</span><span class="n">m_numDirtyRects</span><span class="p">++]</span> <span class="p">=</span> <span class="n">rcDirty</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>

<span class="n">Cleanup</span><span class="p">:</span>

    <span class="nf">RRETURN</span><span class="p">(</span><span class="n">hr</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>上面代码是将传入的参数，合入到 m_pDirtyRects 字段里面</p>

<p>可以看到在调用咱的 AddDirtyRect 方法时，其实就是更新 CSwDoubleBufferedBitmap 的 m_pDirtyRects 字段而已，而此时依然没有做渲染相关逻辑。从 <code class="language-plaintext highlighter-rouge">CSwDoubleBufferedBitmap</code> 这个命名可以看到，这是双缓存的做法。两个缓存，前面的缓存是用在实际显示的对象，后面的缓存是用的是一个数组用于给 WPF 上层使用访问</p>

<p>在 WPF 的渲染过程中，按照 DirectX 应用的渲染步骤，第一步就是收集过程，在收集过程中收集绘制信息。收集过程中将会调用到 CSwDoubleBufferedBitmap 的 CopyForwardDirtyRects 方法，这个方法的作用就是根据脏区从后面的缓存将像素复制到前面的缓存。虽然这个类的命名是双缓存，但实际上的做法不是在渲染的时候交换两个缓存的指针，而是在渲染收集过程中，从后面的缓存拷贝数据到前面的缓存</p>

<p>以下是 CopyForwardDirtyRects 方法的代码，我在代码里面添加了一些注释</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">HRESULT</span>
<span class="n">CSwDoubleBufferedBitmap</span><span class="o">::</span><span class="n">CopyForwardDirtyRects</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">HRESULT</span> <span class="n">hr</span> <span class="o">=</span> <span class="n">S_OK</span><span class="p">;</span>

    <span class="n">IWGXBitmapSource</span> <span class="o">*</span><span class="n">pIWGXBitmapSource</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="n">IWGXBitmapLock</span> <span class="o">*</span><span class="n">pFrontBufferLock</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="n">UINT</span> <span class="n">cbLockStride</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">UINT</span> <span class="n">cbBufferSize</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">BYTE</span> <span class="o">*</span><span class="n">pbSurface</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

    <span class="n">Assert</span><span class="p">(</span><span class="n">m_pBackBuffer</span><span class="p">);</span>

    <span class="c1">// 根据调用 AddDirtyRect 方法加入的 DirtyRect 获取当前有哪些需要拷贝的像素</span>
    <span class="c1">// This locks only the rect specified as dirty for each copy. It would</span>
    <span class="c1">// be more efficient to just lock the entire rect once for all of the</span>
    <span class="c1">// copies, but then we need to manually compute offsets into the front</span>
    <span class="c1">// buffer specific to each pixel format.</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">m_numDirtyRects</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="c1">// We have to jump through a few RECT hoops here since</span>
        <span class="c1">// IWGXBitmapSource::Lock/CopyPixels take a WICRect and</span>
        <span class="c1">// IWGXBitmap::AddDirtyRect takes a GDI RECT, neither of which are</span>
        <span class="c1">// CMilRectU which we use in CSwDoubleBufferedBitmap for geometric operations.</span>
        <span class="c1">//</span>
        <span class="c1">// CMilRectU and RECT share the same memory alignment, but different</span>
        <span class="c1">// signs.  Since we restrict the size of our bitmap to MAX_INT, we can</span>
        <span class="c1">// safely cast.</span>
        <span class="c1">// 这里只是做一层转换而已，拿到当前的一个 DirtyRect 范围</span>
        <span class="k">const</span> <span class="n">RECT</span> <span class="o">*</span><span class="n">rcDirty</span> <span class="o">=</span> <span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="n">RECT</span> <span class="k">const</span> <span class="o">*&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m_pDirtyRects</span><span class="p">[</span><span class="o">--</span><span class="n">m_numDirtyRects</span><span class="p">]);</span>
        <span class="n">WICRect</span> <span class="n">copyRegion</span> <span class="o">=</span> <span class="p">{</span>
            <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">rcDirty</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">),</span>
            <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">rcDirty</span><span class="o">-&gt;</span><span class="n">top</span><span class="p">),</span>
            <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">rcDirty</span><span class="o">-&gt;</span><span class="n">right</span> <span class="o">-</span> <span class="n">rcDirty</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">),</span>
            <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">rcDirty</span><span class="o">-&gt;</span><span class="n">bottom</span> <span class="o">-</span> <span class="n">rcDirty</span><span class="o">-&gt;</span><span class="n">top</span><span class="p">)</span>
            <span class="p">};</span>

        <span class="c1">// 根据 IWICBitmapSource 的使用文档，在使用之前需要先加上锁</span>
        <span class="c1">// This adds copyRegion as a dirty rect to m_pFrontBuffer automatically.</span>
        <span class="n">IFC</span><span class="p">(</span><span class="n">m_pFrontBuffer</span><span class="o">-&gt;</span><span class="n">Lock</span><span class="p">(</span>
            <span class="o">&amp;</span><span class="n">copyRegion</span><span class="p">,</span>
            <span class="n">MilBitmapLock</span><span class="o">::</span><span class="n">Write</span><span class="p">,</span>
            <span class="o">&amp;</span><span class="n">pFrontBufferLock</span>
            <span class="p">));</span>

        <span class="n">IFC</span><span class="p">(</span><span class="n">pFrontBufferLock</span><span class="o">-&gt;</span><span class="n">GetStride</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cbLockStride</span><span class="p">));</span>
        <span class="n">IFC</span><span class="p">(</span><span class="n">pFrontBufferLock</span><span class="o">-&gt;</span><span class="n">GetDataPointer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cbBufferSize</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pbSurface</span><span class="p">));</span>

        <span class="c1">// If a format converter has been allocated, it is necessary that we call copy</span>
        <span class="c1">// pixels through it rather than directly from the back buffer since its very</span>
        <span class="c1">// existence implies that a conversion is needed.</span>
        <span class="n">GetPossiblyFormatConvertedBackBuffer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pIWGXBitmapSource</span><span class="p">);</span>

        <span class="c1">// 这里的 IFC 是一个宏，表示的是如果返回值是 gg 的，那么 goto 到 Cleanup 标签</span>
        <span class="cm">/*
        * #ifndef IFC
          #define IFC(x) { hr = (x); if (FAILED(hr)) goto Cleanup; }
          #endif
        */</span>
        <span class="c1">// 下面代码就是核心逻辑，通过 CopyPixels 方法从后面的缓存也就是 WPF 层的数据拷贝到前面的缓存用于显示</span>
        <span class="c1">// 在这一层里面其实就丢失了 DirtyRect 信息</span>
        <span class="n">IFC</span><span class="p">(</span><span class="n">pIWGXBitmapSource</span><span class="o">-&gt;</span><span class="n">CopyPixels</span><span class="p">(</span>
            <span class="o">&amp;</span><span class="n">copyRegion</span><span class="p">,</span>
            <span class="n">cbLockStride</span><span class="p">,</span>
            <span class="n">cbBufferSize</span><span class="p">,</span>
            <span class="n">pbSurface</span>
            <span class="p">));</span>

        <span class="c1">// 释放掉锁</span>
        <span class="c1">// We need to release the lock and format converter here because we are in a loop.</span>
        <span class="n">ReleaseInterface</span><span class="p">(</span><span class="n">pIWGXBitmapSource</span><span class="p">);</span>
        <span class="n">ReleaseInterface</span><span class="p">(</span><span class="n">pFrontBufferLock</span><span class="p">);</span>
    <span class="p">}</span>

<span class="nl">Cleanup:</span>
    <span class="n">ReleaseInterfaceNoNULL</span><span class="p">(</span><span class="n">pIWGXBitmapSource</span><span class="p">);</span>
    <span class="n">ReleaseInterfaceNoNULL</span><span class="p">(</span><span class="n">pFrontBufferLock</span><span class="p">);</span>

    <span class="n">RRETURN</span><span class="p">(</span><span class="n">hr</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>从上面代码可以看到，咱在使用 WriteableBitmap 的两次复制的第二次复制就是上面的代码，通过 <code class="language-plaintext highlighter-rouge">pIWGXBitmapSource-&gt;CopyPixels</code> 的过程就会依赖传入的 DirtyRect 决定拷贝的数据量。也就是说通过 DirtyRect 能优化的性能也只是更新前面的缓存用到的拷贝的性能，我没有在官方文档里面找到 CopyPixels 里面还会记录 DirtyRect 的功能，同时也没有在 WPF 自定义渲染管线里面找到只刷新图片某个范围的逻辑，因此可以认为使用 WriteableBitmap 的更新，设置 DirtyRect 只影响第二次复制数据的性能，而不会影响渲染性能，依然是整个图片进行渲染</p>

<p>在拷贝到前面的缓存之后，在 WPF 中是在自定义渲染管线里面将前面的缓存作为纹理绘制到形状上，在 WPF 上，可以将 WriteableBitmap 作为 BitmapSource 放入到不规则形状上，将图片作为纹理绘制到形状上能做到比较通用。关于 WPF 的从图片到渲染的步骤，就需要额外的文档来告诉大家</p>

<p>当前的 WPF 在 <a href="https://github.com/dotnet/wpf">https://github.com/dotnet/wpf</a> 完全开源，使用友好的 MIT 协议，意味着允许任何人任何组织和企业任意处置，包括使用，复制，修改，合并，发表，分发，再授权，或者销售。在仓库里面包含了完全的构建逻辑，只需要本地的网络足够好（因为需要下载一堆构建工具），即可进行本地构建</p>

<p>详细请看 <a href="https://docs.microsoft.com/en-us/windows/win32/api/wincodec/nf-wincodec-iwicbitmapsource-copypixels?WT.mc_id=WD-MVP-5003260">IWICBitmapSource::CopyPixels (wincodec.h) - Win32 apps</a></p>

:ET