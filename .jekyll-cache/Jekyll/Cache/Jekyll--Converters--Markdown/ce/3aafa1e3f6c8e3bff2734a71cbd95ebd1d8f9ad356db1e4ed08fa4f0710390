I"\<p>当前的 WPF 的源代码完全开放，本文将从最底层的 WPF 代码告诉大家为什么设置了 AllowsTransparency 之后性能会变差，以及 WPF 透明的原理</p>

<!--more-->

<!-- CreateTime:2020/10/30 19:28:50 -->

<!-- 标签：WPF，渲染,WPF源代码 -->

<p>特别感谢 <a href="https://blog.sdlsj.net/">少珺</a> 的研究，我只是将他告诉我的内容写出来，告诉大家</p>

<p>本文将会告诉大家 AllowsTransparency 设置为 true 之后，为什么整体渲染性能降低，将会占用更多 CPU 资源。以及在 4k 下使用更多内存的原因</p>

<p>本文代码基于 <a href="https://github.com/dotnet/wpf/">WPF 官方开源仓库</a> 所了解，部分逻辑也许和 .NET Framework 不同版本有出入</p>

<p>在 WPF 的实现窗口透明逻辑中，可以在窗口设置 <code class="language-plaintext highlighter-rouge">AllowsTransparency = true</code> 让窗口设置透明笔刷的时候，可以看到窗口后面的内容。这个特性由 Windows 的底层 <a href="https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-updatelayeredwindow?WT.mc_id=WD-MVP-5003260">UpdateLayeredWindow</a> 提供或 <a href="https://docs.microsoft.com/en-us/previous-versions/windows/desktop/legacy/ms633557(v=vs.85)?WT.mc_id=WD-MVP-5003260">UpdateLayeredWindowIndirect</a> 提供</p>

<p>在 WPF 的窗口渲染底层的 WPF_GFX 库里面的入口是在 d3ddevice.cpp 的 Present 方法，方法签名如下</p>

<!-- &WT.mc_id=WD-MVP-5003260 -->

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">HRESULT</span>
<span class="n">CD3DDeviceLevel1</span><span class="p">::</span><span class="nf">Present</span><span class="p">(</span>
    <span class="nf">__in_ecount</span><span class="p">(</span><span class="m">1</span><span class="p">)</span> <span class="n">CD3DSwapChain</span> <span class="k">const</span> <span class="p">*</span><span class="n">pD3DSwapChain</span><span class="p">,</span>
    <span class="nf">__in_ecount_opt</span><span class="p">(</span><span class="m">1</span><span class="p">)</span> <span class="n">CMILSurfaceRect</span> <span class="k">const</span> <span class="p">*</span><span class="n">prcSource</span><span class="p">,</span>
    <span class="nf">__in_ecount_opt</span><span class="p">(</span><span class="m">1</span><span class="p">)</span> <span class="n">CMILSurfaceRect</span> <span class="k">const</span> <span class="p">*</span><span class="n">prcDest</span><span class="p">,</span>
    <span class="nf">__in_ecount</span><span class="p">(</span><span class="m">1</span><span class="p">)</span> <span class="n">CMILDeviceContext</span> <span class="k">const</span> <span class="p">*</span><span class="n">pMILDC</span><span class="p">,</span>
    <span class="nf">__in_ecount_opt</span><span class="p">(</span><span class="m">1</span><span class="p">)</span> <span class="n">RGNDATA</span> <span class="k">const</span> <span class="p">*</span> <span class="n">pDirtyRegion</span><span class="p">,</span>
    <span class="n">DWORD</span> <span class="n">dwD3DPresentFlags</span>
    <span class="p">)</span>


</code></pre></div></div>

<p>在这个方法里面的核心逻辑是通过 <code class="language-plaintext highlighter-rouge">pMILDC-&gt;PresentWithHAL()</code> 决定是否走 PresentWithD3D 还是走 PresentWithGDI 方法，如下面代码</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="k">if</span> <span class="p">(</span><span class="n">pMILDC</span><span class="p">-&gt;</span><span class="nf">PresentWithHAL</span><span class="p">())</span>
    <span class="p">{</span>
        <span class="nf">PresentWithD3D</span><span class="p">(</span>
            <span class="n">pD3DSwapChain</span><span class="p">-&gt;</span><span class="n">m_pD3DSwapChain</span><span class="p">,</span>
            <span class="n">prcSource</span><span class="p">,</span>
            <span class="n">prcDest</span><span class="p">,</span>
            <span class="n">pMILDC</span><span class="p">,</span>
            <span class="n">pDirtyRegion</span><span class="p">,</span>
            <span class="n">dwD3DPresentFlags</span><span class="p">,</span>
            <span class="p">&amp;</span><span class="n">fPresentProcessed</span>
            <span class="p">);</span>
    <span class="p">}</span>
    <span class="k">else</span>
    <span class="p">{</span>
        <span class="nf">PresentWithGDI</span><span class="p">(</span>
            <span class="n">pD3DSwapChain</span><span class="p">,</span>
            <span class="n">prcSource</span><span class="p">,</span>
            <span class="n">prcDest</span><span class="p">,</span>
            <span class="n">pMILDC</span><span class="p">,</span>
            <span class="n">pDirtyRegion</span><span class="p">,</span>
            <span class="p">&amp;</span><span class="n">fPresentProcessed</span>
            <span class="p">);</span>
    <span class="p">}</span>
</code></pre></div></div>

<p>上面代码中的核心逻辑就是通过 PresentWithD3D 使用 D3D 的方法，或通过 PresentWithGDI 使用 GDI 的方法。有趣的是根据静态代码分析工具人 <a href="https://blog.sdlsj.net/">少珺</a> 的研究，基本都是进入了 PresentWithGDI 方法，也就是实际上进行的是 GDI 渲染。以下代码是 PresentWithGDI 方法签名</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">HRESULT</span>
<span class="n">CD3DDeviceLevel1</span><span class="p">::</span><span class="nf">PresentWithGDI</span><span class="p">(</span>
    <span class="nf">__in_ecount</span><span class="p">(</span><span class="m">1</span><span class="p">)</span> <span class="n">CD3DSwapChain</span> <span class="k">const</span> <span class="p">*</span><span class="n">pD3DSwapChain</span><span class="p">,</span>
    <span class="nf">__in_ecount_opt</span><span class="p">(</span><span class="m">1</span><span class="p">)</span> <span class="n">CMILSurfaceRect</span> <span class="k">const</span> <span class="p">*</span> <span class="n">prcSource</span><span class="p">,</span>
    <span class="nf">__in_ecount_opt</span><span class="p">(</span><span class="m">1</span><span class="p">)</span> <span class="n">CMILSurfaceRect</span> <span class="k">const</span> <span class="p">*</span> <span class="n">prcDest</span><span class="p">,</span>
    <span class="nf">__in_ecount</span><span class="p">(</span><span class="m">1</span><span class="p">)</span> <span class="n">CMILDeviceContext</span> <span class="k">const</span> <span class="p">*</span> <span class="n">pMILDC</span><span class="p">,</span>
    <span class="nf">__in_ecount_opt</span><span class="p">(</span><span class="m">1</span><span class="p">)</span> <span class="n">RGNDATA</span> <span class="k">const</span> <span class="p">*</span> <span class="n">pDirtyRegion</span><span class="p">,</span>
    <span class="nf">__out_ecount</span><span class="p">(</span><span class="m">1</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">*</span><span class="n">pfPresentProcessed</span>
    <span class="p">)</span>
</code></pre></div></div>

<p>在这个函数里面的核心逻辑如下</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="n">HDC</span> <span class="n">hdcBackBuffer</span> <span class="p">=</span> <span class="n">NULL</span><span class="p">;</span>

    <span class="n">CD3DSurface</span> <span class="p">*</span><span class="n">pBackBufferSurface</span> <span class="p">=</span> <span class="n">NULL</span><span class="p">;</span>
    <span class="n">UINT</span> <span class="n">uBufferWidth</span><span class="p">;</span>
    <span class="n">UINT</span> <span class="n">uBufferHeight</span><span class="p">;</span>
    <span class="n">CMilRectU</span> <span class="n">rcSource</span><span class="p">;</span>

    <span class="nf">IFC</span><span class="p">(</span><span class="n">pD3DSwapChain</span><span class="p">-&gt;</span><span class="nf">GetBackBuffer</span><span class="p">(</span>
        <span class="m">0</span><span class="p">,</span>
        <span class="p">&amp;</span><span class="n">pBackBufferSurface</span>
        <span class="p">));</span>

    <span class="n">pBackBufferSurface</span><span class="p">-&gt;</span><span class="nf">GetSurfaceSize</span><span class="p">(</span>
        <span class="p">&amp;</span><span class="n">uBufferWidth</span><span class="p">,</span>
        <span class="p">&amp;</span><span class="n">uBufferHeight</span>
        <span class="p">);</span>

    <span class="c1">// 忽略代码，计算 rcSource 的值</span>

    <span class="nf">IFC</span><span class="p">(</span><span class="n">pD3DSwapChain</span><span class="p">-&gt;</span><span class="nf">GetDC</span><span class="p">(</span>
        <span class="m">0</span><span class="p">,</span>
        <span class="n">rcSource</span><span class="p">,</span>
        <span class="n">OUT</span> <span class="p">&amp;</span><span class="n">hdcBackBuffer</span>
        <span class="p">));</span>

    <span class="k">if</span> <span class="p">((</span><span class="n">pMILDC</span><span class="p">-&gt;</span><span class="nf">GetRTInitializationFlags</span><span class="p">()</span> <span class="p">&amp;</span> <span class="n">MilRTInitialization</span><span class="p">::</span><span class="n">PresentUsingMask</span><span class="p">)</span> <span class="p">==</span> <span class="n">MilRTInitialization</span><span class="p">::</span><span class="n">PresentUsingUpdateLayeredWindow</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">SIZE</span> <span class="n">sz</span> <span class="p">=</span> <span class="p">{</span> <span class="n">uBufferWidth</span><span class="p">,</span> <span class="n">uBufferHeight</span> <span class="p">};</span>
        <span class="n">POINT</span> <span class="n">ptSrc</span> <span class="p">=</span> <span class="p">{</span> <span class="m">0</span><span class="p">,</span> <span class="m">0</span> <span class="p">};</span>
        <span class="n">HWND</span> <span class="n">hWnd</span> <span class="p">=</span> <span class="n">pMILDC</span><span class="p">-&gt;</span><span class="nf">GetHWND</span><span class="p">();</span>

        <span class="n">hr</span> <span class="p">=</span> <span class="nf">UpdateLayeredWindowEx</span><span class="p">(</span>
            <span class="n">hWnd</span><span class="p">,</span>
            <span class="n">NULL</span><span class="p">,</span> <span class="c1">// front buffer</span>
            <span class="p">&amp;</span><span class="n">pMILDC</span><span class="p">-&gt;</span><span class="nf">GetPosition</span><span class="p">(),</span>
            <span class="p">&amp;</span><span class="n">sz</span><span class="p">,</span>
            <span class="n">hdcBackBuffer</span><span class="p">,</span>
            <span class="p">&amp;</span><span class="n">ptSrc</span><span class="p">,</span>
            <span class="n">pMILDC</span><span class="p">-&gt;</span><span class="nf">GetColorKey</span><span class="p">(),</span> <span class="c1">// colorkey</span>
            <span class="p">&amp;</span><span class="n">pMILDC</span><span class="p">-&gt;</span><span class="nf">GetBlendFunction</span><span class="p">(),</span> <span class="c1">// blendfunction</span>
            <span class="n">pMILDC</span><span class="p">-&gt;</span><span class="nf">GetULWFlags</span><span class="p">(),</span> <span class="c1">// flags</span>
            <span class="n">prcSource</span>
            <span class="p">);</span>
       
    <span class="p">}</span>
</code></pre></div></div>

<p>以上代码中的 IFC 只是一个宏而已，还请忽略。通过上面代码，就可以了解到为什么占用内存比较多的一个原因，那就是在内存中重新开辟了一段内存，内存的大小就是窗口的大小。因此可以回答本文的为什么在 4k 下将会占用更多的内存的问题，其实是需要在 4k 下进行全屏的窗口才会占用很多内存，因为在如上代码里面重新申请了一段内存，这个内存大小和窗口大小是关联的</p>

<p>在上面代码中申请的内存的用途是用来从 D3D 拷贝出来，用于后续做 GDI 渲染使用。实际的拷贝逻辑放在 <code class="language-plaintext highlighter-rouge">pD3DSwapChain-&gt;GetDC</code> 方法里面，通过这个方法获取了 hdcBackBuffer 对象。而这个方法的核心逻辑是放在 d3dswapchainwithswdc.cpp 类里面，代码大概如下</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//      Gets a DC that refers to a system memory bitmap.</span>
<span class="c1">//</span>
<span class="c1">//      The system memory bitmap is updated during this call. The dirty rect is</span>
<span class="c1">//      used to determine how much of it needs updating.</span>
<span class="c1">//</span>

<span class="n">HRESULT</span>
<span class="n">CD3DSwapChainWithSwDC</span><span class="p">::</span><span class="nf">GetDC</span><span class="p">(</span>
    <span class="cm">/*__in_range(&lt;, this-&gt;m_cBackBuffers)*/</span> <span class="n">UINT</span> <span class="n">iBackBuffer</span><span class="p">,</span>
    <span class="nf">__in_ecount</span><span class="p">(</span><span class="m">1</span><span class="p">)</span> <span class="k">const</span> <span class="n">CMilRectU</span><span class="p">&amp;</span> <span class="n">rcDirty</span><span class="p">,</span>
    <span class="n">__deref_out</span> <span class="n">HDC</span> <span class="p">*</span><span class="n">phdcBackBuffer</span>
    <span class="p">)</span> <span class="k">const</span>
<span class="p">{</span>
    <span class="n">HRESULT</span> <span class="n">hr</span> <span class="p">=</span> <span class="n">S_OK</span><span class="p">;</span>

    <span class="nf">ENTER_USE_CONTEXT_FOR_SCOPE</span><span class="p">(</span><span class="nf">Device</span><span class="p">());</span>

    <span class="nf">Assert</span><span class="p">(</span><span class="n">iBackBuffer</span> <span class="p">&lt;</span> <span class="n">m_cBackBuffers</span><span class="p">);</span>

    <span class="n">D3DSURFACE_DESC</span> <span class="k">const</span> <span class="p">&amp;</span><span class="n">surfDesc</span> <span class="p">=</span> <span class="n">m_rgBackBuffers</span><span class="p">[</span><span class="n">iBackBuffer</span><span class="p">]-&gt;</span><span class="nf">Desc</span><span class="p">();</span>

    <span class="n">UINT</span> <span class="n">cbBufferInset</span> <span class="p">=</span>
          <span class="n">m_stride</span> <span class="p">*</span> <span class="n">rcDirty</span><span class="p">.</span><span class="n">top</span>
        <span class="p">+</span> <span class="nf">D3DFormatSize</span><span class="p">(</span><span class="n">surfDesc</span><span class="p">.</span><span class="n">Format</span><span class="p">)</span> <span class="p">*</span> <span class="n">rcDirty</span><span class="p">.</span><span class="n">left</span><span class="p">;</span>

    <span class="n">BYTE</span> <span class="p">*</span><span class="n">pbBuffer</span> <span class="p">=</span> <span class="n">reinterpret_cast</span><span class="p">&lt;</span><span class="n">BYTE</span><span class="p">*&gt;(</span><span class="n">m_pBuffer</span><span class="p">)</span> <span class="p">+</span> <span class="n">cbBufferInset</span><span class="p">;</span>

    <span class="nf">IFC</span><span class="p">(</span><span class="n">m_rgBackBuffers</span><span class="p">[</span><span class="n">iBackBuffer</span><span class="p">]-&gt;</span><span class="nf">ReadIntoSysMemBuffer</span><span class="p">(</span>
        <span class="n">rcDirty</span><span class="p">,</span>
        <span class="m">0</span><span class="p">,</span>
        <span class="n">NULL</span><span class="p">,</span>
        <span class="nf">D3DFormatToPixelFormat</span><span class="p">(</span><span class="n">surfDesc</span><span class="p">.</span><span class="n">Format</span><span class="p">,</span> <span class="n">TRUE</span><span class="p">),</span>
        <span class="n">m_stride</span><span class="p">,</span>
        <span class="nf">DBG_ANALYSIS_PARAM_COMMA</span><span class="p">(</span><span class="n">m_cbBuffer</span> <span class="p">-</span> <span class="n">cbBufferInset</span><span class="p">)</span>
        <span class="n">pbBuffer</span>
        <span class="p">));</span>

    <span class="p">*</span><span class="n">phdcBackBuffer</span> <span class="p">=</span> <span class="n">m_hdcCopiedBackBuffer</span><span class="p">;</span>

<span class="n">Cleanup</span><span class="p">:</span>
    <span class="nf">RRETURN</span><span class="p">(</span><span class="n">hr</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>上面代码的核心逻辑是 ReadIntoSysMemBuffer 方法，从这里进行了内存的拷贝。这里也就能回答大家为什么会使用更多的 CPU 的原因了，此时存在了显存(这个说法不一定对)到内存的拷贝，进行一次 4k 的大图拷贝的效率还是很低的。当然了，对于没有显存的设备来说，依然也是需要 CPU 到 CPU 的拷贝</p>

<p>好在 WPF 还是加了一点优化的，只是拷贝 rcDirty 范围而已，这个变量的命名意思是 rect (rc) 矩形的 Dirty 需要重绘的范围</p>

<p>回到 <code class="language-plaintext highlighter-rouge">CD3DDeviceLevel1::PresentWithGDI</code> 方法，在拿到 hdcBackBuffer 之后，此时就可以使用 hdcBackBuffer 进行 GDI 渲染了。调用的核心方法是 UpdateLayeredWindowEx 方法。这里的 UpdateLayeredWindowEx 是放在 oscompat.cpp 文件里，这个代码是为了做系统兼容使用的，本质就是将会通过系统判断，调用 <a href="https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-updatelayeredwindow?WT.mc_id=WD-MVP-5003260">UpdateLayeredWindow</a> 或 <a href="https://docs.microsoft.com/en-us/previous-versions/windows/desktop/legacy/ms633557(v=vs.85)?WT.mc_id=WD-MVP-5003260">UpdateLayeredWindowIndirect</a> 方法，如下面代码</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//+----------------------------------------------------------------------------</span>
<span class="c1">//</span>
<span class="c1">//  Function:  UpdateLayeredWindowEx</span>
<span class="c1">//</span>
<span class="c1">//  Synopsis:  Call UpdateLayeredWindow or UpdateLayeredWindowIndirect as</span>
<span class="c1">//             required by parameters.  If UpdateLayeredWindowIndirect is</span>
<span class="c1">//             needed (ULW_EX_NORESIZE requested), but not available return</span>
<span class="c1">//             HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND).  prcDirty is ignored</span>
<span class="c1">//             when UpdateLayeredWindowIndirect is not available.</span>
<span class="c1">//</span>
<span class="c1">//-----------------------------------------------------------------------------</span>
<span class="n">HRESULT</span>
<span class="nf">UpdateLayeredWindowEx</span><span class="p">(</span>
    <span class="n">__in</span> <span class="n">HWND</span> <span class="n">hWnd</span><span class="p">,</span>
    <span class="n">__in_opt</span> <span class="n">HDC</span> <span class="n">hdcDst</span><span class="p">,</span>
    <span class="nf">__in_ecount_opt</span><span class="p">(</span><span class="m">1</span><span class="p">)</span> <span class="n">CONST</span> <span class="n">POINT</span> <span class="p">*</span><span class="n">pptDst</span><span class="p">,</span>
    <span class="nf">__in_ecount_opt</span><span class="p">(</span><span class="m">1</span><span class="p">)</span> <span class="n">CONST</span> <span class="n">SIZE</span> <span class="p">*</span><span class="n">psize</span><span class="p">,</span>
    <span class="n">__in_opt</span> <span class="n">HDC</span> <span class="n">hdcSrc</span><span class="p">,</span>
    <span class="nf">__in_ecount_opt</span><span class="p">(</span><span class="m">1</span><span class="p">)</span> <span class="n">CONST</span> <span class="n">POINT</span> <span class="p">*</span><span class="n">pptSrc</span><span class="p">,</span>
    <span class="n">COLORREF</span> <span class="n">crKey</span><span class="p">,</span>
    <span class="nf">__in_ecount_opt</span><span class="p">(</span><span class="m">1</span><span class="p">)</span><span class="n">CONST</span> <span class="n">BLENDFUNCTION</span> <span class="p">*</span><span class="n">pblend</span><span class="p">,</span>
    <span class="n">DWORD</span> <span class="n">dwFlags</span><span class="p">,</span>
    <span class="nf">__in_ecount_opt</span><span class="p">(</span><span class="m">1</span><span class="p">)</span> <span class="n">CONST</span> <span class="n">RECT</span> <span class="p">*</span><span class="n">prcDirty</span>
    <span class="p">)</span>
</code></pre></div></div>

<p>而在 Windows 提供的 <a href="https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-updatelayeredwindow?WT.mc_id=WD-MVP-5003260">UpdateLayeredWindow</a> 或 <a href="https://docs.microsoft.com/en-us/previous-versions/windows/desktop/legacy/ms633557(v=vs.85)?WT.mc_id=WD-MVP-5003260">UpdateLayeredWindowIndirect</a> 方法将会支持传入 GDI 的绘图空间，根据给定的颜色设置透明。详细使用方法请看 <a href="https://www.cctry.com/thread-283521-1-1.html">分层窗口UpdateLayeredWindowIndirect局部更新</a></p>

<!-- ![](image/WPF 从最底层源代码了解 AllowsTransparency 性能差的原因/WPF 从最底层源代码了解 AllowsTransparency 性能差的原因0.png) -->

<p><img src="http://image.acmx.xyz/lindexi%2F202010301956101811.jpg" alt="" /></p>

<p>也就是说整个 WPF 的 AllowsTransparency 设置透明的一个最底层核心逻辑就是调用 <a href="https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-updatelayeredwindow?WT.mc_id=WD-MVP-5003260">UpdateLayeredWindow</a> 或 <a href="https://docs.microsoft.com/en-us/previous-versions/windows/desktop/legacy/ms633557(v=vs.85)?WT.mc_id=WD-MVP-5003260">UpdateLayeredWindowIndirect</a> 方法实现</p>

<p>在调用过程中需要从 DX 将窗口渲染内容拷贝出来放在内存，然后使用 GDI 进行渲染。在拷贝内存过程中需要重新申请一段内存空间，将会在窗口比较大的时候占用更多的内存，同时拷贝需要使用更多的 CPU 计算。而通过 GDI 的再次渲染将会降低整个应用的渲染性能</p>

<p>说到这里，是否有方法可以提升性能？其实有的，详细请看 <a href="https://blog.walterlv.com/post/wpf-transparent-window-without-allows-transparency.html">WPF 制作高性能的透明背景异形窗口</a></p>

<p>当前的 WPF 在 <a href="https://github.com/dotnet/wpf">https://github.com/dotnet/wpf</a> 完全开源，使用友好的 MIT 协议，意味着允许任何人任何组织和企业任意处置，包括使用，复制，修改，合并，发表，分发，再授权，或者销售。在仓库里面包含了完全的构建逻辑，只需要本地的网络足够好（因为需要下载一堆构建工具），即可进行本地构建</p>

:ET