I"^,<p>本文主要是试验在顺序进入等待 SemaphoreSlim 的任务是否会按照顺序经过锁执行</p>

<!--more-->

<!-- CreateTime:4/15/2020 8:23:09 AM -->

<p>我在一个有趣的WPF程序里面，需要限制任务同时执行的线程数量，不然用户就会说用我的程序会让电脑卡渣。而我的任务是需要按照指定顺序执行的，我需要每次同时仅执行10个任务，同时任务执行按照传入的顺序</p>

<p>此时可以用到 SemaphoreSlim 这个类，这个类的作用如下，给定初始的可以通过锁的数量，以及这个最大可以通过锁的数量。通过 Wait 方法进行等待，如果当前已经有超过可以通过的任务通过了，那么在 Wait 方法将会阻塞。如果没有超过可以通过的数量，那么将可以通过</p>

<p>使用 Release 方法可以添加一个或多个可以通过的数量，但是可以通过的数量最大不会超过初始化时传入的最大可以通过锁的数量的值</p>

<p>如下面代码</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>            <span class="kt">var</span> <span class="n">semaphoreSlim</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">SemaphoreSlim</span><span class="p">(</span><span class="m">10</span><span class="p">,</span> <span class="m">20</span><span class="p">);</span>
</code></pre></div></div>

<p>此时表示初始化的时候，可以让 10 个任务通过锁，也就是初始化的时候可以有10次调用 Wait 方法能通过</p>

<p>而第二个参数表示最大的可以通过的数量，通过 Release 可以添加一个或多个可以通过锁的任务，如 <code class="language-plaintext highlighter-rouge">semaphoreSlim.Release(100);</code> 表示设置有 100 个可以通过锁的任务，但是实际上在上面代码里面，因为设置了最大值是 20 也就是即使写 100 其实之后能通过的任务只有 20 个</p>

<p>而本文的测试在于我有任务按照顺序调用 Wait 方法进入等待，如我的任务有序号，我按照任务1 任务2 任务3 的顺序调用Wait方法，同时此时的锁的可以通过的数量是 0 也就是所有任务在等待</p>

<p>之后我通过 Release 方法的不断调用，请问此时通过锁的任务是否和队列一样，先等待的任务就先通过锁。答案是这样的</p>

<p>先调用 Wait 方法的任务，在锁开始释放的时候就先通过，我通过一个有趣的代码用来测试</p>

<p>我需要有很多线程进入锁的 Wait 方法，但是这些线程每个线程是一个任务，这些任务有顺序，进入等待方法的时候按照顺序进入</p>

<p>而小伙伴都知道，创建线程的先后顺序不会等于线程执行的先后顺序，所以我使用了 AutoResetEvent 在线程创建然后执行开始之后再创建下一个线程</p>

<p>先通过 SemaphoreSlim 创建一个初始值是 10 而最大值是 10 的锁，然后创建一个 AutoResetEvent 设置默认能通过一次</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>            <span class="kt">var</span> <span class="n">semaphoreSlim</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">SemaphoreSlim</span><span class="p">(</span><span class="m">10</span><span class="p">,</span> <span class="m">10</span><span class="p">);</span>

        <span class="k">private</span> <span class="k">static</span> <span class="k">readonly</span> <span class="n">AutoResetEvent</span> <span class="n">_autoResetEvent</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">AutoResetEvent</span><span class="p">(</span><span class="k">true</span><span class="p">);</span>
</code></pre></div></div>

<p>接下来进入循环创建线程，创建线程的时候先等待 AutoResetEvent 锁，而在线程执行的时候释放 AutoResetEvent 锁，这样就能让线程一定是在上一个线程执行之后再创建。而设置 AutoResetEvent 的初始值是通过，也就是第一个线程可以创建，但第二个线程需要等待第一个线程开始执行再创建</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>            <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="p">&lt;</span> <span class="m">1000</span><span class="p">;</span> <span class="n">i</span><span class="p">++)</span>
            <span class="p">{</span>
                <span class="kt">var</span> <span class="n">n</span> <span class="p">=</span> <span class="n">i</span><span class="p">;</span>
                <span class="n">_autoResetEvent</span><span class="p">.</span><span class="nf">WaitOne</span><span class="p">();</span>
                <span class="k">new</span> <span class="nf">Thread</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="p">{</span> <span class="nf">GeregelkunoNeawhikarcee</span><span class="p">(</span><span class="n">semaphoreSlim</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span> <span class="p">}).</span><span class="nf">Start</span><span class="p">();</span>
            <span class="p">}</span>
</code></pre></div></div>

<p>添加 GeregelkunoNeawhikarcee 方法，在方法进入的时候，也就是线程开始执行，释放 AutoResetEvent 锁，这样就能让下一个线程创建</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>            <span class="n">_autoResetEvent</span><span class="p">.</span><span class="nf">Set</span><span class="p">();</span>
</code></pre></div></div>

<p>进入等待 SemaphoreSlim 此时等待是按照线程创建的顺序等待</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>            <span class="n">semaphoreSlim</span><span class="p">.</span><span class="nf">Wait</span><span class="p">();</span>
</code></pre></div></div>

<p>接下来输出当前的任务号，主要用来调试是否通过锁的顺序和线程进入等待的顺序相同</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>            <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
</code></pre></div></div>

<p>接下来通过 Thread.Sleep 模拟执行长任务</p>

<p>在任务执行完成之后释放锁让下一个任务开始，全部代码放在这里</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        <span class="k">static</span> <span class="k">void</span> <span class="nf">Main</span><span class="p">(</span><span class="kt">string</span><span class="p">[]</span> <span class="n">args</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="kt">var</span> <span class="n">semaphoreSlim</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">SemaphoreSlim</span><span class="p">(</span><span class="m">10</span><span class="p">,</span> <span class="m">10</span><span class="p">);</span>

            <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="p">&lt;</span> <span class="m">1000</span><span class="p">;</span> <span class="n">i</span><span class="p">++)</span>
            <span class="p">{</span>
                <span class="kt">var</span> <span class="n">n</span> <span class="p">=</span> <span class="n">i</span><span class="p">;</span>
                <span class="n">_autoResetEvent</span><span class="p">.</span><span class="nf">WaitOne</span><span class="p">();</span>
                <span class="k">new</span> <span class="nf">Thread</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="p">{</span> <span class="nf">GeregelkunoNeawhikarcee</span><span class="p">(</span><span class="n">semaphoreSlim</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span> <span class="p">}).</span><span class="nf">Start</span><span class="p">();</span>
            <span class="p">}</span>

            <span class="n">Console</span><span class="p">.</span><span class="nf">Read</span><span class="p">();</span>
        <span class="p">}</span>

        <span class="k">private</span> <span class="k">static</span> <span class="k">readonly</span> <span class="n">AutoResetEvent</span> <span class="n">_autoResetEvent</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">AutoResetEvent</span><span class="p">(</span><span class="k">true</span><span class="p">);</span>

        <span class="k">private</span> <span class="k">static</span> <span class="k">void</span> <span class="nf">GeregelkunoNeawhikarcee</span><span class="p">(</span><span class="n">SemaphoreSlim</span> <span class="n">semaphoreSlim</span><span class="p">,</span> <span class="kt">int</span> <span class="n">n</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="s">$"</span><span class="p">{</span><span class="n">n</span><span class="p">}</span><span class="s"> 进入"</span><span class="p">);</span>
            <span class="n">_autoResetEvent</span><span class="p">.</span><span class="nf">Set</span><span class="p">();</span>

            <span class="n">semaphoreSlim</span><span class="p">.</span><span class="nf">Wait</span><span class="p">();</span>
            <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>

            <span class="n">Thread</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="n">TimeSpan</span><span class="p">.</span><span class="nf">FromSeconds</span><span class="p">(</span><span class="m">1</span><span class="p">));</span>
            <span class="n">semaphoreSlim</span><span class="p">.</span><span class="nf">Release</span><span class="p">();</span>
        <span class="p">}</span>
</code></pre></div></div>

<p>可以看到代码是按照顺序输出的</p>

<p>本文代码放在<a href="https://github.com/lindexi/lindexi_gd/tree/cf8c1add01a571bafeb0548b6aa43da8670227c9/CallnernawbawceKairwemwhejeene">github</a>欢迎小伙伴访问</p>

<p>在使用 SemaphoreSlim 的时候，需要释放，否则会泄露内存，详细请看 <a href="https://blog.lindexi.com/post/dotnet-%E4%BD%BF%E7%94%A8-SemaphoreSlim-%E5%8F%AF%E8%83%BD%E7%9A%84%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2.html">dotnet 使用 SemaphoreSlim 可能的内存泄露</a></p>

<p><a href="https://xinyuehtx.github.io/post/%E4%BD%BF%E7%94%A8SemaphoreSlim%E5%AE%9E%E7%8E%B0%E5%BC%82%E6%AD%A5%E7%AD%89%E5%BE%85.html">2019-12-1-使用SemaphoreSlim实现异步等待 - huangtengxiao</a></p>

:ET