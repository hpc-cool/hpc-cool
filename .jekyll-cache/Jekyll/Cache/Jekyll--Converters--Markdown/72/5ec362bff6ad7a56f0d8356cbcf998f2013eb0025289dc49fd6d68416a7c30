I"iH<p>本文告诉大家如何使用 Marshal 做出可以快速释放内存的大数组。
最近在做 3D ，需要不断申请一段大内存数组，然后就释放他，但是 C# 对于大内存不是立刻释放，所以就存在一定的性能问题。
在博客园看到了一位大神使用 Marshal 做出快速申请的大数组，于是我就学他的方法来弄一个。本文告诉大家这个类是如何使用。</p>

<!--more-->

<!-- CreateTime:2018/8/10 19:16:52 -->

<p>在使用的时候，先来看下原来的 C# 的大数组性能。可以看到在不停gc，性能不好</p>

<p><img src="http://image.acmx.xyz/34fdad35-5dfe-a75b-2b4b-8c5e313038e2%2F201712151723520171220112957.jpg" alt="" /></p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>      <span class="k">static</span> <span class="k">void</span> <span class="nf">Main</span><span class="p">(</span><span class="kt">string</span><span class="p">[]</span> <span class="n">args</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="p">&lt;</span> <span class="m">10000</span><span class="p">;</span> <span class="n">i</span><span class="p">++)</span>
            <span class="p">{</span>
                <span class="nf">Foo</span><span class="p">();</span>
            <span class="p">}</span>
            <span class="n">Console</span><span class="p">.</span><span class="nf">ReadKey</span><span class="p">();</span>
        <span class="p">}</span>

        <span class="k">private</span> <span class="k">static</span> <span class="k">void</span> <span class="nf">Foo</span><span class="p">()</span>
        <span class="p">{</span>
            <span class="kt">var</span> <span class="n">foo</span> <span class="p">=</span> <span class="k">new</span> <span class="kt">byte</span><span class="p">[</span><span class="m">1000000000</span><span class="p">];</span>
        <span class="p">}</span>
</code></pre></div></div>

<h2 id="介绍">介绍</h2>

<p>在使用 Marshal 之前需要知道这是什么，其实 Marshal 就是一个提供 COM 互操作的方法。</p>

<h2 id="使用">使用</h2>

<p>下面使用一个快速申请 int 数组来告诉大家如何使用。</p>

<p>是否还记得 C 的申请数组？其实下面的方法和 C 的相同</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>            <span class="kt">int</span> <span class="n">n</span> <span class="p">=</span> <span class="m">100000</span><span class="p">;</span><span class="c1">//长度</span>
            <span class="n">IntPtr</span> <span class="n">buffer</span> <span class="p">=</span> <span class="n">Marshal</span><span class="p">.</span><span class="nf">AllocHGlobal</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="p">*</span> <span class="n">n</span><span class="p">);</span>
</code></pre></div></div>

<p>这时就可以使用 buffer 作为数组</p>

<p>下面对他的第 k 个元素修改</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>            <span class="n">IntPtr</span> <span class="n">buffer</span> <span class="p">=</span> <span class="n">Marshal</span><span class="p">.</span><span class="nf">AllocHGlobal</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="p">*</span> <span class="n">n</span><span class="p">);</span>
            <span class="kt">int</span> <span class="n">k</span> <span class="p">=</span> <span class="m">2</span><span class="p">;</span>

            <span class="n">IntPtr</span> <span class="n">t</span> <span class="p">=</span> <span class="n">buffer</span> <span class="p">+</span> <span class="n">k</span> <span class="p">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span>
            <span class="kt">var</span> <span class="n">p</span> <span class="p">=</span> <span class="n">Marshal</span><span class="p">.</span><span class="n">PtrToStructure</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">&gt;(</span><span class="n">t</span><span class="p">);</span>
            <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="s">"p "</span> <span class="p">+</span> <span class="n">p</span><span class="p">);</span> <span class="c1">//196713 这时的值是不确定</span>

            <span class="n">p</span> <span class="p">=</span> <span class="m">2</span><span class="p">;</span>
            <span class="n">Marshal</span><span class="p">.</span><span class="nf">StructureToPtr</span><span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="n">t</span><span class="p">,</span><span class="k">false</span><span class="p">);</span>

            <span class="n">p</span> <span class="p">=</span> <span class="n">Marshal</span><span class="p">.</span><span class="n">PtrToStructure</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">&gt;(</span><span class="n">t</span><span class="p">);</span>
            <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="s">"p "</span> <span class="p">+</span> <span class="n">p</span><span class="p">);</span><span class="c1">//2</span>

            <span class="c1">//遍历</span>
            <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="s">"遍历"</span><span class="p">);</span>
            <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="p">&lt;</span> <span class="m">10</span><span class="p">;</span> <span class="n">i</span><span class="p">++)</span>
            <span class="p">{</span>
                <span class="n">t</span> <span class="p">=</span> <span class="n">buffer</span> <span class="p">+</span> <span class="n">i</span> <span class="p">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span>
                <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="n">Marshal</span><span class="p">.</span><span class="n">PtrToStructure</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">&gt;(</span><span class="n">t</span><span class="p">));</span>
            <span class="p">}</span>
</code></pre></div></div>

<p>遍历：</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>            <span class="m">43909312</span>
            <span class="m">44502144</span>
            <span class="m">2</span>
            <span class="m">0</span>
            <span class="m">0</span>
            <span class="m">24</span>
            <span class="m">1357220181</span>
            <span class="m">196712</span>
            <span class="m">550912</span>
            <span class="m">543686656</span>
</code></pre></div></div>

<p>可以从上面的代码看到，主要使用的两个方法是 StructureToPtr 和 PtrToStructure ，而 StructureToPtr 就是从指定类型写到指针，希望大家还知道如何使用指针，PtrToStructure 就是从指针指向的地方开始读数据，读指定类型的数据。所以可以从 Marshal 把一个类型使用另一个类型来读取，但是一般需要读取的类型都需要是确定类型大小的，如 char 可以、string 不可以。</p>

<p>反过来，StructureToPtr 是对指定指针写入指定的类型，同样也是需要确定这个类型的大小，如可以写入 char 但是不可以写入 string。这就是对数组读写的方法。</p>

<p>那么遍历的时候什么输出一些诡异的值，实际上因为没有初始化，里面的值是不确定的。我觉得用这个做随机数也不错。</p>

<p>使用 Marshal 是比较安全，因为 ms 做了很多处理，但是也会让程序闪退，如下面的代码</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        <span class="k">private</span> <span class="k">static</span> <span class="k">void</span> <span class="nf">Foo</span><span class="p">()</span>
        <span class="p">{</span>
            <span class="kt">int</span> <span class="n">n</span> <span class="p">=</span> <span class="m">100000</span><span class="p">;</span><span class="c1">//长度</span>
            <span class="n">IntPtr</span> <span class="n">buffer</span> <span class="p">=</span> <span class="n">Marshal</span><span class="p">.</span><span class="nf">AllocHGlobal</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="p">*</span> <span class="n">n</span><span class="p">);</span>

            <span class="k">try</span>
            <span class="p">{</span>
                <span class="kt">var</span> <span class="n">t</span> <span class="p">=</span> <span class="n">buffer</span> <span class="p">+</span> <span class="p">(</span><span class="n">n</span> <span class="p">*</span> <span class="m">10</span><span class="p">)</span> <span class="p">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span>
                <span class="kt">var</span> <span class="n">p</span> <span class="p">=</span> <span class="n">Marshal</span><span class="p">.</span><span class="n">PtrToStructure</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">&gt;(</span><span class="n">t</span><span class="p">);</span>
            <span class="p">}</span>
            <span class="k">catch</span> <span class="p">(</span><span class="n">Exception</span> <span class="n">e</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="n">e</span><span class="p">);</span>
            <span class="p">}</span>

            <span class="n">Marshal</span><span class="p">.</span><span class="nf">FreeHGlobal</span><span class="p">(</span><span class="n">buffer</span><span class="p">);</span>
        <span class="p">}</span>
</code></pre></div></div>

<p>会出现异常 System.AccessViolationException，这个异常是无法 catch 的，所以使用的时候最好封装一下</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">“</span><span class="n">System</span><span class="p">.</span><span class="n">AccessViolationException</span><span class="err">”类型的未经处理的异常在</span> <span class="err">未知模块</span>
<span class="err">尝试读取或写入受保护的内存。这通常指示其他内存已损坏</span>
</code></pre></div></div>

<p>如果需要 catch 那么请在 app.config 添加下面的代码</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">&lt;?</span><span class="n">xml</span> <span class="n">version</span><span class="p">=</span><span class="s">"1.0"</span> <span class="n">encoding</span><span class="p">=</span><span class="s">"utf-8"</span> <span class="p">?&gt;</span>
<span class="p">&lt;</span><span class="n">configuration</span><span class="p">&gt;</span>
  <span class="p">&lt;</span><span class="n">runtime</span><span class="p">&gt;</span>
    <span class="p">&lt;</span><span class="n">legacyCorruptedStateExceptionsPolicy</span> <span class="n">enabled</span><span class="p">=</span><span class="s">"true"</span> <span class="p">/&gt;</span>
  <span class="p">&lt;/</span><span class="n">runtime</span><span class="p">&gt;</span>
<span class="p">&lt;/</span><span class="n">configuration</span><span class="p">&gt;</span>
</code></pre></div></div>

<p>然后在 Main 函数添加 HandleProcessCorruptedStateExceptions ，请看代码</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        <span class="p">[</span><span class="n">HandleProcessCorruptedStateExceptions</span><span class="p">]</span>
        <span class="k">static</span> <span class="k">void</span> <span class="nf">Main</span><span class="p">(</span><span class="kt">string</span><span class="p">[]</span> <span class="n">args</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">AppDomain</span><span class="p">.</span><span class="n">CurrentDomain</span><span class="p">.</span><span class="n">UnhandledException</span> <span class="p">+=</span> <span class="n">CurrentDomain_UnhandledException</span><span class="p">;</span>

            <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="p">&lt;</span> <span class="m">100000</span><span class="p">;</span> <span class="n">i</span><span class="p">++)</span>
            <span class="p">{</span>
                <span class="k">try</span>
                <span class="p">{</span>
                    <span class="nf">Foo</span><span class="p">();</span>
                <span class="p">}</span>
                <span class="k">catch</span> <span class="p">(</span><span class="n">Exception</span> <span class="n">e</span><span class="p">)</span>
                <span class="p">{</span>
                    <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="n">e</span><span class="p">);</span>
                   
                <span class="p">}</span>
            <span class="p">}</span>
            <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="s">"完成"</span><span class="p">);</span>
            <span class="n">Console</span><span class="p">.</span><span class="nf">ReadKey</span><span class="p">();</span>
        <span class="p">}</span>
</code></pre></div></div>

<p>这时可以看到进入 UnhandledException ，但是无法接住，软件还是会崩溃</p>

<p><img src="http://image.acmx.xyz/34fdad35-5dfe-a75b-2b4b-8c5e313038e2%2F201712151723520171220152536.jpg" alt="" /></p>

<h3 id="释放内存">释放内存</h3>

<p>那么如何释放内存？因为这个申请是没有经过管理的，如果没有手动释放，那么就出现内存泄露。</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        <span class="k">static</span> <span class="k">void</span> <span class="nf">Main</span><span class="p">(</span><span class="kt">string</span><span class="p">[]</span> <span class="n">args</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="p">&lt;</span> <span class="m">10000</span><span class="p">;</span> <span class="n">i</span><span class="p">++)</span>
            <span class="p">{</span>
                <span class="nf">Foo</span><span class="p">();</span>
            <span class="p">}</span>
            <span class="n">Console</span><span class="p">.</span><span class="nf">ReadKey</span><span class="p">();</span>
        <span class="p">}</span>

        <span class="k">private</span> <span class="k">static</span> <span class="k">void</span> <span class="nf">Foo</span><span class="p">()</span>
        <span class="p">{</span>
            <span class="kt">int</span> <span class="n">n</span> <span class="p">=</span> <span class="m">100000</span><span class="p">;</span><span class="c1">//长度</span>
            <span class="n">IntPtr</span> <span class="n">buffer</span> <span class="p">=</span> <span class="n">Marshal</span><span class="p">.</span><span class="nf">AllocHGlobal</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="p">*</span> <span class="n">n</span><span class="p">);</span>
           
        <span class="p">}</span>
</code></pre></div></div>

<p>上面的代码很快就可以看到内存占用到2G，所以需要手动释放</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>            <span class="n">Marshal</span><span class="p">.</span><span class="nf">FreeHGlobal</span><span class="p">(</span><span class="n">buffer</span><span class="p">);</span>

</code></pre></div></div>

<p>原来的 byte 数组需要使用 1G 内存，而且速度很慢，而现在使用这个方法只需要 7M 内存，速度很快</p>

<p><img src="http://image.acmx.xyz/34fdad35-5dfe-a75b-2b4b-8c5e313038e2%2F201712151723520171220142918.jpg" alt="" /></p>

<p>所以在需要进行大数组申请的时候，需要不停释放，就可以使用这个方法。</p>

<p>如果想使用封装好的，请看下面的大神弄好的类</p>

<p>参见：<a href="http://www.cnblogs.com/bitzhuwei/p/huge-unmanged-array-in-csharp.html">C#+无unsafe的非托管大数组(large unmanaged array in c# without ‘unsafe’ keyword) - BIT祝威 - 博客园</a></p>

<h2 id="实际使用">实际使用</h2>

<p>实际在哪些地方使用？实际上因为很多时候都是使用实例化池，但是实例化池在进入游戏的时候，可以让gc不会让程序暂停，但是会在游戏进入下一关的时候，无法快速清理数据。所以这时就可以使用 Marshal 做实例化池，瞬间就可以清空。</p>

<p>上面的方法暂时不告诉大家如何做，因为涉及到公司的使用。</p>

:ET