I"@b<p>关于什么是委托，委托如何使用，我在这里就不说了。
需要说的：</p>
<ol>
  <li>委托是函数指针链</li>
  <li>委托的 BeginInvoke</li>
  <li>委托如果出现异常，会如何</li>
</ol>

<!--more-->

<!-- CreateTime:2019/9/2 12:57:37 -->

<div id="toc"></div>

<p>如果不知道函数指针，可以继续往下看，我来告诉大家，为何需要委托。</p>

<p>假如在写游戏，有一个人物，他会升级，那么在他升级的时候，需要给他添加潜力值，而判断升级是经验类需要写的。</p>

<p>先写一个经验类。</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="err">核心</span>
    <span class="err">如果当前经验大于最大经验，升级。</span>
</code></pre></div></div>

<p>但是升级是在经验类里，经验类外的人物不会知道已经升级了，那么如何让人物知道升级？</p>

<p>这时可以使用委托。</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>     <span class="err">如果当前经验大于最大经验</span>
     <span class="err">调用函数升级</span>
</code></pre></div></div>

<p>那么函数 升级 如何让人物知道，可以使用一个委托</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="err">升级</span>
    <span class="err">调用委托</span>
</code></pre></div></div>

<p>于是人物可以添加函数到经验。</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="err">经验</span><span class="p">.</span><span class="err">升级</span><span class="p">=</span><span class="err">人物</span><span class="p">.</span><span class="err">升级</span>
</code></pre></div></div>

<p>这样，经验的升级就是使用人物的升级，可以使用其他类的函数。</p>

<p>上面没有代码，现在来说个有代码的。</p>

<p>假如需要去寄快递，那么需要找邮递，把东西给他</p>

<p>假设有个邮递，可以寄快递</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="k">class</span> <span class="err">邮递</span>
    <span class="err">{</span>

        <span class="nc">public</span> <span class="k">static</span> <span class="n">Action</span> <span class="err">寄快递</span><span class="p">;</span>
    <span class="p">}</span>
</code></pre></div></div>

<p>委托最好用Action</p>

<p>这里定义委托是，不知道会是哪个快递员会去寄快递，在实际，谁也不知道最后是哪个，快递员可能说不想干了，实际快递太辛苦，大家多体谅。所以不能写函数说，快递A 给 小明去寄，因为不知道小明是不是今天上班。</p>

<p>来写一个 主角 张 ，他需要去寄快递。</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="k">class</span> <span class="nc">MrZhang</span>
    <span class="p">{</span>
         <span class="k">public</span> <span class="k">void</span> <span class="err">寄快递</span><span class="p">()</span>
         <span class="p">{</span>
         	<span class="err">邮递</span><span class="p">.</span><span class="err">寄快递</span><span class="p">();</span>
         <span class="p">}</span>

    <span class="p">}</span>
</code></pre></div></div>

<p>不知道是谁上班，但是我可以寄快递。</p>

<p>最后，今天来上班的快递员</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
    <span class="err">快递员</span> <span class="n">a</span> <span class="p">=</span> <span class="k">new</span> <span class="err">快递员</span><span class="p">();</span>
    <span class="err">邮递</span><span class="p">.</span><span class="err">寄快递</span> <span class="p">=</span> <span class="n">a</span><span class="p">.</span><span class="err">寄快递</span><span class="p">;</span>

    <span class="k">class</span> <span class="err">快递员</span>
    <span class="err">{</span>

         <span class="nc">public</span> <span class="k">void</span> <span class="err">寄快递</span><span class="p">()</span>
         <span class="p">{</span>
              
         <span class="p">}</span>
    <span class="p">}</span>
</code></pre></div></div>

<p>就是快递，所以这就是委托使用。</p>

<p>使用一个函数，不知道他是谁用的，可以使用委托。</p>

<p>如果使用的委托是 多播，那么小心用 BeginInvoke</p>

<p>如果使用 同步，那么多个方法是可以运行</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>            <span class="k">static</span> <span class="k">void</span> <span class="nf">Main</span><span class="p">(</span><span class="kt">string</span><span class="p">[]</span> <span class="n">args</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">Action</span> <span class="n">m</span> <span class="p">=</span> <span class="n">M1</span><span class="p">;</span>
            <span class="n">m</span> <span class="p">+=</span> <span class="n">M2</span><span class="p">;</span>
            <span class="n">m</span><span class="p">.</span><span class="nf">Invoke</span><span class="p">();</span>
        <span class="p">}</span>

        <span class="k">private</span> <span class="k">static</span> <span class="k">void</span> <span class="nf">M1</span><span class="p">()</span>
        <span class="p">{</span>
            <span class="nf">p</span><span class="p">();</span>
        <span class="p">}</span>

        <span class="k">private</span> <span class="k">static</span> <span class="k">void</span> <span class="nf">M2</span><span class="p">()</span>
        <span class="p">{</span>
            <span class="nf">p</span><span class="p">();</span>
        <span class="p">}</span>

        <span class="k">private</span> <span class="k">static</span> <span class="k">void</span> <span class="nf">p</span><span class="p">()</span>
        <span class="p">{</span>
            <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="s">"线程ID为：{0}"</span><span class="p">,</span> <span class="n">Thread</span><span class="p">.</span><span class="n">CurrentThread</span><span class="p">.</span><span class="n">ManagedThreadId</span><span class="p">);</span>
        <span class="p">}</span>
</code></pre></div></div>

<p>如果使用的BeginInvoke，那么在委托多播使用 BeginInvoke 会报异常 <code class="language-plaintext highlighter-rouge">System.ArgumentException:“The delegate must have only one target.”</code></p>

<p>在一个线程不能同时执行多个方法，使用 BeginInvoke 必须在多个线程，所以可以使用 获得所有方法，然后执行</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        <span class="k">static</span> <span class="k">void</span> <span class="nf">Main</span><span class="p">(</span><span class="kt">string</span><span class="p">[]</span> <span class="n">args</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">Action</span> <span class="n">m</span> <span class="p">=</span> <span class="n">M1</span><span class="p">;</span>
            <span class="n">m</span> <span class="p">+=</span> <span class="n">M2</span><span class="p">;</span>
            <span class="c1">//m.Invoke();</span>
            <span class="n">List</span><span class="p">&lt;</span><span class="n">IAsyncResult</span><span class="p">&gt;</span> <span class="n">list</span><span class="p">=</span><span class="k">new</span> <span class="n">List</span><span class="p">&lt;</span><span class="n">IAsyncResult</span><span class="p">&gt;();</span>
            <span class="kt">var</span> <span class="n">invtl</span> <span class="p">=</span> <span class="n">m</span><span class="p">.</span><span class="nf">GetInvocationList</span><span class="p">().</span><span class="n">OfType</span><span class="p">&lt;</span><span class="n">Action</span><span class="p">&gt;().</span><span class="nf">ToList</span><span class="p">();</span>
            <span class="k">foreach</span> <span class="p">(</span><span class="n">Action</span> <span class="n">temp</span> <span class="k">in</span> <span class="n">invtl</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="n">list</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="n">temp</span><span class="p">.</span><span class="nf">BeginInvoke</span><span class="p">((</span><span class="n">e</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span> <span class="p">},</span> <span class="k">null</span><span class="p">));</span>
            <span class="p">}</span>

            <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="p">&lt;</span> <span class="n">invtl</span><span class="p">.</span><span class="nf">Count</span><span class="p">();</span> <span class="n">i</span><span class="p">++)</span>
            <span class="p">{</span>
                <span class="n">invtl</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="nf">EndInvoke</span><span class="p">(</span><span class="n">list</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
            <span class="p">}</span>
           
        <span class="p">}</span>

        <span class="k">private</span> <span class="k">static</span> <span class="k">void</span> <span class="nf">M1</span><span class="p">()</span>
        <span class="p">{</span>
            <span class="nf">p</span><span class="p">();</span>
        <span class="p">}</span>

        <span class="k">private</span> <span class="k">static</span> <span class="k">void</span> <span class="nf">M2</span><span class="p">()</span>
        <span class="p">{</span>
            <span class="nf">p</span><span class="p">();</span>
        <span class="p">}</span>

        <span class="k">private</span> <span class="k">static</span> <span class="k">void</span> <span class="nf">p</span><span class="p">()</span>
        <span class="p">{</span>
            <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="s">"线程ID为：{0}"</span><span class="p">,</span> <span class="n">Thread</span><span class="p">.</span><span class="n">CurrentThread</span><span class="p">.</span><span class="n">ManagedThreadId</span><span class="p">);</span>
        <span class="p">}</span>
</code></pre></div></div>
<p>有两个需要知道：</p>

<p><code class="language-plaintext highlighter-rouge">m.GetInvocationList()</code> 得到 Delegate 不能直接执行。</p>

<p>需要转类型，定义是知道他是什么类型，上面使用的是 Action ，所以可以转 Action ，如果是自定义的，那么使用自定义的。</p>

<p>第二，如果使用 BeginInvoke ，在等待时，需要拿到 IAsyncResult 才可以。</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="kt">var</span> <span class="n">temp</span> <span class="p">=</span> <span class="n">m</span><span class="p">.</span><span class="nf">BeginInvoke</span><span class="p">((</span><span class="n">e</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span> <span class="p">},</span> <span class="k">null</span><span class="p">);</span>
    <span class="n">m</span><span class="p">.</span><span class="nf">EndInvoke</span><span class="p">(</span><span class="n">temp</span><span class="p">);</span>
</code></pre></div></div>

<p>上面代码：如果要使用 BeginInvoke ，小心  Delegate 是多个函数，不是一个函数，所以使用时，建议使用</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>            <span class="kt">var</span> <span class="n">invtl</span> <span class="p">=</span> <span class="n">m</span><span class="p">.</span><span class="nf">GetInvocationList</span><span class="p">().</span><span class="n">OfType</span><span class="p">&lt;</span><span class="n">Action</span><span class="p">&gt;().</span><span class="nf">ToList</span><span class="p">();</span>
            <span class="k">foreach</span> <span class="p">(</span><span class="n">Action</span> <span class="n">temp</span> <span class="k">in</span> <span class="n">invtl</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="n">list</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="n">temp</span><span class="p">.</span><span class="nf">BeginInvoke</span><span class="p">((</span><span class="n">e</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span> <span class="p">},</span> <span class="k">null</span><span class="p">));</span>
            <span class="p">}</span>
</code></pre></div></div>

<p>需要把类型换自己的类型。</p>

<h2 id="如果委托发生异常">如果委托发生异常</h2>

<p>如果委托方法里没有 try catch，那么如果使用 invoke， 委托是函数指针链，所以会在执行异常退出。</p>

<p>如果使用 BeginInvoke ，那么会在 EndInvoke 退出。</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        <span class="k">static</span> <span class="k">void</span> <span class="nf">Main</span><span class="p">(</span><span class="kt">string</span><span class="p">[]</span> <span class="n">args</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">Action</span> <span class="n">m</span> <span class="p">=</span> <span class="n">M1</span><span class="p">;</span>
            <span class="n">m</span> <span class="p">+=</span> <span class="n">M2</span><span class="p">;</span>
            <span class="c1">//m.Invoke();</span>
            <span class="n">List</span><span class="p">&lt;</span><span class="n">IAsyncResult</span><span class="p">&gt;</span> <span class="n">list</span><span class="p">=</span><span class="k">new</span> <span class="n">List</span><span class="p">&lt;</span><span class="n">IAsyncResult</span><span class="p">&gt;();</span>
            <span class="kt">var</span> <span class="n">invtl</span> <span class="p">=</span> <span class="n">m</span><span class="p">.</span><span class="nf">GetInvocationList</span><span class="p">().</span><span class="n">OfType</span><span class="p">&lt;</span><span class="n">Action</span><span class="p">&gt;().</span><span class="nf">ToList</span><span class="p">();</span>
            <span class="k">foreach</span> <span class="p">(</span><span class="n">Action</span> <span class="n">temp</span> <span class="k">in</span> <span class="n">invtl</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="n">list</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="n">temp</span><span class="p">.</span><span class="nf">BeginInvoke</span><span class="p">((</span><span class="n">e</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span> <span class="p">},</span> <span class="k">null</span><span class="p">));</span>
            <span class="p">}</span>

            <span class="c1">//for (int i = 0; i &lt; invtl.Count(); i++)</span>
            <span class="c1">//{</span>
            <span class="c1">//    invtl[i].EndInvoke(list[i]);</span>
            <span class="c1">//}</span>
           
        <span class="p">}</span>

        <span class="k">private</span> <span class="k">static</span> <span class="k">void</span> <span class="nf">M1</span><span class="p">()</span>
        <span class="p">{</span>
            <span class="nf">p</span><span class="p">();</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="nf">ArgumentException</span><span class="p">();</span>
        <span class="p">}</span>

        <span class="k">private</span> <span class="k">static</span> <span class="k">void</span> <span class="nf">M2</span><span class="p">()</span>
        <span class="p">{</span>
            <span class="nf">p</span><span class="p">();</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="nf">ArgumentException</span><span class="p">();</span>
        <span class="p">}</span>

        <span class="k">private</span> <span class="k">static</span> <span class="k">void</span> <span class="nf">p</span><span class="p">()</span>
        <span class="p">{</span>
            <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="s">"线程ID为：{0}"</span><span class="p">,</span> <span class="n">Thread</span><span class="p">.</span><span class="n">CurrentThread</span><span class="p">.</span><span class="n">ManagedThreadId</span><span class="p">);</span>
        <span class="p">}</span>
</code></pre></div></div>

<p>上面代码没有 EndInvoke 不会有异常，异常发生在别线程，所以不会在Main函数异常。</p>

<p>如果使用 EndInvoke 会在 Main 异常</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>           <span class="k">static</span> <span class="k">void</span> <span class="nf">Main</span><span class="p">(</span><span class="kt">string</span><span class="p">[]</span> <span class="n">args</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">Action</span> <span class="n">m</span> <span class="p">=</span> <span class="n">M1</span><span class="p">;</span>
            <span class="n">m</span> <span class="p">+=</span> <span class="n">M2</span><span class="p">;</span>
            <span class="c1">//m.Invoke();</span>
            <span class="n">List</span><span class="p">&lt;</span><span class="n">IAsyncResult</span><span class="p">&gt;</span> <span class="n">list</span><span class="p">=</span><span class="k">new</span> <span class="n">List</span><span class="p">&lt;</span><span class="n">IAsyncResult</span><span class="p">&gt;();</span>
            <span class="kt">var</span> <span class="n">invtl</span> <span class="p">=</span> <span class="n">m</span><span class="p">.</span><span class="nf">GetInvocationList</span><span class="p">().</span><span class="n">OfType</span><span class="p">&lt;</span><span class="n">Action</span><span class="p">&gt;().</span><span class="nf">ToList</span><span class="p">();</span>
            <span class="k">foreach</span> <span class="p">(</span><span class="n">Action</span> <span class="n">temp</span> <span class="k">in</span> <span class="n">invtl</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="n">list</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="n">temp</span><span class="p">.</span><span class="nf">BeginInvoke</span><span class="p">((</span><span class="n">e</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span> <span class="p">},</span> <span class="k">null</span><span class="p">));</span>
            <span class="p">}</span>

            <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="p">&lt;</span> <span class="n">invtl</span><span class="p">.</span><span class="nf">Count</span><span class="p">();</span> <span class="n">i</span><span class="p">++)</span>
            <span class="p">{</span>
                <span class="n">invtl</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="nf">EndInvoke</span><span class="p">(</span><span class="n">list</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
            <span class="p">}</span>

        <span class="p">}</span>

        <span class="k">private</span> <span class="k">static</span> <span class="k">void</span> <span class="nf">M1</span><span class="p">()</span>
        <span class="p">{</span>
            <span class="nf">p</span><span class="p">();</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="nf">ArgumentException</span><span class="p">();</span>
        <span class="p">}</span>

        <span class="k">private</span> <span class="k">static</span> <span class="k">void</span> <span class="nf">M2</span><span class="p">()</span>
        <span class="p">{</span>
            <span class="nf">p</span><span class="p">();</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="nf">ArgumentException</span><span class="p">();</span>
        <span class="p">}</span>

        <span class="k">private</span> <span class="k">static</span> <span class="k">void</span> <span class="nf">p</span><span class="p">()</span>
        <span class="p">{</span>
            <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="s">"线程ID为：{0}"</span><span class="p">,</span> <span class="n">Thread</span><span class="p">.</span><span class="n">CurrentThread</span><span class="p">.</span><span class="n">ManagedThreadId</span><span class="p">);</span>
        <span class="p">}</span>
</code></pre></div></div>

<h2 id="事件">事件</h2>

<p>如果事件使用 BeginInvoke 和 委托一样</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>     
            <span class="n">_event</span> <span class="p">+=</span> <span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">e</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="nf">M1</span><span class="p">();</span>
            <span class="n">_event</span> <span class="p">+=</span> <span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">e</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="nf">M2</span><span class="p">();</span>
            <span class="n">_event</span><span class="p">?.</span><span class="nf">BeginInvoke</span><span class="p">(</span><span class="k">null</span><span class="p">,</span> <span class="k">null</span><span class="p">,</span> <span class="p">(</span><span class="n">e</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span> <span class="p">},</span> <span class="k">null</span><span class="p">);</span>

     <span class="k">private</span> <span class="k">static</span> <span class="n">EventHandler</span> <span class="n">_event</span><span class="p">;</span>
</code></pre></div></div>

<p>异常：<code class="language-plaintext highlighter-rouge">System.ArgumentException:“The delegate must have only one target.”</code></p>

<p>需要和 委托 一样，获得函数指针，执行，如果方法里有异常，那么不会在 Main 方法异常，如果没有使用 End 。</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>            <span class="k">foreach</span> <span class="p">(</span><span class="kt">var</span> <span class="n">temp</span> <span class="k">in</span> <span class="n">_event</span><span class="p">.</span><span class="nf">GetInvocationList</span><span class="p">().</span><span class="n">OfType</span><span class="p">&lt;</span><span class="n">EventHandler</span><span class="p">&gt;())</span>
            <span class="p">{</span>
                <span class="n">temp</span><span class="p">.</span><span class="nf">BeginInvoke</span><span class="p">(</span><span class="k">null</span><span class="p">,</span> <span class="k">null</span><span class="p">,</span> <span class="p">(</span><span class="n">e</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span> <span class="p">},</span> <span class="k">null</span><span class="p">);</span>
            <span class="p">}</span>
</code></pre></div></div>

<p>本文还没写好，如果有问题，请联系我</p>

<p>本文内容属于大量抄袭，代码是自己写，但是抄了代码大神写的，于是羞愧放下他的博客：</p>

<p>http://www.cnblogs.com/free722/archive/2011/04/04/2005275.html</p>

<p>http://stackoverflow.com/questions/25979264/understanding-the-wpf-dispatcher-begininvoke</p>

:ET