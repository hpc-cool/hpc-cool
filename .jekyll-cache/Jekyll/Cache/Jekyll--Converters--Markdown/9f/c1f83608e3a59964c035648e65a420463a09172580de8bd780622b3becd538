I"T=<p>﻿Windows下没有比较好的Markdown编辑器
我就自己写一个
csdn的Markdown很好，就是我需要截图保存有麻烦
需要把我的截图保存在本地，然后上传</p>

<!--more-->

<!-- CreateTime:2018/2/13 17:23:03 -->

<div id="toc"></div>

<p>这个过程比较麻烦</p>

<p>csdn的图没法外链</p>

<p>我想把自己的博客放到github，发现都没有图片</p>

<p>我自己写了的，可以把截图保存为图片，放到用户位置</p>

<p>然后插入<code class="language-plaintext highlighter-rouge">![](image/file.png)</code></p>

<p>拖入图片也插入<code class="language-plaintext highlighter-rouge">![](image/file.png)</code></p>

<p><img src="image/2016191443.png" alt="这里写图片描述" /></p>

<p>界面有编辑和设置</p>

<p>编辑由TopAppBar，TextBox作为输入和TextBlock显示</p>

<p>拖入文件可以使用Drop</p>

<p>在Grid写Drop=”{x:Bind view.dropimg}” DragOver=”Grid_DragOver”</p>

<p>Grid要AllowDrop=”True”</p>

<p>在MainPage.xaml.cs</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    private void Grid_DragOver(object sender, DragEventArgs e)
    {
        e.AcceptedOperation = Windows.ApplicationModel.DataTransfer.DataPackageOperation.Copy;
        e.DragUIOverride.Caption = "打开";
        e.Handled = true;
    }
</code></pre></div></div>

<p><img src="image/2016191448.png" alt="这里写图片描述" /></p>

<p>在viewModel</p>

<p>public async void dropimg(object sender, Windows.UI.Xaml.DragEventArgs e)</p>

<p>dropimg 处理拖进来的DataPackageView</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        var defer = e.GetDeferral();
        try
        {
            DataPackageView dataView = e.DataView;
            string str = await _m.clipboard(dataView);
            tianjia(str);
        }
        finally
        {
            defer.Complete();
        }
</code></pre></div></div>

<p>文件有</p>

<p>MainPage.xaml</p>

<p>MainPage.xaml.cs</p>

<p>option.xaml</p>

<p>option.xaml.cs</p>

<p>viewModel.cs</p>

<p>model.cs</p>

<p>notify_property.cs</p>

<p>其中notify_property.cs提供继承通知UI改变值</p>

<p>model包括</p>

<p>正在编辑文件file</p>

<p>保存位置folder</p>

<p>其中folder根据StorageApplicationPermissions.FutureAccessList获得用户位置。</p>

<p>可以访问的路径不多，因为一个程序可以访问文件路径多，不安全。如果每次放在一个不是程序目录的位置，都要用户设置，很麻烦。在用户第一次使用，让用户选择一个位置，然后应用程序可以直接访问用户选择的这个，不用每次都选择。</p>

<p>用户输入text</p>

<p>标题 name</p>

<p>其中text和name都是public string _text;</p>

<p><img src="image/2016191456.png" alt="这里写图片描述" /></p>

<p>这样是在viewModel使用，可以OnPropertyChanged();</p>

<p>writetext是用户能输入，在没有设置用户位置，不能输入</p>

<p>_open是否打开</p>

<p>public async Task<string> clipboard(DataPackageView con)</string></p>

<p>处理剪贴板和拖入内容</p>

<p>本来我是处理剪贴板，因为拖入也是DataPackageView</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    public async Task&lt;string&gt; clipboard(DataPackageView con)
    {
        string str = string.Empty;
        //文本
        if (con.Contains(StandardDataFormats.Text))
        {
            str = await con.GetTextAsync();
            //tianjiatext(str);
            return str;
        }

        //图片
        if (con.Contains(StandardDataFormats.Bitmap))
        {
            RandomAccessStreamReference img = await con.GetBitmapAsync();
            var imgstream = await img.OpenReadAsync();
            Windows.UI.Xaml.Media.Imaging.BitmapImage bitmap = new Windows.UI.Xaml.Media.Imaging.BitmapImage();
            bitmap.SetSource(imgstream);

            Windows.UI.Xaml.Media.Imaging.WriteableBitmap src = new Windows.UI.Xaml.Media.Imaging.WriteableBitmap(bitmap.PixelWidth, bitmap.PixelHeight);
            src.SetSource(imgstream);

            Windows.Graphics.Imaging.BitmapDecoder decoder = await Windows.Graphics.Imaging.BitmapDecoder.CreateAsync(imgstream);
            Windows.Graphics.Imaging.PixelDataProvider pxprd = await decoder.GetPixelDataAsync(Windows.Graphics.Imaging.BitmapPixelFormat.Bgra8, Windows.Graphics.Imaging.BitmapAlphaMode.Straight, new Windows.Graphics.Imaging.BitmapTransform(), Windows.Graphics.Imaging.ExifOrientationMode.RespectExifOrientation, Windows.Graphics.Imaging.ColorManagementMode.DoNotColorManage);
            byte[] buffer = pxprd.DetachPixelData();

            str = "image";
            StorageFolder folder = await _folder.GetFolderAsync(str);

            StorageFile file = await folder.CreateFileAsync(DateTime.Now.Year.ToString() + DateTime.Now.Month.ToString() + DateTime.Now.Day.ToString() + DateTime.Now.Hour.ToString() + DateTime.Now.Minute.ToString() + ".png", CreationCollisionOption.GenerateUniqueName);

            using (var fileStream = await file.OpenAsync(FileAccessMode.ReadWrite))
            {
                var encoder = await Windows.Graphics.Imaging.BitmapEncoder.CreateAsync(Windows.Graphics.Imaging.BitmapEncoder.PngEncoderId, fileStream);
                encoder.SetPixelData(Windows.Graphics.Imaging.BitmapPixelFormat.Bgra8, Windows.Graphics.Imaging.BitmapAlphaMode.Straight, decoder.PixelWidth, decoder.PixelHeight, decoder.DpiX, decoder.DpiY, buffer);
                await encoder.FlushAsync();

                str = $"![这里写图片描述](image/{file.Name})";
            }
        }

        //文件
        if (con.Contains(StandardDataFormats.StorageItems))
        {
            var filelist = await con.GetStorageItemsAsync();
            StorageFile file = filelist.OfType&lt;StorageFile&gt;().First();
            return await imgfolder(file);
        }

        return str;
    } 返回string是因为要把str插入到text，需要有Textbox光标插入
</code></pre></div></div>

<p>插入文件</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    public async Task&lt;string&gt; imgfolder(StorageFile file)
    {
        string str = "image";
        StorageFolder image = null;
        try
        {
            image = await _folder.GetFolderAsync(str);
        }
        catch
        {


        }
        if (image == null)
        {
            image = await _folder.CreateFolderAsync(str, CreationCollisionOption.OpenIfExists);
        }
        file = await file.CopyAsync(image, file.Name, NameCollisionOption.GenerateUniqueName);

        if (file.FileType == ".png" || file.FileType == ".jpg")
        {
            str = $"![这里写图片描述](image/{file.Name})";
            return str;
        }
        else
        {
            str = $"[{file.Name}](image/{file.Name})";
            return str;
        }
    } 开始我没有用文件
</code></pre></div></div>

<p>拖入和剪贴板只用第一个文件</p>

<p>public async void accessfolder(StorageFolder folder)</p>

<p>更改用户位置</p>

<p>public async void storage()</p>

<p>保存</p>

<p>在程序运行</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>folder = await Windows.Storage.AccessCache.StorageApplicationPermissions.FutureAccessList.GetFolderAsync(Windows.Storage.AccessCache.StorageApplicationPermissions.FutureAccessList.Entries[0].Token);
</code></pre></div></div>

<p>viewModel.cs</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    public string text
    {
        set
        {
            _m._text = value;
            OnPropertyChanged();
        }
        get
        {
            return _m._text;
        }
    }

    public string name
    {
        set
        {
            _m._name = value;
            OnPropertyChanged();
        }
        get
        {
            return _m._name;
        }
    }
</code></pre></div></div>

<p>本来绑Textbox SelectionStart</p>

<p>SelectionStart错误</p>

<p>要用SelectionStart，只能public Action&lt;int, int&gt; selectchange;</p>

<p>在MainPage.xaml.cs</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    private void selectchange(int select, int selecti)
    {
        text.SelectionStart = select;
        text.SelectionLength = selecti;
    }
</code></pre></div></div>

<p>因为选择可以把<code class="language-plaintext highlighter-rouge">![这里写图片描述](image/{file.Name})</code></p>

<p><img src="image/201619156.png" alt="这里写图片描述" /></p>

<p>select Textbox选择的插入</p>

<p>clipboard 保存剪贴板</p>

<p>storage 保存</p>

<p>accessfolder 更改用户位置</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    public async void accessfolder()
    {
        FolderPicker pick = new FolderPicker();
        pick.FileTypeFilter.Add("*");
        StorageFolder folder = await pick.PickSingleFolderAsync();
        if (folder != null)
        {
            _m.accessfolder(folder);
        }
        addressfolder = string.Empty;
    }
</code></pre></div></div>

<p>model _m</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    private void tianjia(string str)
</code></pre></div></div>

<p>把str添加text</p>

<p>MainPage.xaml</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;Grid Background="{ThemeResource ApplicationPageBackgroundThemeBrush}" AllowDrop="True" Drop="{x:Bind view.dropimg}" DragOver="Grid_DragOver"&gt;
    &lt;Grid.RowDefinitions&gt;
        &lt;RowDefinition Height="auto"/&gt;
        &lt;RowDefinition /&gt;
        &lt;RowDefinition Height="auto"/&gt;
    &lt;/Grid.RowDefinitions&gt;
    &lt;TextBox Text="{x:Bind view.name,Mode=TwoWay}" Grid.Row="0" Margin="10,10,10,10"/&gt;
    &lt;TextBox x:Name="text" Text="{Binding Path=text,Mode=TwoWay,UpdateSourceTrigger=PropertyChanged}" Margin="10,10,10,10" Grid.Row="1" TextWrapping="Wrap" AcceptsReturn="True" IsReadOnly="{x:Bind view.writetext,Mode=OneWay}" SelectionChanged="text_SelectionChanged"/&gt;
    &lt;!--&lt;RichEditBox x:Name="rtext" Margin="10,10,10,10"/&gt;--&gt;

    &lt;TextBlock Text="{x:Bind view.reminder,Mode=OneWay}" Grid.Row="2" Margin="10,10,10,10" TextWrapping="Wrap"/&gt;
    &lt;!--&lt;Button Content="确定" Click="{x:Bind view.property}" Margin="121,300,0,308"/&gt;--&gt;
&lt;/Grid&gt;
&lt;Page.TopAppBar&gt;
    &lt;CommandBar&gt;
        &lt;!--&lt;AppBarButton Icon="Add" Content="新建" Click="{x:Bind view.fileaddress}"/&gt;--&gt;
        &lt;AppBarButton Icon="OpenFile" Content="打开" Click="{x:Bind view.file_open}" /&gt;
        &lt;AppBarButton Icon="Save" Content="保存" Click="{x:Bind view.storage}"/&gt;
        &lt;AppBarButton Icon="Setting" Content="设置" Click="option"/&gt;
    &lt;/CommandBar&gt;
&lt;/Page.TopAppBar&gt;



public sealed partial class MainPage
{
    viewModel view;
    public MainPage()
    {            
        this.InitializeComponent();
        text.Paste += Text_Paste;
    }

    private void Text_Paste(object sender, TextControlPasteEventArgs e)
    {
        view.clipboard(e);
    }

    private void Grid_DragOver(object sender, DragEventArgs e)
    {
        e.AcceptedOperation = Windows.ApplicationModel.DataTransfer.DataPackageOperation.Copy;
        e.DragUIOverride.Caption = "打开";
        e.Handled = true;
    }

    private void text_SelectionChanged(object sender, RoutedEventArgs e)
    {
        view.select = text.SelectionStart;
    }

    private void selectchange(int select, int selecti)
    {
        text.SelectionStart = select;
        text.SelectionLength = selecti;
    }

    private bool _ctrl;

    private void text_KeyDown(object sender, KeyRoutedEventArgs e)
    {
        if (e.Key.Equals(Windows.System.VirtualKey.Control))
        {
            _ctrl = true;
        }
        else if (e.Key == Windows.System.VirtualKey.V &amp;&amp; _ctrl)
        {

        }

        if (_ctrl)
        {
            if (e.Key == Windows.System.VirtualKey.Z)
            {

            }
        }

        e.Handled = true;
    }

    private void text_KeyUp(object sender, KeyRoutedEventArgs e)
    {
        if (e.Key.Equals(Windows.System.VirtualKey.Control))
        {
            _ctrl = false;
        }
    }

    private void option(object sender, RoutedEventArgs e)
    {
        view.storage();
        Frame frame = Window.Current.Content as Frame;
        frame.Navigate(typeof(option), view);
    }

    protected override void OnNavigatedTo(NavigationEventArgs e)
    {
        base.OnNavigatedTo(e);
        if (e.Parameter is viewModel)
        {
            view = e.Parameter as viewModel;
            DataContext = view;
        }
        else
        {
            view = new viewModel();
            view.selectchange = selectchange;               
            this.DataContext = view;
        }

    }
}
</code></pre></div></div>

<p><img src="image/2016191510.png" alt="这里写图片描述" /></p>

<h2 id="发布">发布</h2>

<p>https://dev.windows.com/zh-cn</p>

<p>登录</p>

<p><img src="image/2016191514.png" alt="这里写图片描述" /></p>

<p><img src="image/2016191515.png" alt="这里写图片描述" /></p>

<p>在我的应用</p>

<p><img src="image/2016191515 (2).png" alt="这里写图片描述" /></p>

<p>填名字</p>

<p><img src="image/2016191515 (3).png" alt="这里写图片描述" /></p>

<p>本来想写Markdown</p>

<p>不过自己做的不是很好，不敢，就写win</p>

<p>有人发了Markdown应用</p>

<p><img src="image/2016191517.png" alt="这里写图片描述" /></p>

<p>点击开始提交</p>

<p><img src="image/2016191518.png" alt="这里写图片描述" /></p>

<p>价格免费</p>

<p><img src="image/2016191519.png" alt="这里写图片描述" /></p>

<p>在visual studio</p>

<p><img src="image/2016191520.png" alt="这里写图片描述" /></p>

<p>关联</p>

<p><img src="image/2016191521.png" alt="这里写图片描述" /></p>

<p><img src="image/2016191521 (2).png" alt="这里写图片描述" /></p>

<p><img src="image/2016191522.png" alt="这里写图片描述" /></p>

<p>选择创建的Markdown</p>

<p><img src="image/2016191524.png" alt="这里写图片描述" /></p>

<p>得到</p>

<p>produproperty_StoreKey.pfx</p>

<p>在属性</p>

<p><img src="image/2016191525.png" alt="这里写图片描述" /></p>

<p>没有密码</p>

<p><img src="image/2016191526.png" alt="这里写图片描述" /></p>

<p><img src="image/2016191526 (2).png" alt="这里写图片描述" /></p>

<p><img src="image/2016191527.png" alt="这里写图片描述" /></p>

<p><img src="image/2016191527 (2).png" alt="这里写图片描述" /></p>

<p>配置</p>

<p><img src="image/2016191528.png" alt="这里写图片描述" /></p>

<p><img src="image/2016191531.png" alt="这里写图片描述" /></p>

<p>把produproperty_1.1.0.0_x86_x64_arm_bundle.appxupload上传</p>

<p><img src="image/2016191532.png" alt="这里写图片描述" /></p>

<p><img src="image/2016191534.png" alt="这里写图片描述" /></p>

<p><img src="image/2016191535.png" alt="这里写图片描述" /></p>

<p><img src="image/2016191538.png" alt="这里写图片描述" /></p>

<p><img src="image/2016191538 (2).png" alt="这里写图片描述" /></p>

:ET