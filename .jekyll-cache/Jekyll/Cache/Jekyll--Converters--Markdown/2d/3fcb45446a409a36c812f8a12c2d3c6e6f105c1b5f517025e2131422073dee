I"<p>本文将告诉大家一个黑科技方法在运行时动态获取对象本身占用空间，不包括对象引用的其他对象的空间大小的方法</p>

<!--more-->

<!-- CreateTime:2021/4/27 21:15:57 -->

<!-- 发布 -->

<p>此方法是在开源仓库 <a href="https://github.com/sidristij/dotnetex">sidristij/dotnetex: Gets size of .Net Framework objects, can change type of object to incompatible and can alloc .Net objects at unmanaged memory area</a> 找到的方法</p>

<p>通过不安全代码和反射获取对象类型的 MethodTableInfo 即可在 MethodTableInfo 里面读取 Size 属性，关于 MethodTableInfo 的定义如下</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        <span class="c1">/// &lt;summary&gt;</span>
        <span class="c1">/// Description of GCEnumerator.</span>
        <span class="c1">/// &lt;/summary&gt;</span>
        <span class="p">[</span><span class="nf">StructLayout</span><span class="p">(</span><span class="n">LayoutKind</span><span class="p">.</span><span class="n">Explicit</span><span class="p">)]</span>
        <span class="k">public</span> <span class="k">unsafe</span> <span class="k">struct</span> <span class="nc">MethodTableInfo</span>
        <span class="p">{</span>
            <span class="err">#</span><span class="n">region</span> <span class="n">Basic</span> <span class="n">Type</span> <span class="n">Info</span>

            <span class="p">[</span><span class="nf">FieldOffset</span><span class="p">(</span><span class="m">0</span><span class="p">)]</span>
            <span class="k">public</span> <span class="n">MethodTableFlags</span> <span class="n">Flags</span><span class="p">;</span>

            <span class="p">[</span><span class="nf">FieldOffset</span><span class="p">(</span><span class="m">4</span><span class="p">)]</span>
            <span class="k">public</span> <span class="kt">int</span> <span class="n">Size</span><span class="p">;</span>

            <span class="p">[</span><span class="nf">FieldOffset</span><span class="p">(</span><span class="m">8</span><span class="p">)]</span>
            <span class="k">public</span> <span class="kt">short</span> <span class="n">AdditionalFlags</span><span class="p">;</span>

            <span class="p">[</span><span class="nf">FieldOffset</span><span class="p">(</span><span class="m">10</span><span class="p">)]</span>
            <span class="k">public</span> <span class="kt">short</span> <span class="n">MethodsCount</span><span class="p">;</span>

            <span class="p">[</span><span class="nf">FieldOffset</span><span class="p">(</span><span class="m">12</span><span class="p">)]</span>
            <span class="k">public</span> <span class="kt">short</span> <span class="n">VirtMethodsCount</span><span class="p">;</span>

            <span class="p">[</span><span class="nf">FieldOffset</span><span class="p">(</span><span class="m">14</span><span class="p">)]</span>
            <span class="k">public</span> <span class="kt">short</span> <span class="n">InterfacesCount</span><span class="p">;</span>

            <span class="p">[</span><span class="nf">FieldOffset</span><span class="p">(</span><span class="m">16</span><span class="p">)]</span>
            <span class="k">public</span> <span class="n">MethodTableInfo</span><span class="p">*</span> <span class="n">ParentTable</span><span class="p">;</span>

            <span class="err">#</span><span class="n">endregion</span>

            <span class="p">[</span><span class="nf">FieldOffset</span><span class="p">(</span><span class="m">20</span><span class="p">)]</span>
            <span class="k">public</span> <span class="n">ObjectTypeInfo</span><span class="p">*</span> <span class="n">ModuleInfo</span><span class="p">;</span>

            <span class="p">[</span><span class="nf">FieldOffset</span><span class="p">(</span><span class="m">24</span><span class="p">)]</span>
            <span class="k">public</span> <span class="n">ObjectTypeInfo</span><span class="p">*</span> <span class="n">EEClass</span><span class="p">;</span>
        <span class="p">}</span>
</code></pre></div></div>

<p>以上代码关键属性是 Size 属性，通过 Size 属性可以拿到运行时的对象占用空间大小。在 CLR 里面默认将会做内存的对齐，因此对象占用空间大小将会大于等于字段占用空间大小的总数</p>

<p>获取某类型对象占用空间大小的方法如下</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        <span class="k">public</span> <span class="k">static</span> <span class="k">unsafe</span> <span class="n">Int32</span> <span class="n">SizeOf</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;()</span>
        <span class="p">{</span>
            <span class="k">return</span> <span class="p">((</span><span class="n">MethodTableInfo</span><span class="p">*)(</span><span class="k">typeof</span><span class="p">(</span><span class="n">T</span><span class="p">).</span><span class="n">TypeHandle</span><span class="p">.</span><span class="n">Value</span><span class="p">.</span><span class="nf">ToPointer</span><span class="p">()))-&gt;</span><span class="n">Size</span><span class="p">;</span>
        <span class="p">}</span>
</code></pre></div></div>

<p>本文所有代码放在 <a href="https://github.com/lindexi/lindexi_gd/tree/b4784765aae3a9ea35547fff620305966c750c05/HaynogelwhaiFaycemferlerluja">github</a> 和 <a href="https://gitee.com/lindexi/lindexi_gd/tree/b4784765aae3a9ea35547fff620305966c750c05/HaynogelwhaiFaycemferlerluja">gitee</a> 欢迎小伙伴访问</p>

<p>本文的这个方法获取到的对象内存具体是什么？还请看 伟民哥翻译的 《.NET内存管理宝典 - 提高代码质量、性能和可扩展性》 这本书</p>

:ET