I":(<p>本文简单告诉大家如何在 .NET Core 里面使用 AOP 切面编程，使用 DispatchProxy 做任意接口的动态代理实现</p>

<!--more-->

<!-- CreateTime:6/20/2020 5:49:44 PM -->

<p>使用 DispatchProxy 有一些限制，如只能创建接口的实例。使用 DispatchProxy 可以让咱做到从无中创建出某个实例，这个实例继承咱想要的接口</p>

<p>首先需要创建某个动态代理类继承 DispatchProxy 类，例如创建 Foo 类。此时需要实现 Invoke 接口，这个接口的含义是当代码调用接口里面的函数，包括属性的设置和获取函数的时候将会进入 Invoke 方法</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        <span class="k">protected</span> <span class="k">override</span> <span class="kt">object</span> <span class="nf">Invoke</span><span class="p">(</span><span class="n">MethodInfo</span> <span class="n">targetMethod</span><span class="p">,</span> <span class="kt">object</span><span class="p">[]</span> <span class="n">args</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="c1">// 忽略代码</span>
        <span class="p">}</span>
</code></pre></div></div>

<p>因此通过 Invoke 方法可以假装自己是对应的接口的实现，可以进行随意更改执行逻辑以及修改返回值</p>

<p>而 DispatchProxy 另一个核心方法是静态的 Create 方法，这个方法要求传入两个泛形，第一个类型是想要创建出来的实例继承的接口，第二个类型是某个继承 DispatchProxy 的类</p>

<p>例如咱定义了一个 IF1 的接口，此时可以在 Foo 添加如下代码创建出一个不存在的类型实例，这个实例继承了 IF1 接口</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="k">public</span> <span class="k">class</span> <span class="nc">Foo</span> <span class="p">:</span> <span class="n">DispatchProxy</span>
    <span class="p">{</span>
        <span class="k">public</span> <span class="k">static</span> <span class="n">T</span> <span class="n">GetObject</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;()</span>
        <span class="p">{</span>
            <span class="k">return</span> <span class="n">DispatchProxy</span><span class="p">.</span><span class="n">Create</span><span class="p">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">Foo</span><span class="p">&gt;();</span>
        <span class="p">}</span>

        <span class="k">protected</span> <span class="k">override</span> <span class="kt">object</span> <span class="nf">Invoke</span><span class="p">(</span><span class="n">MethodInfo</span> <span class="n">targetMethod</span><span class="p">,</span> <span class="kt">object</span><span class="p">[]</span> <span class="n">args</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">return</span> <span class="s">"lindexi"</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
</code></pre></div></div>

<p>假设 IF1 的定义如下</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="k">interface</span> <span class="nc">IF1</span>
    <span class="p">{</span>
        <span class="kt">string</span> <span class="nf">F2</span><span class="p">();</span>
    <span class="p">}</span>
</code></pre></div></div>

<p>此时的使用方法如下</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>            <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="n">Foo</span><span class="p">.</span><span class="n">GetObject</span><span class="p">&lt;</span><span class="n">IF1</span><span class="p">&gt;().</span><span class="nf">F2</span><span class="p">());</span>
</code></pre></div></div>

<p>执行代码可以看到输出了 <code class="language-plaintext highlighter-rouge">lindexi</code> 也就是实际调用了 Foo 方法</p>

<p>可以看到 DispatchProxy 的作用就是提供静态方法用于创建继承指定接口的对象，同时让继承 DispatchProxy 的类可以拿到接口所调用的方法，用来修改执行逻辑和返回值</p>

<p>一个实际的使用的例子，提供了调用某个对象的每个方法之前给这个对象调用方法记日志，这是最简便的记日志的方法了，尽管性能很渣</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="k">public</span> <span class="k">class</span> <span class="nc">LoggingAdvice</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="p">:</span> <span class="n">DispatchProxy</span>
    <span class="p">{</span>
        <span class="k">private</span> <span class="n">T</span> <span class="n">Object</span> <span class="p">{</span> <span class="k">set</span><span class="p">;</span> <span class="k">get</span><span class="p">;</span> <span class="p">}</span>


        <span class="k">public</span> <span class="k">static</span> <span class="n">T</span> <span class="nf">CreateLogging</span><span class="p">(</span><span class="n">Func</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="n">creator</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="kt">object</span> <span class="n">proxy</span> <span class="p">=</span> <span class="n">DispatchProxy</span><span class="p">.</span><span class="n">Create</span><span class="p">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">LoggingAdvice</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;&gt;();</span>
            <span class="p">((</span><span class="n">LoggingAdvice</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;)</span><span class="n">proxy</span><span class="p">).</span><span class="n">Object</span> <span class="p">=</span> <span class="nf">creator</span><span class="p">();</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">T</span><span class="p">)</span><span class="n">proxy</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">protected</span> <span class="k">override</span> <span class="kt">object</span> <span class="nf">Invoke</span><span class="p">(</span><span class="n">MethodInfo</span> <span class="n">targetMethod</span><span class="p">,</span> <span class="kt">object</span><span class="p">[]</span> <span class="n">args</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="s">$"开始执行 </span><span class="p">{</span><span class="n">targetMethod</span><span class="p">.</span><span class="n">Name</span><span class="p">}</span><span class="s">"</span><span class="p">);</span>

            <span class="kt">var</span> <span class="n">result</span> <span class="p">=</span> <span class="n">targetMethod</span><span class="p">.</span><span class="nf">Invoke</span><span class="p">(</span><span class="n">Object</span><span class="p">,</span> <span class="n">args</span><span class="p">);</span>

            <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="s">$"执行完成 </span><span class="p">{</span><span class="n">targetMethod</span><span class="p">.</span><span class="n">Name</span><span class="p">}</span><span class="s">"</span><span class="p">);</span>

            <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
</code></pre></div></div>

<p>此时就能做到在方法执行前后添加日志，如这里有一个接口和一个类，使用方法请参考以下示例</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="k">class</span> <span class="nc">Program</span>
    <span class="p">{</span>
        <span class="k">static</span> <span class="k">void</span> <span class="nf">Main</span><span class="p">(</span><span class="kt">string</span><span class="p">[]</span> <span class="n">args</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="kt">var</span> <span class="n">foo</span> <span class="p">=</span> <span class="n">LoggingAdvice</span><span class="p">&lt;</span><span class="n">IF1</span><span class="p">&gt;.</span><span class="nf">CreateLogging</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="k">new</span> <span class="nf">Foo</span><span class="p">());</span>
            <span class="n">foo</span><span class="p">.</span><span class="nf">F2</span><span class="p">();</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">interface</span> <span class="nc">IF1</span>
    <span class="p">{</span>
        <span class="kt">string</span> <span class="nf">F2</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="k">class</span> <span class="nc">Foo</span> <span class="p">:</span> <span class="n">IF1</span>
    <span class="p">{</span>
        <span class="c1">/// &lt;inheritdoc /&gt;</span>
        <span class="k">public</span> <span class="kt">string</span> <span class="nf">F2</span><span class="p">()</span>
        <span class="p">{</span>
            <span class="k">return</span> <span class="s">"lindexi"</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
</code></pre></div></div>

<p>参考</p>

<p><a href="https://www.cnblogs.com/lwqlun/p/11575686.html">在.NET Core中使用DispatchProxy“实现”非公开的接口 - LamondLu - 博客园</a></p>

<p><a href="https://www.cnblogs.com/oyang168/p/11853851.html">使用.net core中的类DispatchProxy实现AOP - 欧阳.NET - 博客园</a></p>

:ET