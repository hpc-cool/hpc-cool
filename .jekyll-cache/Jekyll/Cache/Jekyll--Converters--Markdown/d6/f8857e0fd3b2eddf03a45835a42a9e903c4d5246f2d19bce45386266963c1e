I"24<p>很多逻辑都会使用内存做缓存，这样可以提高运行效率。但是有一些逻辑很少会执行，但是如果有执行就是频繁调用。如我写了文本编辑器，在我打开文件的逻辑，将会不断调用正则判断逻辑，而平时编辑很少会调用。如果将这部分的正则逻辑缓存了，那么可以提升打开文件速度，但是在打开文件之后这部分就成为内存垃圾了。本文给大家一个弱引用缓存，也就是在频繁使用时从内存获取，在不使用时会被回收，这样可以提升性能也能减少内存使用</p>

<!--more-->

<!-- CreateTime:2019/11/7 9:45:05 -->

<!-- csdn -->

<p>因为作为缓存，如果需要考虑线程安全，那么这部分的逻辑就复杂了。在不考虑线程安全下，开发一个弱引用缓存还是很简单</p>

<p>首先是创建一个字典，这个字典包含弱引用，这样在获取之前可以先从字典获取</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        <span class="k">private</span> <span class="k">readonly</span> <span class="n">Dictionary</span><span class="p">&lt;</span><span class="kt">object</span><span class="p">,</span> <span class="n">WeakReference</span><span class="p">&lt;</span><span class="kt">object</span><span class="p">&gt;&gt;</span> <span class="n">_cacheList</span> <span class="p">=</span>
            <span class="k">new</span> <span class="n">Dictionary</span><span class="p">&lt;</span><span class="kt">object</span><span class="p">,</span> <span class="n">WeakReference</span><span class="p">&lt;</span><span class="kt">object</span><span class="p">&gt;&gt;();</span>
</code></pre></div></div>

<p>在用户获取之前，需要知道，可能内存回收了。所以使用方法是获取或创建，也就是这个方法不能保证只有第一次获取时才创建，而是看内存回收</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="k">public</span> <span class="n">T</span> <span class="n">GetOrCreate</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;(</span><span class="kt">object</span> <span class="n">key</span><span class="p">,</span> <span class="n">Func</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="n">createFunc</span><span class="p">)</span>
</code></pre></div></div>

<p>如果此时可以从内存获取，那么直接返回</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>            <span class="k">if</span> <span class="p">(</span><span class="n">_cacheList</span><span class="p">.</span><span class="nf">TryGetValue</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="k">out</span> <span class="kt">var</span> <span class="n">weakReference</span><span class="p">))</span>
            <span class="p">{</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">weakReference</span><span class="p">.</span><span class="nf">TryGetTarget</span><span class="p">(</span><span class="k">out</span> <span class="kt">var</span> <span class="k">value</span><span class="p">))</span>
                <span class="p">{</span>
                    <span class="k">return</span> <span class="p">(</span><span class="n">T</span><span class="p">)</span> <span class="k">value</span><span class="p">;</span>
                <span class="p">}</span>
            <span class="p">}</span>
</code></pre></div></div>

<p>如果不能从内存获取，就需要调用方法创建</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>            <span class="kt">var</span> <span class="n">t</span> <span class="p">=</span> <span class="nf">createFunc</span><span class="p">();</span>
            <span class="n">weakReference</span> <span class="p">=</span> <span class="k">new</span> <span class="n">WeakReference</span><span class="p">&lt;</span><span class="kt">object</span><span class="p">&gt;(</span><span class="n">t</span><span class="p">);</span>
            <span class="n">_cacheList</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="p">=</span> <span class="n">weakReference</span><span class="p">;</span>
            <span class="k">return</span> <span class="n">t</span><span class="p">;</span>
</code></pre></div></div>

<p>所以获取方法如下</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        <span class="c1">/// &lt;summary&gt;</span>
        <span class="c1">/// 从缓存获取或在没有获取到创建</span>
        <span class="c1">/// &lt;/summary&gt;</span>
        <span class="k">public</span> <span class="n">T</span> <span class="n">GetOrCreate</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;(</span><span class="kt">object</span> <span class="n">key</span><span class="p">,</span> <span class="n">Func</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="n">createFunc</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">_cacheList</span><span class="p">.</span><span class="nf">TryGetValue</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="k">out</span> <span class="kt">var</span> <span class="n">weakReference</span><span class="p">))</span>
            <span class="p">{</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">weakReference</span><span class="p">.</span><span class="nf">TryGetTarget</span><span class="p">(</span><span class="k">out</span> <span class="kt">var</span> <span class="k">value</span><span class="p">))</span>
                <span class="p">{</span>
                    <span class="k">return</span> <span class="p">(</span><span class="n">T</span><span class="p">)</span> <span class="k">value</span><span class="p">;</span>
                <span class="p">}</span>
            <span class="p">}</span>

            <span class="kt">var</span> <span class="n">t</span> <span class="p">=</span> <span class="nf">createFunc</span><span class="p">();</span>
            <span class="n">weakReference</span> <span class="p">=</span> <span class="k">new</span> <span class="n">WeakReference</span><span class="p">&lt;</span><span class="kt">object</span><span class="p">&gt;(</span><span class="n">t</span><span class="p">);</span>
            <span class="n">_cacheList</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="p">=</span> <span class="n">weakReference</span><span class="p">;</span>
            <span class="k">return</span> <span class="n">t</span><span class="p">;</span>
        <span class="p">}</span>
</code></pre></div></div>

<p>因为每次给一个 key 也不好用，有一些对象只需要一个类只有存在一个，可以使用类型作为 key 可以再写另一个方法</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        <span class="c1">/// &lt;summary&gt;</span>
        <span class="c1">/// 从缓存获取或在没有获取到创建</span>
        <span class="c1">/// &lt;/summary&gt;</span>
        <span class="k">public</span> <span class="n">T</span> <span class="n">GetOrCreate</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;(</span><span class="n">Func</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="n">createFunc</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="kt">var</span> <span class="n">type</span> <span class="p">=</span> <span class="k">typeof</span><span class="p">(</span><span class="n">T</span><span class="p">);</span>
            <span class="k">return</span> <span class="nf">GetOrCreate</span><span class="p">(</span><span class="n">type</span><span class="p">,</span> <span class="n">createFunc</span><span class="p">);</span>
        <span class="p">}</span>
</code></pre></div></div>

<p>这个线程不安全的弱引用缓存所有代码很少，可以直接复制在项目使用</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="c1">/// &lt;summary&gt;</span>
    <span class="c1">/// 弱引用缓存</span>
    <span class="c1">/// &lt;/summary&gt;</span>
    <span class="k">public</span> <span class="k">class</span> <span class="nc">WeakReferenceCache</span>
    <span class="p">{</span>
        <span class="c1">/// &lt;summary&gt;</span>
        <span class="c1">/// 从缓存获取或在没有获取到创建</span>
        <span class="c1">/// &lt;/summary&gt;</span>
        <span class="k">public</span> <span class="n">T</span> <span class="n">GetOrCreate</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;(</span><span class="kt">object</span> <span class="n">key</span><span class="p">,</span> <span class="n">Func</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="n">createFunc</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">_cacheList</span><span class="p">.</span><span class="nf">TryGetValue</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="k">out</span> <span class="kt">var</span> <span class="n">weakReference</span><span class="p">))</span>
            <span class="p">{</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">weakReference</span><span class="p">.</span><span class="nf">TryGetTarget</span><span class="p">(</span><span class="k">out</span> <span class="kt">var</span> <span class="k">value</span><span class="p">))</span>
                <span class="p">{</span>
                    <span class="k">return</span> <span class="p">(</span><span class="n">T</span><span class="p">)</span> <span class="k">value</span><span class="p">;</span>
                <span class="p">}</span>
            <span class="p">}</span>

            <span class="kt">var</span> <span class="n">t</span> <span class="p">=</span> <span class="nf">createFunc</span><span class="p">();</span>
            <span class="n">weakReference</span> <span class="p">=</span> <span class="k">new</span> <span class="n">WeakReference</span><span class="p">&lt;</span><span class="kt">object</span><span class="p">&gt;(</span><span class="n">t</span><span class="p">);</span>
            <span class="n">_cacheList</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="p">=</span> <span class="n">weakReference</span><span class="p">;</span>
            <span class="k">return</span> <span class="n">t</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="c1">/// &lt;summary&gt;</span>
        <span class="c1">/// 从缓存获取或在没有获取到创建</span>
        <span class="c1">/// &lt;/summary&gt;</span>
        <span class="k">public</span> <span class="n">T</span> <span class="n">GetOrCreate</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;(</span><span class="n">Func</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="n">createFunc</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="kt">var</span> <span class="n">type</span> <span class="p">=</span> <span class="k">typeof</span><span class="p">(</span><span class="n">T</span><span class="p">);</span>
            <span class="k">return</span> <span class="nf">GetOrCreate</span><span class="p">(</span><span class="n">type</span><span class="p">,</span> <span class="n">createFunc</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="k">private</span> <span class="k">readonly</span> <span class="n">Dictionary</span><span class="p">&lt;</span><span class="kt">object</span><span class="p">,</span> <span class="n">WeakReference</span><span class="p">&lt;</span><span class="kt">object</span><span class="p">&gt;&gt;</span> <span class="n">_cacheList</span> <span class="p">=</span>
            <span class="k">new</span> <span class="n">Dictionary</span><span class="p">&lt;</span><span class="kt">object</span><span class="p">,</span> <span class="n">WeakReference</span><span class="p">&lt;</span><span class="kt">object</span><span class="p">&gt;&gt;();</span>
    <span class="p">}</span>
</code></pre></div></div>

<p>此方法是线程不安全的，请不要在多线程下使用此方法，可以通过 <a href="https://blog.lindexi.com/post/dotnet-%E7%BA%BF%E7%A8%8B%E9%9D%99%E6%80%81%E5%AD%97%E6%AE%B5.html">线程静态字段</a> 让一个线程有一个实例</p>

<p>本文代码放在 <a href="https://github.com/lindexi/lindexi_gd/tree/0f639d7a6334acf3c502065182c441113f24eb05/NaycekihallembeaDiwalkailedecer">github</a> 欢迎小伙伴访问</p>

:ET