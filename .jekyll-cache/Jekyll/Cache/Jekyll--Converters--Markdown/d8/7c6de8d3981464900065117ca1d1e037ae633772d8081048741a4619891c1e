I"B<p>本文是记录一个线程相互等待导致主线程无法响应的问题，这个问题是属于一定可以复现的问题，是 WPF 的已知问题。如果遇到这个问题，属于暂时没有方法解决，只能规避。
这个问题的最简单复现步骤是在触摸线程，也就是 StylusInput 线程，等待一个主线程的窗口关闭，此时就会出现主线程卡住的问题</p>

<!--more-->

<!-- CreateTime:2018/10/31 9:30:09 -->

<!-- csdn -->

<p>这个问题有两个复现方法，第一个方法属于必现的方法，第二个方法属于概率的方法</p>

<p>在开始说明问题之前需要大概讲一下 WPF 的触摸原理和这个问题的原理</p>

<h2 id="原理">原理</h2>

<p>在 WPF 触摸下，是存在 Stylus Input 线程用于处理触摸相关的事情，在这个线程会调用 ThreadProc 进入循环</p>

<!-- ![](image/WPF 在触摸线程等待主线程窗口关闭会让主线程和触摸线程相互等待/WPF 在触摸线程等待主线程窗口关闭会让主线程和触摸线程相互等待0.png) -->

<p>这个线程会调用 ThreadProc 进入循环，直到软件退出</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">void</span> <span class="nf">ThreadProc</span><span class="p">()</span>
<span class="p">{</span>

<span class="p">}</span>
</code></pre></div></div>

<p>在 ThreadProc 里面有两次循环，第一层循环是处理添加或移除 PenContext 等，第二层循环是进入 PENIMC 这个库卡住，直到释放线程锁 <code class="language-plaintext highlighter-rouge">_pimcResetHandle</code> 或用户触摸才继续</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">void</span> <span class="nf">ThreadProc</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">while</span> <span class="p">(!</span><span class="n">__disposed</span><span class="p">)</span>
    <span class="p">{</span>
    	<span class="c1">// 第一层循环</span>
    	<span class="c1">// 处理 PenContext 的添加或移除等的代码</span>

    	<span class="k">while</span> <span class="p">(</span><span class="k">true</span><span class="p">)</span>
    	<span class="p">{</span>
    		<span class="c1">// 第二层循环，用于处理用户的触摸</span>
    		<span class="k">if</span><span class="p">(!</span><span class="n">Penimc</span><span class="p">.</span><span class="n">UnsafeNativeMethods</span><span class="p">.</span><span class="nf">GetPenEvent</span><span class="p">(</span><span class="cm">/*等待 _pimcResetHandle 释放，或用户触摸*/</span><span class="p">))</span>
    		<span class="p">{</span>
    			<span class="c1">// 如果是 _pimcResetHandle 被释放，则跳出第二层循环</span>
    			<span class="k">break</span><span class="p">;</span>
    		<span class="p">}</span>

    		<span class="nf">FireEvent</span><span class="p">(</span><span class="cm">/*触发触摸消息*/</span><span class="p">);</span>
    	<span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>在窗口关闭的时候，需要调用 <code class="language-plaintext highlighter-rouge">HwndSource.DisposeStylusInputProvider</code> 关闭窗口的触摸，这时的调用堆栈是从消息到 <code class="language-plaintext highlighter-rouge">PenContext.Disable</code> 方法</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code> 	<span class="n">PresentationCore</span><span class="p">.</span><span class="n">dll</span><span class="p">!</span><span class="n">System</span><span class="p">.</span><span class="n">Windows</span><span class="p">.</span><span class="n">Input</span><span class="p">.</span><span class="n">PenThreadWorker</span><span class="p">.</span><span class="nf">WorkerRemovePenContext</span><span class="p">(</span><span class="n">System</span><span class="p">.</span><span class="n">Windows</span><span class="p">.</span><span class="n">Input</span><span class="p">.</span><span class="n">PenContext</span> <span class="n">penContext</span><span class="p">)</span> 
	<span class="n">PresentationCore</span><span class="p">.</span><span class="n">dll</span><span class="p">!</span><span class="n">System</span><span class="p">.</span><span class="n">Windows</span><span class="p">.</span><span class="n">Input</span><span class="p">.</span><span class="n">PenContext</span><span class="p">.</span><span class="nf">Disable</span><span class="p">(</span><span class="kt">bool</span> <span class="n">shutdownWorkerThread</span><span class="p">)</span> 
 	<span class="n">PresentationCore</span><span class="p">.</span><span class="n">dll</span><span class="p">!</span><span class="n">System</span><span class="p">.</span><span class="n">Windows</span><span class="p">.</span><span class="n">Input</span><span class="p">.</span><span class="n">PenContexts</span><span class="p">.</span><span class="nf">Disable</span><span class="p">(</span><span class="kt">bool</span> <span class="n">shutdownWorkerThread</span><span class="p">)</span> 
 	<span class="n">PresentationCore</span><span class="p">.</span><span class="n">dll</span><span class="p">!</span><span class="n">System</span><span class="p">.</span><span class="n">Windows</span><span class="p">.</span><span class="n">Input</span><span class="p">.</span><span class="n">StylusWisp</span><span class="p">.</span><span class="n">WispLogic</span><span class="p">.</span><span class="nf">UnRegisterHwndForInput</span><span class="p">(</span><span class="n">System</span><span class="p">.</span><span class="n">Windows</span><span class="p">.</span><span class="n">Interop</span><span class="p">.</span><span class="n">HwndSource</span> <span class="n">hwndSource</span><span class="p">)</span> 
 	<span class="n">PresentationCore</span><span class="p">.</span><span class="n">dll</span><span class="p">!</span><span class="n">System</span><span class="p">.</span><span class="n">Windows</span><span class="p">.</span><span class="n">Interop</span><span class="p">.</span><span class="n">HwndStylusInputProvider</span><span class="p">.</span><span class="nf">Dispose</span><span class="p">()</span> 
</code></pre></div></div>

<p>先来看一下 <code class="language-plaintext highlighter-rouge">PenThreadWorker.WorkerRemovePenContext</code> 的代码</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="k">internal</span> <span class="kt">bool</span> <span class="nf">WorkerRemovePenContext</span><span class="p">(</span><span class="n">PenContext</span> <span class="n">penContext</span><span class="p">)</span>
    <span class="p">{</span>

      <span class="kt">var</span> <span class="n">operationRemoveContext</span> <span class="p">=</span> <span class="k">new</span> <span class="n">PenThreadWorker</span><span class="p">.</span><span class="nf">WorkerOperationRemoveContext</span><span class="p">(</span><span class="n">penContext</span><span class="p">,</span> <span class="k">this</span><span class="p">);</span>
     
      <span class="n">_workerOperation</span><span class="p">.</span><span class="nf">Add</span><span class="p">((</span><span class="n">PenThreadWorker</span><span class="p">.</span><span class="n">WorkerOperation</span><span class="p">)</span> <span class="n">operationRemoveContext</span><span class="p">);</span>
      <span class="c1">// 释放 _pimcResetHandle 锁</span>
      <span class="n">UnsafeNativeMethods</span><span class="p">.</span><span class="nf">RaiseResetEvent</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="n">_pimcResetHandle</span><span class="p">.</span><span class="n">Value</span><span class="p">);</span>
      <span class="c1">// 等待任务完成</span>
      <span class="n">operationRemoveContext</span><span class="p">.</span><span class="n">DoneEvent</span><span class="p">.</span><span class="nf">WaitOne</span><span class="p">();</span>
      <span class="n">operationRemoveContext</span><span class="p">.</span><span class="n">DoneEvent</span><span class="p">.</span><span class="nf">Close</span><span class="p">();</span>
      <span class="k">return</span> <span class="n">operationRemoveContext</span><span class="p">.</span><span class="n">Result</span><span class="p">;</span>
    <span class="p">}</span>
</code></pre></div></div>

<p>从上面的代码可以看到，主线程需要等待 WorkerOperationRemoveContext 运行完成，而 WorkerOperationRemoveContext 需要在 Stylus Input 线程运行</p>

<p>这就是关闭窗口可能出现的主线程卡住问题，只要主线程等待没有完成，主线程就会一直等待</p>

<h2 id="方法一">方法一</h2>

<p>添加一个 StylusPlugIn 同时在 StylusPlugIn 的 Up 方法等待一个窗口的关闭</p>

<p>在代码添加一个窗口类，这个窗口类是一个空白的窗口</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="k">public</span> <span class="k">class</span> <span class="nc">FooWindow</span> <span class="p">:</span> <span class="n">Window</span>
    <span class="p">{</span>

    <span class="p">}</span>
</code></pre></div></div>

<p>然后创建一个类 FooStylusPlugIn 继承 StylusPlugIn 类，重写 OnStylusUp 方法，在这个方法等待传入的 FooWindow 关闭</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   <span class="k">public</span> <span class="k">class</span> <span class="nc">FooStylusPlugIn</span> <span class="p">:</span> <span class="n">StylusPlugIn</span>
    <span class="p">{</span>
        <span class="k">public</span> <span class="nf">FooStylusPlugIn</span><span class="p">(</span><span class="n">FooWindow</span> <span class="n">fooWindow</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">FooWindow</span> <span class="p">=</span> <span class="n">fooWindow</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">public</span> <span class="n">FooWindow</span> <span class="n">FooWindow</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="p">}</span>

        <span class="c1">/// &lt;inheritdoc /&gt;</span>
        <span class="k">protected</span> <span class="k">override</span> <span class="k">void</span> <span class="nf">OnStylusUp</span><span class="p">(</span><span class="n">RawStylusInput</span> <span class="n">rawStylusInput</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">FooWindow</span><span class="p">.</span><span class="n">Dispatcher</span><span class="p">.</span><span class="nf">Invoke</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="n">FooWindow</span><span class="p">.</span><span class="nf">Close</span><span class="p">());</span>
            <span class="k">base</span><span class="p">.</span><span class="nf">OnStylusUp</span><span class="p">(</span><span class="n">rawStylusInput</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
</code></pre></div></div>

<p>在主窗口创建 FooWindow 和 FooStylusPlugIn 同时在前台放一个按钮，放一个按钮可以知道当前的主线程是否无法点击</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   <span class="k">public</span> <span class="k">partial</span> <span class="k">class</span> <span class="nc">MainWindow</span> <span class="p">:</span> <span class="n">Window</span>
    <span class="p">{</span>
        <span class="k">public</span> <span class="nf">MainWindow</span><span class="p">()</span>
        <span class="p">{</span>
            <span class="nf">InitializeComponent</span><span class="p">();</span>
            <span class="n">_fooWindow</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">FooWindow</span><span class="p">();</span>
            <span class="n">StylusPlugIns</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="k">new</span> <span class="nf">FooStylusPlugIn</span><span class="p">(</span><span class="n">_fooWindow</span><span class="p">));</span>
            <span class="n">_fooWindow</span><span class="p">.</span><span class="nf">Show</span><span class="p">();</span>
        <span class="p">}</span>

        <span class="k">private</span> <span class="k">void</span> <span class="nf">Button_OnClick</span><span class="p">(</span><span class="kt">object</span> <span class="n">sender</span><span class="p">,</span> <span class="n">RoutedEventArgs</span> <span class="n">e</span><span class="p">)</span>
        <span class="p">{</span>
        <span class="p">}</span>

        <span class="k">private</span> <span class="n">FooWindow</span> <span class="n">_fooWindow</span><span class="p">;</span>
    <span class="p">}</span>
</code></pre></div></div>

<p>这时运行代码触摸一下屏幕就会发现主窗口的按钮无法点击</p>

<p>因为在 FooStylusPlugIn 的 OnStylusUp 属于 Stylus Input 线程，执行的方法在 ThreadProc 的 FireEvent 里，而处理窗口关闭的时候需要调用 WorkerOperationRemoveContext 也需要在 Stylus Input 线程运行。</p>

<p>在主线程需要等待触摸线程运行移除 PenContext 代码，触摸线程需要等待主线程关闭窗口，这时两个线程就无响应</p>

<p>所有的代码在 <a href="https://github.com/dotnet-campus/wpf-issues/tree/master/MainThreadDeadlockWithStylusInputThread/MainThreadDeadlockWhenTouchThreadWaitForWindowClosed">github</a></p>

<h2 id="方法二">方法二</h2>

<p>在触摸触发的过程中，出现了窗口的关闭，会让主线程卡住</p>

<p>和方法一不同的是，方法一会让触摸线程和主线程同时卡住，方法二只会让主线程卡住</p>

<p>从原理上可以知道，窗口关闭需要移除 PenContext 需要在触摸线程的第一层循环运行。但是在触摸的过程，触摸线程运行到第二层循环里。</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">void</span> <span class="nf">ThreadProc</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">while</span> <span class="p">(!</span><span class="n">__disposed</span><span class="p">)</span>
    <span class="p">{</span>
    	<span class="c1">// 第一层循环</span>
    	<span class="c1">// 处理 PenContext 的添加或移除等的代码</span>
    	<span class="c1">// 主线程需要等待这里的代码运行完成</span>
    	<span class="nf">RemovePenContext</span><span class="p">();</span>

    	<span class="k">while</span> <span class="p">(</span><span class="k">true</span><span class="p">)</span>
    	<span class="p">{</span>
    		<span class="c1">// 第二层循环，用于处理用户的触摸</span>
    		<span class="k">if</span><span class="p">(!</span><span class="n">Penimc</span><span class="p">.</span><span class="n">UnsafeNativeMethods</span><span class="p">.</span><span class="nf">GetPenEvent</span><span class="p">(</span><span class="cm">/*等待 _pimcResetHandle 释放，或用户触摸*/</span><span class="p">))</span>
    		<span class="p">{</span>
    			<span class="c1">// 如果是 _pimcResetHandle 被释放，则跳出第二层循环</span>
    			<span class="k">break</span><span class="p">;</span>
    		<span class="p">}</span>

    		<span class="nf">FireEvent</span><span class="p">(</span><span class="cm">/*触发触摸消息*/</span><span class="p">);</span> <span class="c1">// 当前触摸线程运行到这里</span>
    	<span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>在没有出现触摸的时候，触摸线程会在 <code class="language-plaintext highlighter-rouge">Penimc.UnsafeNativeMethods.GetPenEvent</code> 卡住</p>

<p>主线程通过释放 <code class="language-plaintext highlighter-rouge">_pimcResetHandle</code> 锁运行 RemovePenContext 代码</p>

<p>触摸线程在运行到 FireEvent 不需要等待<code class="language-plaintext highlighter-rouge">_pimcResetHandle</code>就无法到第一层循环，主线程无法等到触摸线程移除 PenContext 主线程卡住</p>

<p>其他请看 <a href="https://huchengv5.gitee.io/post/WPF-%E7%95%8C%E9%9D%A2%E5%BC%82%E5%B8%B8%E5%8D%A1%E6%AD%BB-Dispatcher%E7%9A%84%E6%AD%BB%E9%94%81.html">WPF 界面异常卡死？Dispatcher的死锁</a></p>

<p>更多触摸请看 <a href="https://blog.lindexi.com/post/WPF-%E8%A7%A6%E6%91%B8%E7%9B%B8%E5%85%B3.html">WPF 触摸相关</a></p>

:ET