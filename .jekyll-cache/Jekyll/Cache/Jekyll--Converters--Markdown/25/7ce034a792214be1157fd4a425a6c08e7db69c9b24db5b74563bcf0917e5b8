I"!n<p>本文来和大家聊聊在 WPF 里面在给 ResourceDictionary 设置 Source 属性时，在 WPF 框架里面做了哪些逻辑</p>

<!--more-->

<!-- CreateTime:2020/11/25 14:22:23 -->

<p>默认添加 Source 时都是指定 WPF 自身的 XAML 资源字典，用途就是指定 XAML 字典作为此控件的资源字典</p>

<p>而默认的 XAML 资源字典使用 Page 形式进行构建，构建之后作为二进制的 Baml 文件被打入程序集中作为程序集资源，在 dotnet 里面有专门的程序集 System.IO.Packaging 来解析程序集资源</p>

<p>而给 Source 属性赋值的时候，给的是一个 Uri 类型的变量，那么 资源字典 ResourceDictionary 是如何通过 Uri 拿到对应的内容的？其实在 WPF 的 ResourceDictionary 的 Source 属性赋值里面有很长的一段逻辑，如下面代码，请大家快速跳过，这些代码只是用来告诉大家，在 WPF 里面使用了很多代码来处理这部分逻辑</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        <span class="k">public</span> <span class="n">Uri</span> <span class="n">Source</span>
        <span class="p">{</span>
            <span class="k">get</span>
            <span class="p">{</span>
                <span class="k">return</span> <span class="n">_source</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="k">set</span>
            <span class="p">{</span>
                <span class="k">if</span> <span class="p">(</span><span class="k">value</span> <span class="p">==</span> <span class="k">null</span> <span class="p">||</span> <span class="n">String</span><span class="p">.</span><span class="nf">IsNullOrEmpty</span><span class="p">(</span><span class="k">value</span><span class="p">.</span><span class="n">OriginalString</span><span class="p">))</span>
                <span class="p">{</span>
                    <span class="k">throw</span> <span class="k">new</span> <span class="nf">ArgumentException</span><span class="p">(</span><span class="n">SR</span><span class="p">.</span><span class="nf">Get</span><span class="p">(</span><span class="n">SRID</span><span class="p">.</span><span class="n">ResourceDictionaryLoadFromFailure</span><span class="p">,</span> <span class="k">value</span> <span class="p">==</span> <span class="k">null</span> <span class="p">?</span> <span class="s">"''"</span> <span class="p">:</span> <span class="k">value</span><span class="p">.</span><span class="nf">ToString</span><span class="p">()));</span>
                <span class="p">}</span>

                <span class="n">ResourceDictionaryDiagnostics</span><span class="p">.</span><span class="nf">RemoveResourceDictionaryForUri</span><span class="p">(</span><span class="n">_source</span><span class="p">,</span> <span class="k">this</span><span class="p">);</span>

                <span class="n">ResourceDictionarySourceUriWrapper</span> <span class="n">uriWrapper</span> <span class="p">=</span> <span class="k">value</span> <span class="k">as</span> <span class="n">ResourceDictionarySourceUriWrapper</span><span class="p">;</span>

                <span class="n">Uri</span> <span class="n">sourceUri</span><span class="p">;</span>

                <span class="c1">// If the Uri we received is a ResourceDictionarySourceUriWrapper it means</span>
                <span class="c1">// that it is being passed down by the Baml parsing code, and it is trying to give us more</span>
                <span class="c1">// information to avoid possible ambiguities in assembly resolving. Use the VersionedUri</span>
                <span class="c1">// to resolve, and the set _source to the OriginalUri so we don't change the return of Source property.</span>
                <span class="c1">// The versioned Uri is not stored, if the version info is needed while debugging, once this method </span>
                <span class="c1">// returns _reader should be set, from there BamlSchemaContext.LocalAssembly contains the version info.</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">uriWrapper</span> <span class="p">==</span> <span class="k">null</span><span class="p">)</span>
                <span class="p">{</span>
                    <span class="n">_source</span> <span class="p">=</span> <span class="k">value</span><span class="p">;</span>
                    <span class="n">sourceUri</span> <span class="p">=</span> <span class="n">_source</span><span class="p">;</span>
                <span class="p">}</span>
                <span class="k">else</span>
                <span class="p">{</span>
                    <span class="n">_source</span> <span class="p">=</span> <span class="n">uriWrapper</span><span class="p">.</span><span class="n">OriginalUri</span><span class="p">;</span>
                    <span class="n">sourceUri</span> <span class="p">=</span> <span class="n">uriWrapper</span><span class="p">.</span><span class="n">VersionedUri</span><span class="p">;</span>
                <span class="p">}</span>
                
                <span class="nf">Clear</span><span class="p">();</span>
                
                
                <span class="n">Uri</span> <span class="n">uri</span> <span class="p">=</span> <span class="n">BindUriHelper</span><span class="p">.</span><span class="nf">GetResolvedUri</span><span class="p">(</span><span class="n">_baseUri</span><span class="p">,</span> <span class="n">sourceUri</span><span class="p">);</span>

                <span class="n">WebRequest</span> <span class="n">request</span> <span class="p">=</span> <span class="n">WpfWebRequestHelper</span><span class="p">.</span><span class="nf">CreateRequest</span><span class="p">(</span><span class="n">uri</span><span class="p">);</span>
                <span class="n">WpfWebRequestHelper</span><span class="p">.</span><span class="nf">ConfigCachePolicy</span><span class="p">(</span><span class="n">request</span><span class="p">,</span> <span class="k">false</span><span class="p">);</span>
                <span class="n">ContentType</span> <span class="n">contentType</span> <span class="p">=</span> <span class="k">null</span><span class="p">;</span>
                <span class="n">Stream</span> <span class="n">s</span> <span class="p">=</span> <span class="k">null</span><span class="p">;</span>

                <span class="k">try</span>
                <span class="p">{</span>
                     <span class="n">s</span> <span class="p">=</span> <span class="n">WpfWebRequestHelper</span><span class="p">.</span><span class="nf">GetResponseStream</span><span class="p">(</span><span class="n">request</span><span class="p">,</span> <span class="k">out</span> <span class="n">contentType</span><span class="p">);</span>
                <span class="p">}</span>
                <span class="k">catch</span> <span class="p">(</span><span class="n">System</span><span class="p">.</span><span class="n">IO</span><span class="p">.</span><span class="n">IOException</span><span class="p">)</span>
                <span class="p">{</span>
                     <span class="c1">// 忽略细节处理的代码</span>
                <span class="p">}</span>

                <span class="c1">// MimeObjectFactory.GetObjectAndCloseStream will try to find the object converter basing on the mime type.</span>
                <span class="c1">// It can be a sync/async converter. It's the converter's responsiblity to close the stream.</span>
                <span class="c1">// If it fails to find a convert, this call will return null.</span>
                <span class="n">System</span><span class="p">.</span><span class="n">Windows</span><span class="p">.</span><span class="n">Markup</span><span class="p">.</span><span class="n">XamlReader</span> <span class="n">asyncObjectConverter</span><span class="p">;</span>
                <span class="n">ResourceDictionary</span> <span class="n">loadedRD</span> <span class="p">=</span> <span class="n">MimeObjectFactory</span><span class="p">.</span><span class="nf">GetObjectAndCloseStream</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">contentType</span><span class="p">,</span> <span class="n">uri</span><span class="p">,</span> <span class="k">false</span><span class="p">,</span> <span class="k">false</span><span class="p">,</span> <span class="k">false</span> <span class="cm">/*allowAsync*/</span><span class="p">,</span> <span class="k">false</span> <span class="cm">/*isJournalNavigation*/</span><span class="p">,</span> <span class="k">out</span> <span class="n">asyncObjectConverter</span><span class="p">)</span>
                                            <span class="k">as</span> <span class="n">ResourceDictionary</span><span class="p">;</span>

                <span class="k">if</span> <span class="p">(</span><span class="n">loadedRD</span> <span class="p">==</span> <span class="k">null</span><span class="p">)</span>
                <span class="p">{</span>
                    <span class="k">throw</span> <span class="k">new</span> <span class="nf">InvalidOperationException</span><span class="p">(</span><span class="n">SR</span><span class="p">.</span><span class="nf">Get</span><span class="p">(</span><span class="n">SRID</span><span class="p">.</span><span class="n">ResourceDictionaryLoadFromFailure</span><span class="p">,</span> <span class="n">_source</span><span class="p">.</span><span class="nf">ToString</span><span class="p">()));</span>
                <span class="p">}</span>

                <span class="c1">// ReferenceCopy all the key-value pairs in the _baseDictionary</span>
                <span class="n">_baseDictionary</span> <span class="p">=</span> <span class="n">loadedRD</span><span class="p">.</span><span class="n">_baseDictionary</span><span class="p">;</span>

                <span class="c1">// ReferenceCopy all the entries in the MergedDictionaries collection</span>
                <span class="n">_mergedDictionaries</span> <span class="p">=</span> <span class="n">loadedRD</span><span class="p">.</span><span class="n">_mergedDictionaries</span><span class="p">;</span>

                <span class="c1">// ReferenceCopy all of the deferred content state</span>
                <span class="nf">CopyDeferredContentFrom</span><span class="p">(</span><span class="n">loadedRD</span><span class="p">);</span>

                <span class="c1">// Take over the deferred resource references</span>
                <span class="nf">MoveDeferredResourceReferencesFrom</span><span class="p">(</span><span class="n">loadedRD</span><span class="p">);</span>

                <span class="c1">// Copy over the HasImplicitStyles flag</span>
                <span class="n">HasImplicitStyles</span> <span class="p">=</span> <span class="n">loadedRD</span><span class="p">.</span><span class="n">HasImplicitStyles</span><span class="p">;</span>

                <span class="c1">// Copy over the HasImplicitDataTemplates flag</span>
                <span class="n">HasImplicitDataTemplates</span> <span class="p">=</span> <span class="n">loadedRD</span><span class="p">.</span><span class="n">HasImplicitDataTemplates</span><span class="p">;</span>

                <span class="c1">// Copy over the InvalidatesImplicitDataTemplateResources flag</span>
                <span class="n">InvalidatesImplicitDataTemplateResources</span> <span class="p">=</span> <span class="n">loadedRD</span><span class="p">.</span><span class="n">InvalidatesImplicitDataTemplateResources</span><span class="p">;</span>

                <span class="c1">// Set inheritance context on the copied values</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">InheritanceContext</span> <span class="p">!=</span> <span class="k">null</span><span class="p">)</span>
                <span class="p">{</span>
                    <span class="nf">AddInheritanceContextToValues</span><span class="p">();</span>
                <span class="p">}</span>

                <span class="c1">// Propagate parent owners to each of the acquired merged dictionaries</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">_mergedDictionaries</span> <span class="p">!=</span> <span class="k">null</span><span class="p">)</span>
                <span class="p">{</span>
                    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="p">&lt;</span> <span class="n">_mergedDictionaries</span><span class="p">.</span><span class="n">Count</span><span class="p">;</span> <span class="n">i</span><span class="p">++)</span>
                    <span class="p">{</span>
                        <span class="nf">PropagateParentOwners</span><span class="p">(</span><span class="n">_mergedDictionaries</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
                    <span class="p">}</span>
                <span class="p">}</span>

                <span class="n">ResourceDictionaryDiagnostics</span><span class="p">.</span><span class="nf">AddResourceDictionaryForUri</span><span class="p">(</span><span class="n">uri</span><span class="p">,</span> <span class="k">this</span><span class="p">);</span>

                <span class="k">if</span> <span class="p">(!</span><span class="n">IsInitializePending</span><span class="p">)</span>
                <span class="p">{</span>
                    <span class="c1">// Fire Invalidations for the changes made by asigning a new Source</span>
                    <span class="nf">NotifyOwners</span><span class="p">(</span><span class="k">new</span> <span class="nf">ResourcesChangeInfo</span><span class="p">(</span><span class="k">null</span><span class="p">,</span> <span class="k">this</span><span class="p">));</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>
</code></pre></div></div>

<p>大概整理一下的在 Source 的 set 方法里面的逻辑大概如下</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 前置属性判断</span>

<span class="c1">// 清空当前资源字典的所有元素</span>
<span class="nf">Clear</span><span class="p">();</span>

<span class="c1">// 解析 Uri 获取资源</span>
<span class="n">ResourceDictionary</span> <span class="n">loadedRD</span> <span class="p">=</span> <span class="n">xx</span><span class="p">;</span> <span class="c1">// 这里的 loadedRD 就是 loadedR(esource)D(ictionary) 的意思</span>

<span class="c1">// 取出资源字典的值</span>
<span class="n">_baseDictionary</span> <span class="p">=</span> <span class="n">loadedRD</span><span class="p">.</span><span class="n">_baseDictionary</span><span class="p">;</span>

<span class="c1">// 取出资源字典加载的其他资源字典</span>
<span class="n">_mergedDictionaries</span> <span class="p">=</span> <span class="n">loadedRD</span><span class="p">.</span><span class="n">_mergedDictionaries</span><span class="p">;</span>

<span class="c1">// 其他杂项状态处理</span>
</code></pre></div></div>

<p>可以看到上面代码的逻辑步骤其实很少，核心的逻辑就是 解析 Uri 获取资源 这部分</p>

<p>在开始获取资源之前，需要先将 Uri 转换为绝对路径，也就是说在 XAML 中写的 Uri 将会被补全</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>     <span class="n">_source</span> <span class="p">=</span> <span class="k">value</span><span class="p">;</span>
     <span class="n">sourceUri</span> <span class="p">=</span> <span class="n">_source</span><span class="p">;</span>
     <span class="n">Uri</span> <span class="n">uri</span> <span class="p">=</span> <span class="n">BindUriHelper</span><span class="p">.</span><span class="nf">GetResolvedUri</span><span class="p">(</span><span class="n">_baseUri</span><span class="p">,</span> <span class="n">sourceUri</span><span class="p">);</span>
</code></pre></div></div>

<p>这里拿到 uri 之后，通过调用 WpfWebRequestHelper 的方法拿到资源的 Stream 对象</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">WebRequest</span> <span class="n">request</span> <span class="p">=</span> <span class="n">WpfWebRequestHelper</span><span class="p">.</span><span class="nf">CreateRequest</span><span class="p">(</span><span class="n">uri</span><span class="p">);</span>
<span class="n">WpfWebRequestHelper</span><span class="p">.</span><span class="nf">ConfigCachePolicy</span><span class="p">(</span><span class="n">request</span><span class="p">,</span> <span class="k">false</span><span class="p">);</span>
<span class="n">ContentType</span> <span class="n">contentType</span> <span class="p">=</span> <span class="k">null</span><span class="p">;</span>
<span class="n">Stream</span> <span class="n">s</span> <span class="p">=</span> <span class="k">null</span><span class="p">;</span>

<span class="k">try</span>
<span class="p">{</span>
    <span class="n">s</span> <span class="p">=</span> <span class="n">WpfWebRequestHelper</span><span class="p">.</span><span class="nf">GetResponseStream</span><span class="p">(</span><span class="n">request</span><span class="p">,</span> <span class="k">out</span> <span class="n">contentType</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">catch</span>
<span class="p">{</span>
	<span class="c1">// 忽略细节代码</span>
<span class="p">}</span>
</code></pre></div></div>

<p>看到了 WebRequest 请不要激动，这不代表一定会从网络上读取哦</p>

<p>因为这个 WebRequest 是使用 WpfWebRequestHelper 的 CreateRequest 拿到的 WebRequest 不一定是一个走网络的 WebRequest 哦，在 WpfWebRequestHelper 的 CreateRequest 方法里面，会根据 Uri 进行判断，假定是获取到一个在应用本地资源的路径，那么将使用 PackWebRequestFactory.CreateWebRequest 返回一个基于 System.IO.Packaging 的 PackWebRequest 对象。否则就是真的走网络了，因此给资源字典设置一个网络上的 Url 也是可以的</p>

<p>在 PackWebRequest 里面，其实就是一个继承了 WebRequest 的类，这个类的命名空间是 System.IO.Packaging 但是放在 PresentationCore 里面，是逻辑上属于 System.IO.Packaging 程序集，但实际上在 PresentationCore 程序集</p>

<p>在 PackWebRequest 通过重写 WebRequest 的方法，实现了实际上没有走网络，而是返回了 PackWebResponse 对象，在 PackWebResponse 里面就是读取程序集的资源作为 Stream 返回</p>

<p>因此调用 WpfWebRequestHelper 的 CreateRequest 方法创建的 WebRequest 在传入的是 uri 是一个本地的资源字典的时候，就是读取本地程序集资源返回 Stream 对象</p>

<p>读取到 Stream 之后需要进行解析，如下面代码</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">ResourceDictionary</span> <span class="n">loadedRD</span> <span class="p">=</span> <span class="n">MimeObjectFactory</span><span class="p">.</span><span class="nf">GetObjectAndCloseStream</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">contentType</span><span class="p">,</span> <span class="n">uri</span><span class="p">,</span> <span class="k">false</span><span class="p">,</span> <span class="k">false</span><span class="p">,</span> <span class="k">false</span> <span class="cm">/*allowAsync*/</span><span class="p">,</span> <span class="k">false</span> <span class="cm">/*isJournalNavigation*/</span><span class="p">,</span> <span class="k">out</span> <span class="n">asyncObjectConverter</span><span class="p">)</span> <span class="k">as</span> <span class="n">ResourceDictionary</span><span class="p">;</span>
</code></pre></div></div>

<p>此时拿到了 loadedResourceDictionary 也就是 loadedRD 变量，下一步就是取出里面的值</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>                <span class="c1">// ReferenceCopy all the key-value pairs in the _baseDictionary</span>
                <span class="n">_baseDictionary</span> <span class="p">=</span> <span class="n">loadedRD</span><span class="p">.</span><span class="n">_baseDictionary</span><span class="p">;</span>

                <span class="c1">// ReferenceCopy all the entries in the MergedDictionaries collection</span>
                <span class="n">_mergedDictionaries</span> <span class="p">=</span> <span class="n">loadedRD</span><span class="p">.</span><span class="n">_mergedDictionaries</span><span class="p">;</span>
</code></pre></div></div>

<p>此时就完成了资源字典的从 Uri 加载了</p>

<p>在资源字典里面，包含了两层内容，第一层的内容就是在这个资源字典里面定义的资源，这些资源放在了 <code class="language-plaintext highlighter-rouge">private Hashtable _baseDictionary</code> 里面。第二层内容就是 <code class="language-plaintext highlighter-rouge">private ObservableCollection&lt;ResourceDictionary&gt; _mergedDictionaries</code> 被这个资源字典合并的其他资源字典里面</p>

<p>因此在 WPF 中寻找资源是先从自己的 <code class="language-plaintext highlighter-rouge">_baseDictionary</code> 尝试获取资源，如获取不到在从 <code class="language-plaintext highlighter-rouge">_mergedDictionaries</code> 里面获取，如下面代码</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        <span class="k">private</span> <span class="kt">object</span> <span class="nf">GetValueWithoutLock</span><span class="p">(</span><span class="kt">object</span> <span class="n">key</span><span class="p">,</span> <span class="k">out</span> <span class="kt">bool</span> <span class="n">canCache</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="kt">object</span> <span class="k">value</span> <span class="p">=</span> <span class="n">_baseDictionary</span><span class="p">[</span><span class="n">key</span><span class="p">];</span>
            <span class="k">if</span> <span class="p">(</span><span class="k">value</span> <span class="p">!=</span> <span class="k">null</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="nf">OnGettingValuePrivate</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="k">ref</span> <span class="k">value</span><span class="p">,</span> <span class="k">out</span> <span class="n">canCache</span><span class="p">);</span>
            <span class="p">}</span>
            <span class="k">else</span>
            <span class="p">{</span>
                <span class="n">canCache</span> <span class="p">=</span> <span class="k">true</span><span class="p">;</span>

                <span class="c1">//Search for the value in the Merged Dictionaries</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">_mergedDictionaries</span> <span class="p">!=</span> <span class="k">null</span><span class="p">)</span>
                <span class="p">{</span>
                    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="p">=</span> <span class="n">MergedDictionaries</span><span class="p">.</span><span class="n">Count</span> <span class="p">-</span> <span class="m">1</span><span class="p">;</span> <span class="p">(</span><span class="n">i</span> <span class="p">&gt;</span> <span class="p">-</span><span class="m">1</span><span class="p">);</span> <span class="n">i</span><span class="p">--)</span>
                    <span class="p">{</span>
                        <span class="c1">// Note that MergedDictionaries collection can also contain null values</span>
                        <span class="n">ResourceDictionary</span> <span class="n">mergedDictionary</span> <span class="p">=</span> <span class="n">MergedDictionaries</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
                        <span class="k">if</span> <span class="p">(</span><span class="n">mergedDictionary</span> <span class="p">!=</span> <span class="k">null</span><span class="p">)</span>
                        <span class="p">{</span>
                            <span class="k">value</span> <span class="p">=</span> <span class="n">mergedDictionary</span><span class="p">.</span><span class="nf">GetValue</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="k">out</span> <span class="n">canCache</span><span class="p">);</span>
                            <span class="k">if</span> <span class="p">(</span><span class="k">value</span> <span class="p">!=</span> <span class="k">null</span><span class="p">)</span>
                            <span class="p">{</span>
                                <span class="k">break</span><span class="p">;</span>
                            <span class="p">}</span>
                        <span class="p">}</span>
                    <span class="p">}</span>
                <span class="p">}</span>
            <span class="p">}</span>

            <span class="k">return</span> <span class="k">value</span><span class="p">;</span>
        <span class="p">}</span>
</code></pre></div></div>

<p>从上面代码可以看到，获取的时候是优先从 <code class="language-plaintext highlighter-rouge">_baseDictionary</code> 获取的。获取不到在从 MergedDictionaries 里面获取，最后添加的资源字典最先寻找。也就是说存在 Key 重复的资源的时候，会先从资源字典本身寻找，如果找不到就从合并的其他字典的最后一个资源字典开始寻找</p>

<p>这就是 WPF 资源字典设置的逻辑</p>

<p>当前整个 WPF 源代码都是开源的，请看 <a href="https://github.com/dotnet/wpf/">https://github.com/dotnet/wpf/</a></p>

<p>更多资源字典相关请看</p>

<!-- ?WT.mc_id=WD-MVP-5003260

&WT.mc_id=WD-MVP-5003260 -->

<ul>
  <li><a href="https://docs.microsoft.com/en-us/dotnet/desktop/wpf/fundamentals/xaml-resources-define?view=netdesktop-5.0&amp;WT.mc_id=WD-MVP-5003260">Define XAML resources - WPF .NET</a></li>
  <li><a href="https://docs.microsoft.com/en-us/dotnet/desktop/wpf/app-development/how-to-use-an-application-scope-resource-dictionary?view=netframeworkdesktop-4.8&amp;WT.mc_id=WD-MVP-5003260">How to: Use an Application-Scope Resource Dictionary - WPF .NET Framework</a></li>
  <li><a href="https://blog.csdn.net/jiangxinyu/article/details/8756985?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-1.control&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-1.control">ResourceDictionary.Source 属性_jiangxinyu的专栏-CSDN博客</a></li>
  <li><a href="https://blog.csdn.net/wlarlen/article/details/79047320">WPF之ResourceDictionary资源字典_LADT的博客-CSDN博客</a></li>
  <li><a href="https://blog.csdn.net/wcc27857285/article/details/90943244">WPF 资源字典ResourceDictionary使用_Stay Hungry-CSDN博客</a></li>
  <li><a href="https://blog.lindexi.com/post/WPF-%E5%9C%A8%E5%90%8E%E5%8F%B0%E4%BB%A3%E7%A0%81%E5%AE%9A%E4%B9%89-ResourceDictionary-%E8%B5%84%E6%BA%90%E5%AD%97%E5%85%B8.html">WPF 在后台代码定义 ResourceDictionary 资源字典</a></li>
  <li><a href="https://www.cnblogs.com/Peter-Luo/p/12288443.html">【WPF学习】第三十四章 资源基础 - Peter.Luo - 博客园</a></li>
  <li><a href="https://www.cnblogs.com/Peter-Luo/p/12289408.html">【WPF学习】第三十五章 资源字典 - Peter.Luo - 博客园</a></li>
</ul>

:ET