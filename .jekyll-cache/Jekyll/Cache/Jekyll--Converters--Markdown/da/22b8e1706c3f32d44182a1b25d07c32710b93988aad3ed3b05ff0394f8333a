I";Y<p>本文收集一些基础的知识，本文的逻辑是在 WPF 框架下实现，有包含了默认的坐标系以及默认类型定义。对于 WPF 系的包括 Xamarin 和 UWP 都适合</p>

<!--more-->

<!-- CreateTime:2021/1/27 19:18:15 -->

<h2 id="运行代码">运行代码</h2>

<p>本文的代码都放在 GitHub 或 Gitee 上，代码都可以下载进行运行。基本的代码都可以使用一句 <code class="language-plaintext highlighter-rouge">dotnet run</code> 跑起来，当然，前提是你的 dotnet 版本需要足够新</p>

<p>本文代码协议基于 MIT 协议，请放心抄代码</p>

<h2 id="根据点集求外接矩形">根据点集求外接矩形</h2>

<p>先看图片，通过给定的点的集合，求这些点的外接矩形</p>

<!-- ![](image/WPF 基础 2D 图形学知识/根据点集求外接矩形.gif) -->

<p><img src="http://image.acmx.xyz/lindexi%2F%25E6%25A0%25B9%25E6%258D%25AE%25E7%2582%25B9%25E9%259B%2586%25E6%25B1%2582%25E5%25A4%2596%25E6%258E%25A5%25E7%259F%25A9%25E5%25BD%25A2.gif" alt="" /></p>

<p>传入的是 <code class="language-plaintext highlighter-rouge">List&lt;Point&gt; pointList</code> 要求传出的是 Rect 类，实现代码如下</p>

<!-- ![](image/WPF 基础 2D 图形学知识/WPF 基础 2D 图形学知识0.png) -->

<p><img src="http://image.acmx.xyz/lindexi%2F2021127194264742.jpg" alt="" /></p>

<p>在新建矩形的时候，采用了第一个点创建，如果没有传入点，将使用默认的原点</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        <span class="k">private</span> <span class="n">Rect</span> <span class="nf">CreateRect</span><span class="p">(</span><span class="n">List</span><span class="p">&lt;</span><span class="n">Point</span><span class="p">&gt;</span> <span class="n">pointList</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="kt">var</span> <span class="n">rect</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">Rect</span><span class="p">(</span><span class="n">pointList</span><span class="p">[</span><span class="m">0</span><span class="p">],</span> <span class="k">new</span> <span class="nf">Size</span><span class="p">(</span><span class="m">0</span><span class="p">,</span> <span class="m">0</span><span class="p">));</span>

            <span class="k">for</span> <span class="p">(</span><span class="kt">var</span> <span class="n">i</span> <span class="p">=</span> <span class="m">1</span><span class="p">;</span> <span class="n">i</span> <span class="p">&lt;</span> <span class="n">pointList</span><span class="p">.</span><span class="n">Count</span><span class="p">;</span> <span class="n">i</span><span class="p">++)</span>
            <span class="p">{</span>
                <span class="n">rect</span><span class="p">.</span><span class="nf">Union</span><span class="p">(</span><span class="n">pointList</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
            <span class="p">}</span>

            <span class="k">return</span> <span class="n">rect</span><span class="p">;</span>
        <span class="p">}</span>
</code></pre></div></div>

<p>以上代码放在 <a href="https://github.com/lindexi/lindexi_gd/tree/df873f1e/LeajemhurhoCaiwhemqurhahawwhaw">github</a> 和 <a href="https://gitee.com/lindexi/lindexi_gd/tree/df873f1e/LeajemhurhoCaiwhemqurhahawwhaw">gitee</a> 欢迎小伙伴访问</p>

<h2 id="绘制闭合折线">绘制闭合折线</h2>

<p>通过 Polygon 可以根据点集绘制闭合折线</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>            <span class="kt">var</span> <span class="n">polygon</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">Polygon</span><span class="p">()</span>
            <span class="p">{</span>
                <span class="n">Points</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">PointCollection</span><span class="p">(</span><span class="n">PointList</span><span class="p">),</span>
                <span class="n">Stroke</span> <span class="p">=</span> <span class="n">Brushes</span><span class="p">.</span><span class="n">Red</span><span class="p">,</span>
            <span class="p">};</span>
</code></pre></div></div>

<!-- ![](image/WPF 基础 2D 图形学知识/绘制闭合折线.gif) -->

<p><img src="http://image.acmx.xyz/lindexi%2F%25E7%25BB%2598%25E5%2588%25B6%25E9%2597%25AD%25E5%2590%2588%25E6%258A%2598%25E7%25BA%25BF.gif" alt="" /></p>

<p>以上代码放在 <a href="https://github.com/lindexi/lindexi_gd/tree/0d947fe2/LeajemhurhoCaiwhemqurhahawwhaw">github</a> 和 <a href="https://gitee.com/lindexi/lindexi_gd/tree/0d947fe2/LeajemhurhoCaiwhemqurhahawwhaw">gitee</a> 欢迎小伙伴访问</p>

<h2 id="判断点在几何内">判断点在几何内</h2>

<p>这个做法也叫命中测试，输入是一个 Geometry 和一个点，输出是判断点是否在闭合的 Geometry 几何内。方法是通过 WPF 的 Geometry 的 FillContains 方法，这个方法可以传入点也可以传入另一个 Geometry 用来判断是否在几何内</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Geometry</span><span class="p">.</span><span class="nf">FillContains</span><span class="p">(</span><span class="n">position</span><span class="p">)</span>
</code></pre></div></div>

<p>和 FillContains 相对的是 StrokeContains 方法，和 Fill 方法不相同的是，调用 StrokeContains 判断的是在几何的线上，而不是在几何内</p>

<p>我写了一点测试的逻辑，如果鼠标在几何内，那么几何显示灰色</p>

<!-- ![](image/WPF 基础 2D 图形学知识/判断点在几何内.gif) -->

<p><img src="http://image.acmx.xyz/lindexi%2F%25E5%2588%25A4%25E6%2596%25AD%25E7%2582%25B9%25E5%259C%25A8%25E5%2587%25A0%25E4%25BD%2595%25E5%2586%2585.gif" alt="" /></p>

<p>以上代码放在 <a href="https://github.com/lindexi/lindexi_gd/tree/5f804a35/LeajemhurhoCaiwhemqurhahawwhaw">github</a> 和 <a href="https://gitee.com/lindexi/lindexi_gd/tree/5f804a35/LeajemhurhoCaiwhemqurhahawwhaw">gitee</a> 欢迎小伙伴访问</p>

<p>更多请看 <a href="https://blog.lindexi.com/post/WPF-%E5%9F%BA%E7%A1%80-2D-%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%9F%A5%E8%AF%86-%E5%88%A4%E6%96%AD%E7%82%B9%E6%98%AF%E5%90%A6%E5%9C%A8%E4%BB%BB%E6%84%8F%E5%87%A0%E4%BD%95%E5%86%85%E9%83%A8%E6%96%B9%E6%B3%95.html">WPF 基础 2D 图形学知识 判断点是否在任意几何内部方法</a></p>

<p>以上文档包含了求旋转矩形命中测试，给定一个旋转矩形，已知这个旋转矩形的各个顶点坐标。以及一个点，求这个点是否在旋转矩形内的算法</p>

<h2 id="给定中心点和宽度高度旋转角度求旋转矩形顶点坐标">给定中心点和宽度高度旋转角度求旋转矩形顶点坐标</h2>

<p>如有定义旋转矩形的顶点分别是 A B C D 四个点，在没有进行旋转之前如图</p>

<!-- ![](image/WPF 基础 2D 图形学知识/WPF 基础 2D 图形学知识1.png) -->

<p><img src="http://image.acmx.xyz/lindexi%2F20211272028498690.jpg" alt="" /></p>

<p>给定中心点 O1 和宽度高度，以及使用弧度表示的旋转角度可以创建旋转矩形，代码逻辑如下</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="k">class</span> <span class="err">旋转矩形</span>
    <span class="err">{</span>
        <span class="nc">public</span> <span class="err">旋转矩形</span><span class="p">(</span><span class="n">Point</span> <span class="n">a</span><span class="p">,</span> <span class="n">Point</span> <span class="n">b</span><span class="p">,</span> <span class="n">Point</span> <span class="n">c</span><span class="p">,</span> <span class="n">Point</span> <span class="n">d</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="cm">/*
             *A    B
             *------
             *|    |
             *|    |
             *------
             *C    D
             */</span>
            <span class="c1">// 顺序需要是一个逆时针，因此就是 A C D B 的传入</span>

            <span class="n">Polygon</span> <span class="p">=</span> <span class="k">new</span> <span class="n">Point</span><span class="p">[</span><span class="m">4</span><span class="p">]</span>
            <span class="p">{</span>
                <span class="n">a</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">b</span>
            <span class="p">};</span>

            <span class="n">A</span> <span class="p">=</span> <span class="n">a</span><span class="p">;</span>
            <span class="n">B</span> <span class="p">=</span> <span class="n">b</span><span class="p">;</span>
            <span class="n">C</span> <span class="p">=</span> <span class="n">c</span><span class="p">;</span>
            <span class="n">D</span> <span class="p">=</span> <span class="n">d</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">public</span> <span class="k">static</span> <span class="err">旋转矩形</span> <span class="n">Create</span><span class="err">旋转矩形</span><span class="p">(</span><span class="n">Point</span> <span class="n">position</span><span class="p">,</span> <span class="kt">double</span> <span class="n">width</span><span class="p">,</span> <span class="kt">double</span> <span class="n">height</span><span class="p">,</span> <span class="kt">double</span> <span class="n">rotation</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="kt">var</span> <span class="n">w</span> <span class="p">=</span> <span class="n">width</span><span class="p">;</span>
            <span class="kt">var</span> <span class="n">h</span> <span class="p">=</span> <span class="n">height</span><span class="p">;</span>

            <span class="kt">var</span> <span class="n">ax</span> <span class="p">=</span> <span class="p">-</span><span class="n">w</span> <span class="p">/</span> <span class="m">2</span><span class="p">;</span>
            <span class="kt">var</span> <span class="n">ay</span> <span class="p">=</span> <span class="p">-</span><span class="n">h</span> <span class="p">/</span> <span class="m">2</span><span class="p">;</span>
            <span class="kt">var</span> <span class="n">bx</span> <span class="p">=</span> <span class="n">w</span> <span class="p">/</span> <span class="m">2</span><span class="p">;</span>
            <span class="kt">var</span> <span class="k">by</span> <span class="p">=</span> <span class="n">ay</span><span class="p">;</span>
            <span class="kt">var</span> <span class="n">cx</span> <span class="p">=</span> <span class="n">ax</span><span class="p">;</span>
            <span class="kt">var</span> <span class="n">cy</span> <span class="p">=</span> <span class="n">h</span> <span class="p">/</span> <span class="m">2</span><span class="p">;</span>
            <span class="kt">var</span> <span class="n">dx</span> <span class="p">=</span> <span class="n">bx</span><span class="p">;</span>
            <span class="kt">var</span> <span class="n">dy</span> <span class="p">=</span> <span class="n">cy</span><span class="p">;</span>

            <span class="kt">var</span> <span class="n">a</span> <span class="p">=</span> <span class="err">已知未旋转的相对矩形中心点的坐标求旋转后的相对于零点的坐标</span><span class="p">(</span><span class="n">ax</span><span class="p">,</span> <span class="n">ay</span><span class="p">,</span> <span class="n">position</span><span class="p">,</span> <span class="n">rotation</span><span class="p">);</span>
            <span class="kt">var</span> <span class="n">b</span> <span class="p">=</span> <span class="err">已知未旋转的相对矩形中心点的坐标求旋转后的相对于零点的坐标</span><span class="p">(</span><span class="n">bx</span><span class="p">,</span> <span class="k">by</span><span class="p">,</span> <span class="n">position</span><span class="p">,</span> <span class="n">rotation</span><span class="p">);</span>
            <span class="kt">var</span> <span class="n">c</span> <span class="p">=</span> <span class="err">已知未旋转的相对矩形中心点的坐标求旋转后的相对于零点的坐标</span><span class="p">(</span><span class="n">cx</span><span class="p">,</span> <span class="n">cy</span><span class="p">,</span> <span class="n">position</span><span class="p">,</span> <span class="n">rotation</span><span class="p">);</span>
            <span class="kt">var</span> <span class="n">d</span> <span class="p">=</span> <span class="err">已知未旋转的相对矩形中心点的坐标求旋转后的相对于零点的坐标</span><span class="p">(</span><span class="n">dx</span><span class="p">,</span> <span class="n">dy</span><span class="p">,</span> <span class="n">position</span><span class="p">,</span> <span class="n">rotation</span><span class="p">);</span>
            <span class="k">return</span> <span class="k">new</span> <span class="err">旋转矩形</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">d</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="c1">/// &lt;summary&gt;</span>
        <span class="c1">/// 根据未旋转的相对圆角矩形 中心点 的坐标计算旋转后的相对于零点的坐标。</span>
        <span class="c1">/// &lt;/summary&gt;</span>
        <span class="c1">/// &lt;returns&gt;旋转后的相对于零点的坐标&lt;/returns&gt;</span>
        <span class="k">private</span> <span class="k">static</span> <span class="n">Point</span> <span class="err">已知未旋转的相对矩形中心点的坐标求旋转后的相对于零点的坐标</span><span class="p">(</span><span class="kt">double</span> <span class="n">x</span><span class="p">,</span> <span class="kt">double</span> <span class="n">y</span><span class="p">,</span> <span class="n">Point</span> <span class="n">position</span><span class="p">,</span> <span class="kt">double</span> <span class="err">旋转弧度</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="kt">var</span> <span class="n">x0</span> <span class="p">=</span> <span class="n">position</span><span class="p">.</span><span class="n">X</span><span class="p">;</span>
            <span class="kt">var</span> <span class="n">y0</span> <span class="p">=</span> <span class="n">position</span><span class="p">.</span><span class="n">Y</span><span class="p">;</span>
            <span class="kt">var</span> <span class="err">θ</span> <span class="p">=</span> <span class="err">旋转弧度</span><span class="p">;</span>
            <span class="k">return</span> <span class="k">new</span> <span class="nf">Point</span><span class="p">(</span><span class="n">x</span> <span class="p">*</span> <span class="n">Math</span><span class="p">.</span><span class="nf">Cos</span><span class="p">(</span><span class="err">θ</span><span class="p">)</span> <span class="p">-</span> <span class="n">y</span> <span class="p">*</span> <span class="n">Math</span><span class="p">.</span><span class="nf">Sin</span><span class="p">(</span><span class="err">θ</span><span class="p">)</span> <span class="p">+</span> <span class="n">x0</span><span class="p">,</span> <span class="n">x</span> <span class="p">*</span> <span class="n">Math</span><span class="p">.</span><span class="nf">Sin</span><span class="p">(</span><span class="err">θ</span><span class="p">)</span> <span class="p">+</span> <span class="n">y</span> <span class="p">*</span> <span class="n">Math</span><span class="p">.</span><span class="nf">Cos</span><span class="p">(</span><span class="err">θ</span><span class="p">)</span> <span class="p">+</span> <span class="n">y0</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="k">public</span> <span class="n">Point</span> <span class="n">A</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="p">}</span>
        <span class="k">public</span> <span class="n">Point</span> <span class="n">B</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="p">}</span>
        <span class="k">public</span> <span class="n">Point</span> <span class="n">C</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="p">}</span>
        <span class="k">public</span> <span class="n">Point</span> <span class="n">D</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="p">}</span>

        <span class="k">public</span> <span class="n">Point</span><span class="p">[]</span> <span class="n">Polygon</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="p">}</span>
    <span class="p">}</span>
</code></pre></div></div>

<p>上面代码的 Polygon 仅仅只是用来给界面显示</p>

<p>以上代码放在 <a href="https://github.com/lindexi/lindexi_gd/tree/12324b85/LeajemhurhoCaiwhemqurhahawwhaw">github</a> 和 <a href="https://gitee.com/lindexi/lindexi_gd/tree/12324b85/LeajemhurhoCaiwhemqurhahawwhaw">gitee</a> 欢迎小伙伴访问</p>

<p>在命名上，使用 Rotation 指的是旋转，包含了角度和旋转中心点。而 Angle 表示的是旋转的角度，默认咱使用的是弧度表示</p>

<h2 id="向量的获取方法">向量的获取方法</h2>

<p>有两个点分别是 A 和 B 两点，求向量 AB 的值</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">AB</span> <span class="p">=</span> <span class="n">B</span> <span class="p">-</span> <span class="n">A</span><span class="p">;</span>
</code></pre></div></div>

<p>向量里面，采用的点的相减可以获取向量。如上面代码表示向量 AB 以 A 为起点，以 B 为终点的向量</p>

<!-- ![](image/WPF 基础 2D 图形学知识/WPF 基础 2D 图形学知识7.png) -->

<p><img src="http://image.acmx.xyz/lindexi%2F202133103233804.jpg" alt="" /></p>

<h2 id="求向量旋转角度"><a href="https://blog.lindexi.com/post/WPF-%E5%9F%BA%E7%A1%80-2D-%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%9F%A5%E8%AF%86-%E6%B1%82%E5%90%91%E9%87%8F%E6%97%8B%E8%BD%AC%E8%A7%92%E5%BA%A6.html">求向量旋转角度</a></h2>

<p>求向量的三角函数 sin 或 cos 的值。或已知两个点，求两点相连线段角度</p>

<p>请看 <a href="https://blog.lindexi.com/post/WPF-%E5%9F%BA%E7%A1%80-2D-%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%9F%A5%E8%AF%86-%E6%B1%82%E5%90%91%E9%87%8F%E6%97%8B%E8%BD%AC%E8%A7%92%E5%BA%A6.html">WPF 基础 2D 图形学知识 求向量旋转角度</a></p>

<h2 id="角度弧度">角度弧度</h2>

<p>使用 Math 的三角函数计算返回值使用的是弧度单位，如下面代码</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        <span class="c1">/// &lt;summary&gt;</span>
        <span class="c1">/// 获取向量的 cos（θ）值</span>
        <span class="c1">/// &lt;/summary&gt;</span>
        <span class="c1">/// &lt;param name="vector"&gt;&lt;/param&gt;</span>
        <span class="c1">/// &lt;returns&gt;&lt;/returns&gt;</span>
        <span class="k">public</span> <span class="k">static</span> <span class="kt">double</span> <span class="nf">GetCos</span><span class="p">(</span><span class="k">this</span> <span class="n">Vector</span> <span class="n">vector</span><span class="p">)</span>
            <span class="p">=&gt;</span> <span class="n">vector</span><span class="p">.</span><span class="n">Y</span> <span class="p">/</span> <span class="n">vector</span><span class="p">.</span><span class="n">Length</span><span class="p">;</span>
</code></pre></div></div>

<p>在 C# 中将弧度转换为角度可以使用如下代码</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">var</span> <span class="err">角度</span> <span class="p">=</span> <span class="err">弧度</span> <span class="p">/</span> <span class="n">Math</span><span class="p">.</span><span class="n">PI</span> <span class="p">*</span> <span class="m">180</span><span class="p">;</span>
</code></pre></div></div>

<h2 id="最简代码绘制-geometry-几何">最简代码绘制 Geometry 几何</h2>

<p>使用 Path 元素</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>      &lt;Path x:Name="DrawElement" Stroke="Red" StrokeThickness="1" HorizontalAlignment="Left" VerticalAlignment="Top"&gt;&lt;/Path&gt;

      DrawElement.Data = geometry;
</code></pre></div></div>

<h2 id="wpf-虚线和像素关系">WPF 虚线和像素关系</h2>

<p>在 WPF 中，如果需要绘制虚线，可以使用 StrokeDashArray 属性，这个属性将可以传入数组，数组下标从0开始算，如果是偶数的就显示内容，奇数的就透明。而长度就是和像素相关，计算方法和 StrokeThickness 大小有关。像素值等于数组上的数值乘以 StrokeThickness 的大小。例如下面代码，虚线的可以显示部分和不可以显示部分的像素值是 5 乘以 StrokeThickness 的大小，也就是 25 像素</p>

<div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="nt">&lt;Line</span> <span class="na">X1=</span><span class="s">"10"</span> <span class="na">Y1=</span><span class="s">"100"</span> <span class="na">X2=</span><span class="s">"100"</span> <span class="na">Y2=</span><span class="s">"100"</span> <span class="na">Stroke=</span><span class="s">"BlanchedAlmond"</span> <span class="na">StrokeThickness=</span><span class="s">"5"</span> <span class="na">StrokeDashArray=</span><span class="s">"5 5"</span> <span class="nt">/&gt;</span>
</code></pre></div></div>

<p>当然，上面说的像素其实不算对，应该是 WPF 单位</p>

<p>以上代码放在 <a href="https://github.com/lindexi/lindexi_gd/tree/9e31bab17e4a0e48fb6d58e298fbb7c281279fcb/ChacalijurLeahulurbufel">github</a> 和 <a href="https://gitee.com/lindexi/lindexi_gd/tree/9e31bab17e4a0e48fb6d58e298fbb7c281279fcb/ChacalijurLeahulurbufel">gitee</a> 欢迎小伙伴访问</p>

<h2 id="参考">参考</h2>

<p>《人教版初中数学》</p>

<p>《程序员的数学 线性代数》</p>

<p>《同济线性代数教材》</p>

:ET