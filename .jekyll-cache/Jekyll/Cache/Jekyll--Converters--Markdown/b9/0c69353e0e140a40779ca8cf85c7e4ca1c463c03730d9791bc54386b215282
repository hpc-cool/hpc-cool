I"c<p>本文告诉大家 await 的高级用法，包括底层原理。</p>

<!--more-->

<!-- CreateTime:2019/8/31 16:55:58 -->

<!-- 标签：C#，await，dotnet -->

<p>昨天看到<a href="https://walterlv.github.io/">太子</a>写了一段代码，我开始觉得他修改了编译器，要不然下面的代码怎么可以编译通过</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">await</span> <span class="s">"林德熙逗比"</span><span class="p">;</span>
</code></pre></div></div>

<p>需要知道，基本可以添加 await 都是可以等待的类型，如 Task 。如果一个类需要可以被等待，那么这个类必须满足以下条件</p>

<ul>
  <li>
    <p>类里有一个 GetAwaiter 函数</p>
  </li>
  <li>
    <p>GetAwaiter 有返回值，返回值需要继承 INotifyCompletion 并且有 <code class="language-plaintext highlighter-rouge">bool IsCompleted { get; }</code>,<code class="language-plaintext highlighter-rouge">GetResult()</code>,<code class="language-plaintext highlighter-rouge">void OnCompleted(Action continuation)</code> 定义</p>
  </li>
</ul>

<p>参见：<a href="https://walterlv.github.io/post/write-custom-awaiter.html">如何实现一个可以用 await 异步等待的 Awaiter - walterlv</a></p>

<p>但是上面的代码使用的是一个字符串，什么时候可以修改继承字符串？</p>

<p>先让我来说下 await 原理，因为知道了原理，上面的代码实现很简单。看完了本文，你就会知道如何让几乎所有类型包括 int 、string 、自定义的类都支持 await 。</p>

<p>如果真的不想看原理，那么请直接调到文章的最后，看到最后很快就知道如何做。</p>

<h2 id="原理">原理</h2>

<p>在 .net 4.5 之后，框架默认提供 async 和 await 的语法糖，这时千万不要认为进入 await 就会进入一个新的线程，实际上不一定会进入一个新的线程才会调用 await 。</p>

<p>那么 await 的语法糖写的是什么？实际上就是以前的 Begin xx 和 End xx 的语法糖。</p>

<p>古时候的写法：</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">foo</span><span class="p">.</span><span class="nf">Beginxx</span><span class="p">();</span>

<span class="n">foo</span><span class="p">.</span><span class="nf">Endxx</span><span class="p">(</span><span class="err">传入委托</span><span class="p">);</span>
</code></pre></div></div>

<p>这样大家就无法在一个流程写完，需要分为两个东西，而在 Continus with 下，就需要传入委托。如果委托里又使用了异步，那么又需要传入委托</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>       <span class="n">task</span><span class="p">.</span><span class="nf">ContinueWith</span><span class="p">(</span><span class="n">_</span> <span class="p">=&gt;</span>
            <span class="p">{</span>
                <span class="n">Task</span> <span class="n">t1</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">Task</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="p">{</span> <span class="p">});</span>
                <span class="n">t1</span><span class="p">.</span><span class="nf">ContinueWith</span><span class="p">((</span><span class="n">t2</span><span class="p">)</span> <span class="p">=&gt;</span>
                <span class="p">{</span>
                    <span class="c1">//可以看到如果进入很多的委托</span>
                <span class="p">});</span>
            <span class="p">});</span>
</code></pre></div></div>

<p>所以这时就使用了 await ，可以让大家按照顺序写。</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">await</span> <span class="n">task</span><span class="p">;</span>
<span class="n">Task</span> <span class="n">t1</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">Task</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="p">{</span> <span class="p">});</span>
<span class="k">await</span> <span class="n">t1</span><span class="p">;</span>
<span class="c1">//可以看到这时不需要进入委托</span>
</code></pre></div></div>

<p>实际上 await 是在编译时支持的，请看<a href="http://www.cnblogs.com/brookshi/p/5240510.html">进阶篇：以IL为剑，直指async/await - 布鲁克石 - 博客园</a></p>

<p>而且千万不要认为 await 一定会进入一个新的线程，实际上他只是把需要写在多处的代码，可以按照流写下载，和写同步代码一样。如果感兴趣 await 不一定会进入一个新的线程请看 <a href="http://blog.stephencleary.com/2013/11/there-is-no-thread.html">There Is No Thread</a></p>

<h2 id="使用">使用</h2>

<p>因为 await 需要找到一个 GetAwaiter 函数，这个函数即使是扩展方法也可以，所以其实上面的代码是这样写的</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
    <span class="k">public</span> <span class="k">static</span> <span class="k">class</span> <span class="nc">KvpbamjhKsvm</span>
    <span class="p">{</span>
        <span class="k">public</span> <span class="k">static</span> <span class="n">HeabdsdnbKevx</span> <span class="nf">GetAwaiter</span><span class="p">(</span><span class="k">this</span> <span class="kt">string</span> <span class="n">str</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">return</span> <span class="k">new</span> <span class="nf">HeabdsdnbKevx</span><span class="p">();</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">public</span> <span class="k">class</span> <span class="nc">HeabdsdnbKevx</span> <span class="p">:</span> <span class="n">INotifyCompletion</span>
    <span class="p">{</span>
        <span class="k">public</span> <span class="kt">bool</span> <span class="n">IsCompleted</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="p">}</span>

        <span class="k">public</span> <span class="k">void</span> <span class="nf">GetResult</span><span class="p">()</span>
        <span class="p">{</span>
        <span class="p">}</span>

        <span class="c1">/// &lt;inheritdoc /&gt;</span>
        <span class="k">public</span> <span class="k">void</span> <span class="nf">OnCompleted</span><span class="p">(</span><span class="n">Action</span> <span class="n">continuation</span><span class="p">)</span>
        <span class="p">{</span>
        <span class="p">}</span>
    <span class="p">}</span>
</code></pre></div></div>

<p>HeabdsdnbKevx 就是一个可以等待的类型</p>

<p>现在就可以写出下面的代码</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        <span class="k">private</span> <span class="k">static</span> <span class="k">void</span> <span class="nf">Main</span><span class="p">(</span><span class="kt">string</span><span class="p">[]</span> <span class="n">args</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="nf">DdngSiwchjux</span><span class="p">();</span>
        <span class="p">}</span>

        <span class="k">private</span> <span class="k">static</span> <span class="k">async</span> <span class="k">void</span> <span class="nf">DdngSiwchjux</span><span class="p">()</span>
        <span class="p">{</span>
            <span class="k">await</span> <span class="s">"林德熙逗比"</span><span class="p">;</span>
        <span class="p">}</span>
</code></pre></div></div>

<p>当然，上面的这个代码可以运行，不过不会返回什么。下面让我加上一句代码。</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        <span class="k">private</span> <span class="k">static</span> <span class="k">void</span> <span class="nf">Main</span><span class="p">(</span><span class="kt">string</span><span class="p">[]</span> <span class="n">args</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="nf">DdngSiwchjux</span><span class="p">();</span>
        <span class="p">}</span>

        <span class="k">private</span> <span class="k">static</span> <span class="k">async</span> <span class="k">void</span> <span class="nf">DdngSiwchjux</span><span class="p">()</span>
        <span class="p">{</span>
            <span class="k">await</span> <span class="s">"林德熙逗比"</span><span class="p">;</span>
            <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="s">"csdn"</span><span class="p">);</span>
        <span class="p">}</span>
</code></pre></div></div>

<p>这时可以看到，<code class="language-plaintext highlighter-rouge">Console.WriteLine("csdn");</code>不会运行，因为这时如果在 <code class="language-plaintext highlighter-rouge">OnCompleted</code> 函数打断点就可以看到，执行<code class="language-plaintext highlighter-rouge">await "林德熙逗比"</code>之后就进入<code class="language-plaintext highlighter-rouge">OnCompleted</code> 函数。从上面的原理可以知道，这个函数传入的参数就是两个<code class="language-plaintext highlighter-rouge">await</code>或 <code class="language-plaintext highlighter-rouge">await</code>和函数结束之间的代码。如果需要让<code class="language-plaintext highlighter-rouge">Console.WriteLine("csdn");</code>运行，那么只需要在<code class="language-plaintext highlighter-rouge">OnCompleted</code>运行参数</p>

<p><img src="http://image.acmx.xyz/34fdad35-5dfe-a75b-2b4b-8c5e313038e2%2F2018211153416.jpg" alt="" /></p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   <span class="k">public</span> <span class="k">void</span> <span class="nf">OnCompleted</span><span class="p">(</span><span class="n">Action</span> <span class="n">continuation</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="nf">continuation</span><span class="p">();</span>
        <span class="p">}</span>
</code></pre></div></div>

<p><img src="http://image.acmx.xyz/34fdad35-5dfe-a75b-2b4b-8c5e313038e2%2F2018211154415.jpg" alt="" /></p>

<p>但是作为一个挖坑专业的大神，怎么可以就扩展 string ，下面我把 int 进行扩展</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="k">public</span> <span class="k">static</span> <span class="k">class</span> <span class="nc">KvpbamjhKsvm</span>
    <span class="p">{</span>
        <span class="k">public</span> <span class="k">static</span> <span class="n">HeabdsdnbKevx</span> <span class="nf">GetAwaiter</span><span class="p">(</span><span class="k">this</span> <span class="kt">int</span> <span class="n">dxpbnzSce</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">return</span> <span class="k">new</span> <span class="nf">HeabdsdnbKevx</span><span class="p">();</span>
        <span class="p">}</span>
    <span class="p">}</span>
</code></pre></div></div>

<p>随意写一个值，然后进行等待</p>

<p><img src="http://image.acmx.xyz/34fdad35-5dfe-a75b-2b4b-8c5e313038e2%2F2018211154944.jpg" alt="" /></p>

<p>现在我准备在 object 加一个扩展方法，所有类型都可以等待，然后把这个扩展方法的 namespace 写为 System ，这样大家就不知道这个是我写的，过了一年我就告诉大家这是 C# 的特性，所有的类都可以等待。但是这个特性需要开光才可以使用，你们直接建的项目没有开光所以没法使用这个特性。</p>

<h2 id="等待和不等待的区别">等待和不等待的区别</h2>

<p>虽然很多时候从原理上看，等待和不等待只是调用时机的问题。但是依旧遇到一些小伙伴一直以为全部的异步方法都需要<code class="language-plaintext highlighter-rouge">await</code>，看到我写了没有直接<code class="language-plaintext highlighter-rouge">await</code>的代码觉得很诡异，所以我在这里做个实验给大家看。</p>

<p>下面的代码是最常见的代码，在 <code class="language-plaintext highlighter-rouge">async Task</code> 的方法使用 <code class="language-plaintext highlighter-rouge">await</code> ，这样就会等待这个方法完成，代码就和同步代码一样。</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="k">await</span> <span class="nf">GagarLerecel</span><span class="p">();</span>
<span class="k">private</span> <span class="k">static</span> <span class="k">async</span> <span class="n">Task</span> <span class="nf">GagarLerecel</span><span class="p">()</span>
</code></pre></div></div>

<p>例如我这样写</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>            <span class="k">await</span> <span class="nf">GagarLerecel</span><span class="p">();</span>

        <span class="k">private</span> <span class="k">static</span> <span class="k">async</span> <span class="n">Task</span> <span class="nf">GagarLerecel</span><span class="p">()</span>
        <span class="p">{</span>
            <span class="nf">Write</span><span class="p">(</span><span class="s">"GagarLerecel 开始"</span><span class="p">);</span>
            <span class="k">await</span> <span class="n">Task</span><span class="p">.</span><span class="nf">Delay</span><span class="p">(</span><span class="m">100</span><span class="p">);</span>
            <span class="nf">Write</span><span class="p">(</span><span class="s">"GagarLerecel 完成"</span><span class="p">);</span>
        <span class="p">}</span>
</code></pre></div></div>

<p>输出就是按照顺序输出</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">GagarLerecel</span> <span class="err">开始</span>
<span class="n">GagarLerecel</span> <span class="err">完成</span>
</code></pre></div></div>

<p>如果我修改一下代码，创建一个新的函数 <code class="language-plaintext highlighter-rouge">CoujafuDarso</code> 里面的代码和上面函数相同</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        <span class="k">private</span> <span class="k">static</span> <span class="k">async</span> <span class="n">Task</span> <span class="nf">CoujafuDarso</span><span class="p">()</span>
        <span class="p">{</span>
            <span class="nf">Write</span><span class="p">(</span><span class="s">"CoujafuDarso开始"</span><span class="p">);</span>
            <span class="k">await</span> <span class="n">Task</span><span class="p">.</span><span class="nf">Delay</span><span class="p">(</span><span class="m">100</span><span class="p">);</span>
            <span class="nf">Write</span><span class="p">(</span><span class="s">"CoujafuDarso结束"</span><span class="p">);</span>
        <span class="p">}</span>
</code></pre></div></div>

<p>但是不在调用 <code class="language-plaintext highlighter-rouge">CoujafuDarso</code> 使用 await ，而是使用一个变量</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>            <span class="kt">var</span> <span class="n">aa</span> <span class="p">=</span> <span class="nf">CoujafuDarso</span><span class="p">();</span>
            <span class="nf">Write</span><span class="p">(</span><span class="s">"其他代码"</span><span class="p">);</span>
            <span class="k">await</span> <span class="n">aa</span><span class="p">;</span>
</code></pre></div></div>

<p>就是这样的代码，我的小伙伴说，这样写不清真，实际上这样写也是清真的代码。在调用 <code class="language-plaintext highlighter-rouge">CoujafuDarso</code> 会在代码到第一个 <code class="language-plaintext highlighter-rouge">await</code> 函数就返回，于是先执行了<code class="language-plaintext highlighter-rouge">CoujafuDarso开始</code>，然后函数返回，执行<code class="language-plaintext highlighter-rouge">Write("其他代码")</code>，在最后<code class="language-plaintext highlighter-rouge">await aa</code>才等待函数把所有代码执行完成。所以可以看到下面输出</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">CoujafuDarso</span><span class="err">开始</span>
<span class="err">其他代码</span>
<span class="n">CoujafuDarso</span><span class="err">结束</span>
</code></pre></div></div>

<p>但是不加 await 的呢？也就是函数一直都没有等待，我再写一个函数<code class="language-plaintext highlighter-rouge">BotujawWorpay</code></p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        <span class="k">private</span> <span class="k">static</span> <span class="k">async</span> <span class="n">Task</span> <span class="nf">BotujawWorpay</span><span class="p">()</span>
        <span class="p">{</span>
            <span class="nf">Write</span><span class="p">(</span><span class="s">"BotujawWorpay开始"</span><span class="p">);</span>
            <span class="k">await</span> <span class="n">Task</span><span class="p">.</span><span class="nf">Delay</span><span class="p">(</span><span class="m">100</span><span class="p">);</span>
            <span class="nf">Write</span><span class="p">(</span><span class="s">"BotujawWorpay结束"</span><span class="p">);</span>
        <span class="p">}</span>
</code></pre></div></div>

<p>调用的时候没有等待</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>            <span class="nf">BotujawWorpay</span><span class="p">();</span>
            <span class="nf">Write</span><span class="p">(</span><span class="s">"CesearJemmeme"</span><span class="p">);</span>
</code></pre></div></div>

<p>这时会在输出<code class="language-plaintext highlighter-rouge">CesearJemmeme</code>之后，某个时间继续执行函数</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">BotujawWorpay</span><span class="err">开始</span>
<span class="n">CesearJemmeme</span>
<span class="n">BotujawWorpay</span><span class="err">结束</span>
</code></pre></div></div>

<p>这样和使用 void 函数有什么区别？</p>

<p>在执行的函数遇到第一个 <code class="language-plaintext highlighter-rouge">await</code> 就会返回，这样就可以继续执行函数下面的代码</p>

<p><img src="http://image.acmx.xyz/lindexi%2F2018613944481469.jpg" alt="" />
<!-- ![](image/C＃ await 高级用法/C＃ await 高级用法0.png) --></p>

<p>输出下面代码</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">德熙逗比代码</span>
<span class="n">BarpooseewhowGelpousacall</span> <span class="err">代码</span><span class="m">1</span> <span class="err">线程</span><span class="m">1</span>
<span class="err">德熙逗比状态开始</span>
<span class="n">BarpooseewhowGelpousacall</span> <span class="err">代码</span><span class="m">2</span> <span class="err">线程</span><span class="m">5</span>
<span class="n">BarpooseewhowGelpousacall</span> <span class="err">代码</span><span class="m">3</span> <span class="err">线程</span><span class="m">4</span>
<span class="n">BarpooseewhowGelpousacall</span> <span class="err">完成</span> <span class="err">线程</span><span class="m">5</span>
</code></pre></div></div>

<h2 id="多线程">多线程</h2>

<p>不是所有的 await 都会开多线程，如下面的代码</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>       <span class="k">static</span> <span class="k">void</span> <span class="nf">Main</span><span class="p">(</span><span class="kt">string</span><span class="p">[]</span> <span class="n">args</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="nf">Write</span><span class="p">(</span><span class="s">"开始"</span><span class="p">);</span>
            <span class="nf">Write</span><span class="p">(</span><span class="s">"线程"</span> <span class="p">+</span> <span class="n">Thread</span><span class="p">.</span><span class="n">CurrentThread</span><span class="p">.</span><span class="n">ManagedThreadId</span><span class="p">);</span>

            <span class="nf">CeaXisci</span><span class="p">();</span>
            <span class="n">Task</span><span class="p">.</span><span class="nf">Run</span><span class="p">(</span><span class="k">async</span> <span class="p">()</span> <span class="p">=&gt;</span>
            <span class="p">{</span>
                <span class="k">await</span> <span class="n">Task</span><span class="p">.</span><span class="nf">Delay</span><span class="p">(</span><span class="m">1000</span><span class="p">);</span>
                <span class="nf">MouvaypuNasjo</span><span class="p">();</span>
            <span class="p">});</span>
            <span class="k">while</span> <span class="p">(</span><span class="k">true</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="n">Console</span><span class="p">.</span><span class="nf">Read</span><span class="p">();</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="k">private</span> <span class="k">static</span> <span class="k">async</span> <span class="n">Task</span> <span class="nf">BarpooseewhowGelpousacall</span><span class="p">()</span>
        <span class="p">{</span>
            <span class="nf">Write</span><span class="p">(</span><span class="s">"BarpooseewhowGelpousacall 代码1 线程"</span> <span class="p">+</span> <span class="n">Thread</span><span class="p">.</span><span class="n">CurrentThread</span><span class="p">.</span><span class="n">ManagedThreadId</span><span class="p">);</span>
            <span class="k">await</span> <span class="n">Task</span><span class="p">.</span><span class="nf">Delay</span><span class="p">(</span><span class="m">10</span><span class="p">);</span>
            <span class="nf">Write</span><span class="p">(</span><span class="s">"BarpooseewhowGelpousacall 代码2 线程"</span> <span class="p">+</span> <span class="n">Thread</span><span class="p">.</span><span class="n">CurrentThread</span><span class="p">.</span><span class="n">ManagedThreadId</span><span class="p">);</span>
            <span class="k">await</span> <span class="n">Task</span><span class="p">.</span><span class="nf">Delay</span><span class="p">(</span><span class="m">10</span><span class="p">);</span>
            <span class="nf">Write</span><span class="p">(</span><span class="s">"BarpooseewhowGelpousacall 完成 线程"</span> <span class="p">+</span> <span class="n">Thread</span><span class="p">.</span><span class="n">CurrentThread</span><span class="p">.</span><span class="n">ManagedThreadId</span><span class="p">);</span>
        <span class="p">}</span>
</code></pre></div></div>

<p>也就是在没有<code class="language-plaintext highlighter-rouge">Task.Delay</code>分开的代码，只要使用了 await 那么就可以在同个线程运行，请看输出。在最后的<code class="language-plaintext highlighter-rouge">BarpooseewhowGelpousacall 完成</code>和这个函数后面的代码都在同一个线程运行，而上面的代码，可能是在同个线程，也可能在不同的线程</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">开始</span>
<span class="err">线程</span><span class="m">1</span>
<span class="n">CeaXisci</span> <span class="err">开始</span> <span class="err">线程</span><span class="m">1</span>
<span class="n">BarpooseewhowGelpousacall</span> <span class="err">代码</span><span class="m">1</span> <span class="err">线程</span><span class="m">1</span>
<span class="n">BarpooseewhowGelpousacall</span> <span class="err">代码</span><span class="m">2</span> <span class="err">线程</span><span class="m">5</span>
<span class="n">BarpooseewhowGelpousacall</span> <span class="err">完成</span> <span class="err">线程</span><span class="m">4</span>
<span class="n">CeaXisci</span> <span class="err">开始</span> <span class="err">完成</span><span class="m">4</span>
</code></pre></div></div>

<h2 id="相关博客">相关博客</h2>

<p><a href="https://walterlv.github.io/post/deadlock-in-task-wait.html">使用 Task.Wait()？立刻死锁（deadlock） - walterlv</a></p>

<p><a href="https://walterlv.github.io/post/write-custom-awaiter.html">如何实现一个可以用 await 异步等待的 Awaiter</a></p>

:ET