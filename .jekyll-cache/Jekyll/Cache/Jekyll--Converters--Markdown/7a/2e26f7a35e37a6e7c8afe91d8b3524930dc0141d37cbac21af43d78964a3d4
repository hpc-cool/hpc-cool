I"DB<p>本文主要讲如何保存我们的屏幕显示的控件，保存为图片。这个也就是截图，截我们应用显示的，我们应用之外的不截图。</p>

<!--more-->

<!-- CreateTime:2019/9/2 12:57:38 -->

<div id="toc"></div>

<p>UWP有一个功能，可以截图，截图使用的类是 RenderTargetBitmap</p>

<p>我们首先写一个Grid，我们需要给他名字，我这里给他<code class="language-plaintext highlighter-rouge">Stamp</code>，需要名称可以让我们在后面使用截图用到元素。</p>

<p>然后我们可以使用<code class="language-plaintext highlighter-rouge">RenderTargetBitmap</code>保存我们屏幕Grid显示的元素，请看下面代码</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
            <span class="kt">var</span> <span class="n">bitmap</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">RenderTargetBitmap</span><span class="p">();</span>
            <span class="n">StorageFile</span> <span class="n">file</span> <span class="p">=</span> <span class="k">await</span> <span class="n">KnownFolders</span><span class="p">.</span><span class="n">PicturesLibrary</span><span class="p">.</span><span class="nf">CreateFileAsync</span><span class="p">(</span><span class="s">"1.jpg"</span><span class="p">,</span>
                <span class="n">CreationCollisionOption</span><span class="p">.</span><span class="n">GenerateUniqueName</span><span class="p">);</span>
            <span class="k">await</span> <span class="n">bitmap</span><span class="p">.</span><span class="nf">RenderAsync</span><span class="p">(</span><span class="n">Stamp</span><span class="p">);</span>
            <span class="kt">var</span> <span class="n">buffer</span> <span class="p">=</span> <span class="k">await</span> <span class="n">bitmap</span><span class="p">.</span><span class="nf">GetPixelsAsync</span><span class="p">();</span>
            <span class="k">using</span> <span class="p">(</span><span class="n">IRandomAccessStream</span> <span class="n">stream</span> <span class="p">=</span> <span class="k">await</span> <span class="n">file</span><span class="p">.</span><span class="nf">OpenAsync</span><span class="p">(</span><span class="n">FileAccessMode</span><span class="p">.</span><span class="n">ReadWrite</span><span class="p">))</span>
            <span class="p">{</span>
                <span class="kt">var</span> <span class="n">encod</span> <span class="p">=</span> <span class="k">await</span> <span class="n">BitmapEncoder</span><span class="p">.</span><span class="nf">CreateAsync</span><span class="p">(</span>
                    <span class="n">BitmapEncoder</span><span class="p">.</span><span class="n">JpegEncoderId</span><span class="p">,</span> <span class="n">stream</span><span class="p">);</span>
                <span class="n">encod</span><span class="p">.</span><span class="nf">SetPixelData</span><span class="p">(</span><span class="n">BitmapPixelFormat</span><span class="p">.</span><span class="n">Bgra8</span><span class="p">,</span>
                    <span class="n">BitmapAlphaMode</span><span class="p">.</span><span class="n">Ignore</span><span class="p">,</span>
                    <span class="p">(</span><span class="kt">uint</span><span class="p">)</span><span class="n">bitmap</span><span class="p">.</span><span class="n">PixelWidth</span><span class="p">,</span>
                    <span class="p">(</span><span class="kt">uint</span><span class="p">)</span><span class="n">bitmap</span><span class="p">.</span><span class="n">PixelHeight</span><span class="p">,</span>
                    <span class="n">DisplayInformation</span><span class="p">.</span><span class="nf">GetForCurrentView</span><span class="p">().</span><span class="n">LogicalDpi</span><span class="p">,</span>
                    <span class="n">DisplayInformation</span><span class="p">.</span><span class="nf">GetForCurrentView</span><span class="p">().</span><span class="n">LogicalDpi</span><span class="p">,</span>
                    <span class="n">buffer</span><span class="p">.</span><span class="nf">ToArray</span><span class="p">()</span>
                   <span class="p">);</span>
                <span class="k">await</span> <span class="n">encod</span><span class="p">.</span><span class="nf">FlushAsync</span><span class="p">();</span>
            <span class="p">}</span>

</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">await bitmap.RenderAsync(Stamp);</code> 能把一个UIelement显示转为图片，不过这个图片我们需要用 <code class="language-plaintext highlighter-rouge">BitmapEncoder</code> 才可以保存为我们的图片</p>

<p><code class="language-plaintext highlighter-rouge">BitmapEncoder</code>可以保存为bmp、jpg、gif、png，上面代码保存为 jpg ，但是一般保存为 png 比较好</p>

<p>保存需要使用<code class="language-plaintext highlighter-rouge">SetPixelData</code> <code class="language-plaintext highlighter-rouge">BitmapPixelFormat pixelFormat, BitmapAlphaMode alphaMode, System.UInt32 width, System.UInt32 height, System.Double dpiX, System.Double dpiY, [Range(0, int.MaxValue)] System.Byte[] pixels</code> 参数大概可以使用我的代码，不过上面代码使用的  dpi 不是 96 可能在不同的用户保存的图片不同。不过因为他截图的图片 像素本来就不是和其他的用户相同，所以使用这个方式保存是可以的。</p>

<p>我们在Grid放一个Image，然后可以看到，我们的原图</p>

<!-- ![这里写图片描述](http://img.blog.csdn.net/20160919155040537) -->

<!-- ![](image/win10-uwp-截图-获取屏幕显示界面保存图片/win10-uwp-截图-获取屏幕显示界面保存图片0.png) -->

<p><img src="http://image.acmx.xyz/lindexi%2F20181128103429509" alt="" /></p>

<!-- ![这里写图片描述](http://img.blog.csdn.net/20160919160057373) -->

<!-- ![](image/win10-uwp-截图-获取屏幕显示界面保存图片/win10-uwp-截图-获取屏幕显示界面保存图片1.png) -->

<p><img src="http://image.acmx.xyz/lindexi%2F20181128103450213" alt="" /></p>

<p>我们把图片一部分不显示，截图下来看下不显示的是不是就不会在图片。也就是截图是不是只截显示的元素</p>

<div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code>       <span class="nt">&lt;Grid</span> <span class="na">x:Name=</span><span class="s">"Stamp"</span> <span class="nt">&gt;</span>
            <span class="nt">&lt;Image</span> <span class="na">x:Name=</span><span class="s">"image"</span> <span class="na">Width=</span><span class="s">"500"</span>
                   <span class="na">Margin=</span><span class="s">"200,10,10,10"</span><span class="nt">&gt;</span>
            <span class="nt">&lt;/Image&gt;</span>
        <span class="nt">&lt;/Grid&gt;</span>

</code></pre></div></div>

<!-- ![这里写图片描述](http://img.blog.csdn.net/20160919161007340) -->

<!-- ![](image/win10-uwp-截图-获取屏幕显示界面保存图片/win10-uwp-截图-获取屏幕显示界面保存图片2.png) -->

<p><img src="http://image.acmx.xyz/lindexi%2F20181128103539240" alt="" /></p>

<p>可以看到图片有部分被裁掉</p>

<!-- ![这里写图片描述](http://img.blog.csdn.net/20160919161220562) -->

<!-- ![](image/win10-uwp-截图-获取屏幕显示界面保存图片/win10-uwp-截图-获取屏幕显示界面保存图片3.png) -->

<p><img src="http://image.acmx.xyz/lindexi%2F20181128103715456" alt="" /></p>

<p>假如我们不显示Grid，使用的方法就是让 Grid 被另一个 Grid 挡住，这时对被挡住的Grid截图，看是否还可以拿到 Grid 显示的内容。</p>

<div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="nt">&lt;Grid</span> <span class="na">Grid.Row=</span><span class="s">"0"</span> <span class="na">Background=</span><span class="s">"White"</span><span class="nt">&gt;&lt;/Grid&gt;</span>
</code></pre></div></div>

<p>截图之后可以看到结果没影响</p>

<p>那么我们要显示我们的图片显示全，我们可以借用一个简单的控件</p>

<div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        <span class="nt">&lt;ScrollViewer</span> <span class="na">VerticalScrollBarVisibility=</span><span class="s">"Visible"</span>
                      <span class="na">HorizontalScrollBarVisibility=</span><span class="s">"Visible"</span><span class="nt">&gt;</span>
            <span class="nt">&lt;Grid</span> <span class="na">x:Name=</span><span class="s">"Stamp"</span> <span class="nt">&gt;</span>
                <span class="nt">&lt;Image</span> <span class="na">x:Name=</span><span class="s">"image"</span> <span class="na">Width=</span><span class="s">"500"</span>
                   <span class="na">Margin=</span><span class="s">"300,10,10,10"</span><span class="nt">&gt;</span>
                <span class="nt">&lt;/Image&gt;</span>
            <span class="nt">&lt;/Grid&gt;</span>
        <span class="nt">&lt;/ScrollViewer&gt;</span>
</code></pre></div></div>

<p>我们的图片不会被遮盖，因为我们可以有无限空间</p>

<!-- ![这里写图片描述](http://img.blog.csdn.net/20160919161643284) -->

<!-- ![](image/win10-uwp-截图-获取屏幕显示界面保存图片/win10-uwp-截图-获取屏幕显示界面保存图片4.png) -->

<p><img src="http://image.acmx.xyz/lindexi%2F20181128103734746" alt="" /></p>

<!-- ![这里写图片描述](http://img.blog.csdn.net/20160919161712393) -->

<!-- ![](image/win10-uwp-截图-获取屏幕显示界面保存图片/win10-uwp-截图-获取屏幕显示界面保存图片5.png) -->

<p><img src="http://image.acmx.xyz/lindexi%2F20181128103746730" alt="" /></p>

<p>我们可以在滚动条写大小为很小，但是<code class="language-plaintext highlighter-rouge">Width="1"</code>就出错，我们不需要把他放在用户可视的，也就是放在最底层也是可以</p>

<h2 id="水印">水印</h2>

<p>UWP图片水印简单，我们需要一个Image和一个水印，水印在图片Zindex比他大</p>

<p>我们在我们图片的同个Panel放一个TextBlock，然后TextBlock就是我们的水印。</p>

<div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
            <span class="nt">&lt;Grid</span> <span class="na">x:Name=</span><span class="s">"Stamp"</span><span class="nt">&gt;</span>
                <span class="nt">&lt;Image</span> <span class="na">x:Name=</span><span class="s">"image"</span> <span class="na">Width=</span><span class="s">"500"</span>
                       <span class="na">Margin=</span><span class="s">"300,10,10,10"</span> <span class="nt">/&gt;</span>
                <span class="nt">&lt;TextBlock</span> <span class="na">Text=</span><span class="s">"blog.csdn.net/lindexi_gd"</span>
                           <span class="na">HorizontalAlignment=</span><span class="s">"Center"</span>
                           <span class="na">VerticalAlignment=</span><span class="s">"Center"</span> <span class="nt">/&gt;</span>
            <span class="nt">&lt;/Grid&gt;</span>

</code></pre></div></div>

<!-- ![这里写图片描述](http://img.blog.csdn.net/20160923165028626)  -->

<!-- ![](image/win10-uwp-截图-获取屏幕显示界面保存图片/win10-uwp-截图-获取屏幕显示界面保存图片6.png) -->

<p><img src="http://image.acmx.xyz/lindexi%2F2018112810395552" alt="" /></p>

<p>可以看到我们有了水印，虽然这样看起来一定都不觉得是好的。（我不想说很烂）</p>

<p>如果遇到了全黑的图，我们还没办法加水印，但是基本99%的图是可以的。（谁说的，代码是黑的，vs背景用黑的好多）</p>

<p>如果想要改颜色，每个颜色改为和图不同的，好难。</p>

<p>我想到渐变，这样每个颜色都有。LinearGradientBrush是渐变，我们需要每个字符都看到，我们把渐变改为从上到下。<code class="language-plaintext highlighter-rouge">EndPoint="0,1" StartPoint="0,0"</code>一个是开始的Point，一个是结束</p>

<div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
                    <span class="nt">&lt;TextBlock.Foreground&gt;</span>
                        <span class="nt">&lt;LinearGradientBrush</span> <span class="na">EndPoint=</span><span class="s">"结束点X,结束点Y"</span> <span class="na">StartPoint=</span><span class="s">"开始点X,开始点Y"</span><span class="nt">&gt;</span>
                            <span class="nt">&lt;GradientStop</span> <span class="na">Color=</span><span class="s">"颜色 默认offset=0"</span><span class="nt">/&gt;</span>
                            <span class="nt">&lt;GradientStop</span> <span class="na">Color=</span><span class="s">"White"</span> <span class="na">Offset=</span><span class="s">"1 1就是100%"</span><span class="nt">/&gt;</span>
                        <span class="nt">&lt;/LinearGradientBrush&gt;</span>
                    <span class="nt">&lt;/TextBlock.Foreground&gt;</span>

</code></pre></div></div>

<!-- ![这里写图片描述](http://img.blog.csdn.net/20160923180345146) -->

<!-- ![](image/win10-uwp-截图-获取屏幕显示界面保存图片/win10-uwp-截图-获取屏幕显示界面保存图片7.png) -->

<p><img src="http://image.acmx.xyz/lindexi%2F20181128103953800" alt="" /></p>

<p>说到这，我们来总的说下，就是用一个滚动条把我们的一个Grid放进去，然后Grid里面存在一张图片和一个TextBlock，图片就是我们需要加水印的，TextBlock就是水印，水印颜色最好渐变，然后使用获取元素图片截图。保存截图就是我们的图片加水印，做法很简单。</p>

<p>如果对大图感觉水印太小，可以用ViewBox。如果觉得我们水印要在中间，或下方或其他，那么我们需要把Image的宽度不设置，然后Grid也不设置高度和宽度。</p>

<div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
        <span class="nt">&lt;ScrollViewer</span> <span class="na">Width=</span><span class="s">"10"</span> <span class="na">Height=</span><span class="s">"10"</span>
            <span class="na">VerticalScrollBarVisibility=</span><span class="s">"Visible"</span>
                      <span class="na">HorizontalScrollBarVisibility=</span><span class="s">"Visible"</span><span class="nt">&gt;</span>
            <span class="nt">&lt;Grid</span> <span class="na">x:Name=</span><span class="s">"Stamp"</span><span class="nt">&gt;</span>
                <span class="nt">&lt;Image</span> <span class="na">x:Name=</span><span class="s">"image"</span> <span class="na">HorizontalAlignment=</span><span class="s">"Left"</span>
                       <span class="na">VerticalAlignment=</span><span class="s">"Top"</span>
                       <span class="na">Margin=</span><span class="s">"10,10,10,10"</span> <span class="nt">/&gt;</span>
                <span class="nt">&lt;TextBlock</span> <span class="na">Text=</span><span class="s">"blog.csdn.net/lindexi_gd"</span>
                           <span class="na">HorizontalAlignment=</span><span class="s">"Center"</span>
                           <span class="na">VerticalAlignment=</span><span class="s">"Center"</span> <span class="nt">&gt;</span>
                    <span class="nt">&lt;TextBlock.Foreground&gt;</span>
                        <span class="nt">&lt;LinearGradientBrush</span> <span class="na">EndPoint=</span><span class="s">"0,1"</span> <span class="na">StartPoint=</span><span class="s">"0,0"</span><span class="nt">&gt;</span>
                            <span class="nt">&lt;GradientStop</span> <span class="na">Color=</span><span class="s">"Black"</span><span class="nt">/&gt;</span>
                            <span class="nt">&lt;GradientStop</span> <span class="na">Color=</span><span class="s">"White"</span> <span class="na">Offset=</span><span class="s">"1"</span><span class="nt">/&gt;</span>
                        <span class="nt">&lt;/LinearGradientBrush&gt;</span>
                    <span class="nt">&lt;/TextBlock.Foreground&gt;</span>
                <span class="nt">&lt;/TextBlock&gt;</span>
            <span class="nt">&lt;/Grid&gt;</span>
        <span class="nt">&lt;/ScrollViewer&gt;</span>

</code></pre></div></div>

<p>参见：http://www.zmy123.cn/?p=1257</p>

<p>因为保存的图片比较大，我在找压缩图片的算法，找到了这个博客 <a href="http://blog.csdn.net/chinacsharper/article/details/9865491">用C#开发一个WinForm版的批量图片压缩工具 - CSDN博客</a> 还有 <a href="http://blog.csdn.net/chinacsharper/article/details/50854852">GDI+ 如何将图片绘制成圆形的图片 - CSDN博客</a></p>

:ET