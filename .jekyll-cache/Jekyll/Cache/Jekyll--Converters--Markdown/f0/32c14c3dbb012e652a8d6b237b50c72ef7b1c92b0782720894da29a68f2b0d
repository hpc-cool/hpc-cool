I"gR<p>我在 Office 的 Open-XML-SDK 库里面找到有代码线程不安全，代码里面使用了 TryGetValue 加 TryAdd 的方法添加对象，而线程安全的方法是通过 GetOrAdd 方法。不过在小伙伴的评论我找到了 GetOrAdd 性能其实在有闭包的时候不如使用 TryGetValue 加 TryAdd 调用这两个方法，但是 GetOrAdd 的优势在于能做到只创建一次对象</p>

<!--more-->

<!-- CreateTime:2020/7/16 11:00:59 -->

<p>在 <a href="https://github.com/OfficeDev/Open-XML-SDK/pull/758">Avoid multi-thread creates ElementMetadata object by lindexi · Pull Request #758 · OfficeDev/Open-XML-SDK</a> 我找到了 OpenXML SDK 的代码存在线程不安全，代码如下</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        <span class="k">public</span> <span class="k">static</span> <span class="n">ElementMetadata</span> <span class="nf">Create</span><span class="p">(</span><span class="n">OpenXmlElement</span> <span class="n">element</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="kt">var</span> <span class="n">type</span> <span class="p">=</span> <span class="n">element</span><span class="p">.</span><span class="nf">GetType</span><span class="p">();</span>

            <span class="c1">// Use TryGetValue first for the common case of already existing types to limit number of allocations</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">_lookup</span><span class="p">.</span><span class="nf">TryGetValue</span><span class="p">(</span><span class="n">type</span><span class="p">,</span> <span class="k">out</span> <span class="kt">var</span> <span class="n">result</span><span class="p">))</span>
            <span class="p">{</span>
                <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="c1">// 假设有两个线程进来，此时两个线程都判断 TryGetValue 不存在，于是就会使用 CreateInternal 创建对象</span>

            <span class="kt">var</span> <span class="n">metadata</span> <span class="p">=</span> <span class="nf">CreateInternal</span><span class="p">(</span><span class="n">element</span><span class="p">);</span>

            <span class="n">_lookup</span><span class="p">.</span><span class="nf">TryAdd</span><span class="p">(</span><span class="n">type</span><span class="p">,</span> <span class="n">metadata</span><span class="p">);</span>

            <span class="k">return</span> <span class="n">metadata</span><span class="p">;</span>
        <span class="p">}</span>
</code></pre></div></div>

<p>也就是调用 Create 多线程调用将会创建多个不同的实例，如果修改为 GetOrAdd 方法，那么只会创建一个对象实例</p>

<p>但是如果在对象创建的时间可以忽略的前提下，如 CreateInternal 方法的耗时可以忽略，同时在 OpenXML 的这个业务里面，其实多创建对象是没有问题的，那么此时使用 TryGetValue 加上 TryAdd 的方法的性能会比使用 GetOrAdd 的性能高</p>

<p>这是我更改的方法，使用 GetOrAdd 可以做到只创建一个对象</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        <span class="k">public</span> <span class="k">static</span> <span class="n">ElementMetadata</span> <span class="nf">Create2</span><span class="p">(</span><span class="n">OpenXmlElement</span> <span class="n">element</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="kt">var</span> <span class="n">type</span> <span class="p">=</span> <span class="n">element</span><span class="p">.</span><span class="nf">GetType</span><span class="p">();</span>

            <span class="c1">// Use GetOrAdd first for the common case of already existing types to limit number of allocations</span>
            <span class="k">return</span> <span class="n">_lookup</span><span class="p">.</span><span class="nf">GetOrAdd</span><span class="p">(</span><span class="n">type</span><span class="p">,</span> <span class="n">_</span> <span class="p">=&gt;</span> <span class="nf">CreateInternal</span><span class="p">(</span><span class="n">element</span><span class="p">));</span>
        <span class="p">}</span>
</code></pre></div></div>

<p>此时做性能测试对比，性能测试的代码放在本文最后</p>

<p>可以看到使用 Create 方法的性能更好，同时申请的对象也更少</p>

<!-- ![](image/dotnet ConcurrentDictionary 的 GetOrAdd 性能比 TryGetValue 加 TryAdd 低/dotnet ConcurrentDictionary 的 GetOrAdd 性能比 TryGetValue 加 TryAdd 低0.png) -->

<p><img src="http://image.acmx.xyz/lindexi%2F2020716116373889.jpg" alt="" /></p>

<table>
  <thead>
    <tr>
      <th>Method</th>
      <th style="text-align: right">Mean</th>
      <th style="text-align: right">Error</th>
      <th style="text-align: right">StdDev</th>
      <th style="text-align: right">Gen 0</th>
      <th style="text-align: right">Gen 1</th>
      <th style="text-align: right">Gen 2</th>
      <th style="text-align: right">Allocated</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Create</td>
      <td style="text-align: right">22.19 ns</td>
      <td style="text-align: right">0.154 ns</td>
      <td style="text-align: right">0.144 ns</td>
      <td style="text-align: right">-</td>
      <td style="text-align: right">-</td>
      <td style="text-align: right">-</td>
      <td style="text-align: right">-</td>
    </tr>
    <tr>
      <td>Create2</td>
      <td style="text-align: right">37.22 ns</td>
      <td style="text-align: right">0.337 ns</td>
      <td style="text-align: right">0.315 ns</td>
      <td style="text-align: right">0.0210</td>
      <td style="text-align: right">-</td>
      <td style="text-align: right">-</td>
      <td style="text-align: right">88 B</td>
    </tr>
  </tbody>
</table>

<p>为什么 Create2 方法会更慢，同时需要申请内存？原因是调用</p>

<p>每次使用 GetOrAdd 方法都需要创建一个 Lambda 表达式和传入参数，需要创建类，所以性能上不如原先代码</p>

<p>那么如果没有闭包呢？</p>

<p>接下来我测试了值存在和不存在等的比较，测试效果如下 GetOrAdd 需要传入一个 Lambda 表达式，这个表达式需要传入一个 element 变量，这将需要创建一个闭包</p>

<div class="language-ini highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="py">BenchmarkDotNet</span><span class="p">=</span><span class="s">v0.12.1, OS=Windows 10.0.19041.264 (19062/3/20H1)</span>
<span class="err">Intel</span> <span class="err">Core</span> <span class="err">i7-6700</span> <span class="err">CPU</span> <span class="err">3.40GHz</span> <span class="err">(Skylake),</span> <span class="err">1</span> <span class="err">CPU,</span> <span class="err">8</span> <span class="err">logical</span> <span class="err">and</span> <span class="err">4</span> <span class="err">physical</span> <span class="err">cores</span>
<span class="err">.NET</span> <span class="err">Core</span> <span class="py">SDK</span><span class="p">=</span><span class="s">3.1.301</span>
  <span class="nn">[Host]</span>     <span class="err">:</span> <span class="err">.NET</span> <span class="err">Core</span> <span class="err">3.1.5</span> <span class="err">(CoreCLR</span> <span class="err">4.700.20.26901,</span> <span class="err">CoreFX</span> <span class="err">4.700.20.27001),</span> <span class="err">X64</span> <span class="err">RyuJIT</span>
  <span class="err">DefaultJob</span> <span class="err">:</span> <span class="err">.NET</span> <span class="err">Core</span> <span class="err">3.1.5</span> <span class="err">(CoreCLR</span> <span class="err">4.700.20.26901,</span> <span class="err">CoreFX</span> <span class="err">4.700.20.27001),</span> <span class="err">X64</span> <span class="err">RyuJIT</span>


</code></pre></div></div>

<table>
  <thead>
    <tr>
      <th>Method</th>
      <th style="text-align: right">Mean</th>
      <th style="text-align: right">Error</th>
      <th style="text-align: right">StdDev</th>
      <th style="text-align: right">Median</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>GetOrAddExistWithClosed</td>
      <td style="text-align: right">1.702 μs</td>
      <td style="text-align: right">0.0339 μs</td>
      <td style="text-align: right">0.0772 μs</td>
      <td style="text-align: right">1.659 μs</td>
    </tr>
    <tr>
      <td>GetOrAddExistWithValue</td>
      <td style="text-align: right">1.586 μs</td>
      <td style="text-align: right">0.0460 μs</td>
      <td style="text-align: right">0.1335 μs</td>
      <td style="text-align: right">1.518 μs</td>
    </tr>
    <tr>
      <td>GetOrAddNotExistWithClosed</td>
      <td style="text-align: right">1.422 μs</td>
      <td style="text-align: right">0.0181 μs</td>
      <td style="text-align: right">0.0141 μs</td>
      <td style="text-align: right">1.417 μs</td>
    </tr>
    <tr>
      <td>GetOrAddNotExistWithValue</td>
      <td style="text-align: right">1.591 μs</td>
      <td style="text-align: right">0.0665 μs</td>
      <td style="text-align: right">0.1940 μs</td>
      <td style="text-align: right">1.529 μs</td>
    </tr>
    <tr>
      <td>GetOrAddExistWithoutClosed</td>
      <td style="text-align: right">1.986 μs</td>
      <td style="text-align: right">0.0204 μs</td>
      <td style="text-align: right">0.0180 μs</td>
      <td style="text-align: right">1.991 μs</td>
    </tr>
    <tr>
      <td>GetOrAddNotExistWithoutClosed</td>
      <td style="text-align: right">2.054 μs</td>
      <td style="text-align: right">0.0167 μs</td>
      <td style="text-align: right">0.0130 μs</td>
      <td style="text-align: right">2.057 μs</td>
    </tr>
    <tr>
      <td>TryGetValueExist</td>
      <td style="text-align: right">1.149 μs</td>
      <td style="text-align: right">0.0132 μs</td>
      <td style="text-align: right">0.0117 μs</td>
      <td style="text-align: right">1.144 μs</td>
    </tr>
    <tr>
      <td>TryGetValueNotExist</td>
      <td style="text-align: right">1.281 μs</td>
      <td style="text-align: right">0.0353 μs</td>
      <td style="text-align: right">0.1019 μs</td>
      <td style="text-align: right">1.229 μs</td>
    </tr>
  </tbody>
</table>

<p>这里的 TryGetValueNotExist 就是使用 TryGetValue 判断之后再使用 TryAdd 加回去。同时每个 Key 都是不存在的，代码如下</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        <span class="p">[</span><span class="n">Benchmark</span><span class="p">]</span>
        <span class="k">public</span> <span class="kt">object</span> <span class="nf">TryGetValueNotExist</span><span class="p">()</span>
        <span class="p">{</span>
            <span class="kt">object</span> <span class="n">o</span> <span class="p">=</span> <span class="k">null</span><span class="p">;</span>
            <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="p">&lt;</span> <span class="n">Count</span><span class="p">;</span> <span class="n">i</span><span class="p">++)</span>
            <span class="p">{</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">_concurrentDictionary</span><span class="p">.</span><span class="nf">TryGetValue</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="k">out</span> <span class="kt">var</span> <span class="k">value</span><span class="p">))</span>
                <span class="p">{</span>
                <span class="p">}</span>
                <span class="k">else</span>
                <span class="p">{</span>
                    <span class="n">o</span> <span class="p">=</span> <span class="nf">GetObject</span><span class="p">();</span>

                    <span class="n">_concurrentDictionary</span><span class="p">.</span><span class="nf">TryAdd</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">o</span><span class="p">);</span>
                <span class="p">}</span>
            <span class="p">}</span>

            <span class="k">return</span> <span class="n">o</span><span class="p">;</span>
        <span class="p">}</span>
</code></pre></div></div>

<p>而 GetOrAddExistWithClosed 就是使用 GetOrAdd 方法，同时 Key 是存在的，也就是每次获取的都是存在的相同的值。而 Closed 表示闭包，也就是存在一次闭包的委托创建，代码如下</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        <span class="p">[</span><span class="n">Benchmark</span><span class="p">]</span>
        <span class="k">public</span> <span class="kt">object</span> <span class="nf">GetOrAddExistWithClosed</span><span class="p">()</span>
        <span class="p">{</span>
            <span class="kt">object</span> <span class="n">o</span> <span class="p">=</span> <span class="k">null</span><span class="p">;</span>
            <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="p">&lt;</span> <span class="n">Count</span><span class="p">;</span> <span class="n">i</span><span class="p">++)</span>
            <span class="p">{</span>
                <span class="n">o</span> <span class="p">=</span> <span class="nf">GetObject</span><span class="p">();</span>

                <span class="n">_concurrentDictionary</span><span class="p">.</span><span class="nf">GetOrAdd</span><span class="p">(-</span><span class="m">1</span><span class="p">,</span> <span class="n">_</span> <span class="p">=&gt;</span> <span class="n">o</span><span class="p">);</span>
            <span class="p">}</span>

            <span class="k">return</span> <span class="n">o</span><span class="p">;</span>
        <span class="p">}</span>
</code></pre></div></div>

<p>在 GetOrAdd 还有重载的方法，可以传入需要的参数，也就是 GetOrAddExistWithValue 方法，此时没有传入闭包，而是传入参数</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        <span class="p">[</span><span class="n">Benchmark</span><span class="p">]</span>
        <span class="k">public</span> <span class="kt">object</span> <span class="nf">GetOrAddExistWithValue</span><span class="p">()</span>
        <span class="p">{</span>
            <span class="kt">object</span> <span class="n">o</span> <span class="p">=</span> <span class="nf">GetObject</span><span class="p">();</span>
            <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="p">&lt;</span> <span class="n">Count</span><span class="p">;</span> <span class="n">i</span><span class="p">++)</span>
            <span class="p">{</span>
                <span class="n">o</span> <span class="p">=</span> <span class="n">_concurrentDictionary</span><span class="p">.</span><span class="nf">GetOrAdd</span><span class="p">(-</span><span class="m">1</span><span class="p">,</span> <span class="p">(</span><span class="n">_</span><span class="p">,</span> <span class="k">value</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="k">value</span><span class="p">,</span> <span class="n">o</span><span class="p">);</span>
            <span class="p">}</span>

            <span class="k">return</span> <span class="n">o</span><span class="p">;</span>
        <span class="p">}</span>
</code></pre></div></div>

<p>同时测试了不传入闭包，也就是使用类的方法，代码如下</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        <span class="p">[</span><span class="n">Benchmark</span><span class="p">]</span>
        <span class="k">public</span> <span class="kt">object</span> <span class="nf">GetOrAddExistWithoutClosed</span><span class="p">()</span>
        <span class="p">{</span>
            <span class="kt">object</span> <span class="n">o</span> <span class="p">=</span> <span class="k">null</span><span class="p">;</span>
            <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="p">&lt;</span> <span class="n">Count</span><span class="p">;</span> <span class="n">i</span><span class="p">++)</span>
            <span class="p">{</span>
                <span class="n">o</span> <span class="p">=</span> <span class="n">_concurrentDictionary</span><span class="p">.</span><span class="nf">GetOrAdd</span><span class="p">(-</span><span class="m">1</span><span class="p">,</span> <span class="n">_</span> <span class="p">=&gt;</span> <span class="nf">GetObject</span><span class="p">());</span>
            <span class="p">}</span>

            <span class="k">return</span> <span class="n">o</span><span class="p">;</span>
        <span class="p">}</span>
</code></pre></div></div>

<p>上面是测试 <code class="language-plaintext highlighter-rouge">_concurrentDictionary</code> 存在值的，因为在初始化给了 <code class="language-plaintext highlighter-rouge">-1</code> 的值，也就是每次获取都是存在值的</p>

<p>如果每次都是 Key 不存在的，也测试了性能就是对应的 <code class="language-plaintext highlighter-rouge">NotExist</code> 方法</p>

<p>上面测试的代码放在 <a href="https://github.com/lindexi/lindexi_gd/tree/4f1793cb116e8609ec09c2c6f00c63413ba96aca/YawyahunecafeCorekeenaine">github</a> 欢迎小伙伴访问</p>

<p>这是在 OpenXML 的性能测试代码</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Copyright (c) Microsoft. All rights reserved.</span>
<span class="c1">// Licensed under the MIT license. See LICENSE file in the project root for full license information.</span>
<span class="k">using</span> <span class="nn">BenchmarkDotNet.Attributes</span><span class="p">;</span>
<span class="k">using</span> <span class="nn">DocumentFormat.OpenXml.Framework.Metadata</span><span class="p">;</span>

<span class="k">namespace</span> <span class="nn">DocumentFormat.OpenXml.Benchmarks</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="k">class</span> <span class="nc">ElementMetadataTests</span>
    <span class="p">{</span>
        <span class="p">[</span><span class="n">GlobalSetup</span><span class="p">]</span>
        <span class="k">public</span> <span class="k">void</span> <span class="nf">Setup</span><span class="p">()</span>
        <span class="p">{</span>
            <span class="n">_element</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">AlternateContent</span><span class="p">();</span>
        <span class="p">}</span>

        <span class="k">private</span> <span class="n">OpenXmlElement</span> <span class="n">_element</span><span class="p">;</span>

        <span class="p">[</span><span class="nf">BenchmarkCategory</span><span class="p">(</span><span class="s">"ElementMetadataTests"</span><span class="p">)]</span>
        <span class="p">[</span><span class="n">Benchmark</span><span class="p">]</span>
        <span class="k">public</span> <span class="k">void</span> <span class="nf">Create</span><span class="p">()</span>
        <span class="p">{</span>
            <span class="n">_</span> <span class="p">=</span> <span class="n">ElementMetadata</span><span class="p">.</span><span class="nf">Create</span><span class="p">(</span><span class="n">_element</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="p">[</span><span class="nf">BenchmarkCategory</span><span class="p">(</span><span class="s">"ElementMetadataTests"</span><span class="p">)]</span>
        <span class="p">[</span><span class="n">Benchmark</span><span class="p">]</span>
        <span class="k">public</span> <span class="k">void</span> <span class="nf">Create2</span><span class="p">()</span>
        <span class="p">{</span>
            <span class="n">_</span> <span class="p">=</span> <span class="n">ElementMetadata</span><span class="p">.</span><span class="nf">Create2</span><span class="p">(</span><span class="n">_element</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

:ET