I"
e<p>本文是分析 .net Framework 源代码的系列，主要告诉大家微软做 ScrollViewer 的思路，分析很简单。
看完本文，可以学会如何写一个 ScrollViewer ，如何定义一个 IScrollInfo 或者给他滚动添加动画</p>

<!--more-->

<!-- CreateTime:2019/10/7 13:15:25 -->

<!-- 标签：C#，.net Framework，源代码分析，wpf，ScrollViewer ，dotnet,WPF源代码 -->

<div id="toc"></div>

<h2 id="使用">使用</h2>

<p>下面告诉大家如何简单使用 ScrollViewer ，一般在需要滚动的控件外面放一个 ScrollViewer 就可以实现滚动。</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="p">&lt;</span><span class="n">ScrollViewer</span> <span class="n">HorizontalScrollBarVisibility</span><span class="p">=</span><span class="s">"Auto"</span><span class="p">&gt;</span>
    <span class="p">&lt;</span><span class="n">StackPanel</span> <span class="n">VerticalAlignment</span><span class="p">=</span><span class="s">"Top"</span> <span class="n">HorizontalAlignment</span><span class="p">=</span><span class="s">"Left"</span><span class="p">&gt;</span>
      <span class="p">&lt;</span><span class="n">TextBlock</span> <span class="n">TextWrapping</span><span class="p">=</span><span class="s">"Wrap"</span> <span class="n">Margin</span><span class="p">=</span><span class="s">"0,0,0,20"</span><span class="p">&gt;</span><span class="n">Scrolling</span> <span class="k">is</span> <span class="n">enabled</span> <span class="n">when</span> <span class="n">it</span> <span class="k">is</span> <span class="n">necessary</span><span class="p">.</span> 
      <span class="n">Resize</span> <span class="n">the</span> <span class="n">window</span><span class="p">,</span> <span class="n">making</span> <span class="n">it</span> <span class="n">larger</span> <span class="n">and</span> <span class="n">smaller</span><span class="p">.&lt;/</span><span class="n">TextBlock</span><span class="p">&gt;</span>
      <span class="p">&lt;</span><span class="n">Rectangle</span> <span class="n">Fill</span><span class="p">=</span><span class="s">"Red"</span> <span class="n">Width</span><span class="p">=</span><span class="s">"500"</span> <span class="n">Height</span><span class="p">=</span><span class="s">"500"</span><span class="p">&gt;&lt;/</span><span class="n">Rectangle</span><span class="p">&gt;</span>
    <span class="p">&lt;/</span><span class="n">StackPanel</span><span class="p">&gt;</span>
  <span class="p">&lt;/</span><span class="n">ScrollViewer</span><span class="p">&gt;</span>
</code></pre></div></div>

<p>但不是所有的控件外面放一个 ScrollViewer 都能实现滚动，因为滚动实际上需要控件自己做。</p>

<h2 id="原理">原理</h2>

<p>下面来告诉大家滚动是如何做的。</p>

<p>一个最简单的方法是设置元素的 <code class="language-plaintext highlighter-rouge">transForm.Y</code> 通过这个方式进行滚动是最简单的方法，但是缺点是其他控件不能做其他的移动。</p>

<p>在 ScrollViewer 存在两个滚动方式，物理滚动 和 逻辑滚动，如果使用 物理滚动 那么滚动就是ScrollViewer做的，如何使用逻辑滚动，那么滚动就是控件自己做的。</p>

<p>那么我从 ScrollViewer 接收输入开始讲起</p>

<h3 id="输入">输入</h3>

<p>如果大家使用 ScrollViewer 进行滚动，那么也许会遇到一个神奇的需求，如何在触摸下滚动。是的，如果使用一个简单的 ScrollViewer 是无法使用触摸滚动</p>

<p>请看代码，写一个简单的 ScrollViewer 里面有一些矩形，可以看到这时可以进行鼠标滚动，但是触摸是无法滚动。</p>

<p><img src="http://image.acmx.xyz/65fb6078-c169-4ce3-cdd9-e35752d07be0%2F2018313153148.jpg" alt="" /></p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="p">&lt;</span><span class="n">Grid</span><span class="p">&gt;</span>
        <span class="p">&lt;</span><span class="n">ScrollViewer</span><span class="p">&gt;</span>
            <span class="p">&lt;</span><span class="n">StackPanel</span> <span class="n">x</span><span class="p">:</span><span class="n">Name</span><span class="p">=</span><span class="s">"HcrkKmqnnfzo"</span><span class="p">&gt;&lt;/</span><span class="n">StackPanel</span><span class="p">&gt;</span>
        <span class="p">&lt;/</span><span class="n">ScrollViewer</span><span class="p">&gt;</span>
    <span class="p">&lt;/</span><span class="n">Grid</span><span class="p">&gt;</span>
</code></pre></div></div>

<p>在后台遍历颜色然后添加</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        <span class="k">public</span> <span class="nf">MainWindow</span><span class="p">()</span>
        <span class="p">{</span>
            <span class="nf">InitializeComponent</span><span class="p">();</span>

            <span class="k">foreach</span> <span class="p">(</span><span class="kt">var</span> <span class="n">temp</span> <span class="k">in</span> <span class="k">typeof</span><span class="p">(</span><span class="n">Brushes</span><span class="p">)</span>
                <span class="p">.</span><span class="nf">GetProperties</span><span class="p">(</span><span class="n">BindingFlags</span><span class="p">.</span><span class="n">Static</span> <span class="p">|</span> <span class="n">BindingFlags</span><span class="p">.</span><span class="n">Public</span> <span class="p">|</span> <span class="n">BindingFlags</span><span class="p">.</span><span class="n">NonPublic</span><span class="p">)</span>
                <span class="p">.</span><span class="nf">Select</span><span class="p">(</span><span class="n">temp</span> <span class="p">=&gt;</span> <span class="n">temp</span><span class="p">.</span><span class="nf">GetValue</span><span class="p">(</span><span class="k">null</span><span class="p">,</span> <span class="k">null</span><span class="p">)))</span>
            <span class="p">{</span>
                <span class="kt">var</span> <span class="n">rectangle</span> <span class="p">=</span> <span class="k">new</span> <span class="n">Rectangle</span>
                <span class="p">{</span>
                    <span class="n">Height</span> <span class="p">=</span> <span class="m">20</span><span class="p">,</span>
                    <span class="n">Fill</span> <span class="p">=</span> <span class="p">(</span><span class="n">Brush</span><span class="p">)</span><span class="n">temp</span>
                <span class="p">};</span>

                <span class="n">HcrkKmqnnfzo</span><span class="p">.</span><span class="n">Children</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="n">rectangle</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>
</code></pre></div></div>

<p>代码：<a href="https://download.csdn.net/download/lindexi_gd/10284083">WPF ScrollView 代码解释 1.1-CSDN下载</a></p>

<p>如果没有csdn积分，尝试使用 <a href="http://lindexi.ml:8080/index.php/s/zavJRGtNeBbu8Yg">我的网盘</a>，但是我的网盘如果过期请告诉我</p>

<p>如果需要在触摸使用滚动，那么需要设置<code class="language-plaintext highlighter-rouge">PanningMode</code>，可以设置支持垂直拖动。</p>

<p>如果这时设置了<code class="language-plaintext highlighter-rouge">PanningMode</code>，就会发现拖动时让窗口抖动，这时需要在窗口重写 OnManipulationBoundaryFeedback ，请看下面代码。函数里面什么都不要写，详细请看 https://stackoverflow.com/a/6918131/6116637</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>       <span class="k">protected</span> <span class="k">override</span> <span class="k">void</span> <span class="nf">OnManipulationBoundaryFeedback</span><span class="p">(</span><span class="n">ManipulationBoundaryFeedbackEventArgs</span> <span class="n">e</span><span class="p">)</span>
        <span class="p">{</span>
        <span class="p">}</span>
</code></pre></div></div>

<p>修改后的代码：<a href="https://download.csdn.net/download/lindexi_gd/10284122">WPF ScrollView 代码解释 1.2-CSDN下载</a></p>

<p>那么在鼠标滚动是如何收到滚动？</p>

<p>从微软源代码可以看到 ScrollViewer 继承 ContentControl，所以可以重写 OnMouseWheel ，请看他的代码</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>      <span class="k">protected</span> <span class="k">override</span> <span class="k">void</span> <span class="nf">OnMouseWheel</span><span class="p">(</span><span class="n">MouseWheelEventArgs</span> <span class="n">e</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">e</span><span class="p">.</span><span class="n">Handled</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span><span class="p">;</span> <span class="p">}</span>
 
            <span class="k">if</span> <span class="p">(!</span><span class="n">HandlesMouseWheelScrolling</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="k">return</span><span class="p">;</span>
            <span class="p">}</span>
 
            <span class="k">if</span> <span class="p">(</span><span class="n">ScrollInfo</span> <span class="p">!=</span> <span class="k">null</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">e</span><span class="p">.</span><span class="n">Delta</span> <span class="p">&lt;</span> <span class="m">0</span><span class="p">)</span> <span class="p">{</span> <span class="n">ScrollInfo</span><span class="p">.</span><span class="nf">MouseWheelDown</span><span class="p">();</span> <span class="p">}</span>
                <span class="k">else</span> <span class="p">{</span> <span class="n">ScrollInfo</span><span class="p">.</span><span class="nf">MouseWheelUp</span><span class="p">();</span> <span class="p">}</span>
            <span class="p">}</span>
 
            <span class="n">e</span><span class="p">.</span><span class="n">Handled</span> <span class="p">=</span> <span class="k">true</span><span class="p">;</span>
        <span class="p">}</span>
</code></pre></div></div>

<p>实际上 ScrollViewer 是不做滚动的，实际的滚动是 ScrollInfo 进行滚动。</p>

<h3 id="scrollinfo">ScrollInfo</h3>

<p>那么 ScrollInfo 是什么，实际上他是一个接口，在 ScrollViewer 里面放的控件实际上不是直接放在 ScrollViewer 里，控件是放在 <code class="language-plaintext highlighter-rouge">ScrollContentPresenter</code>，而 ScrollContentPresenter 是写在 ScrollViewer 的 Style 里，在 ScrollViewer 可以看到这个代码</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">[</span><span class="nf">TemplatePart</span><span class="p">(</span><span class="n">Name</span> <span class="p">=</span> <span class="s">"PART_ScrollContentPresenter"</span><span class="p">,</span> <span class="n">Type</span> <span class="p">=</span> <span class="k">typeof</span><span class="p">(</span><span class="n">ScrollContentPresenter</span><span class="p">))]</span>
</code></pre></div></div>

<p>但是从垃圾微软的代码可以看到，没有属性直接使用这个，而是在使用的地方这样写<code class="language-plaintext highlighter-rouge">GetTemplateChild(ScrollContentPresenterTemplateName) as ScrollContentPresenter;</code></p>

<p>这样写的性能是比较差的。</p>

<p>那么他是如何给 ScrollInfo 赋值？实际上在这个类的 HookupScrollingComponents 就是给 ScrollInfo 赋值，在 HookupScrollingComponents 调用的地方就是  OnApplyTemplate 所以大家可以看到，在初始化的时候就已经知道了控件。</p>

<p>从垃圾微软的源代码可以看到 HookupScrollingComponents 的逻辑，首先是判断属性<code class="language-plaintext highlighter-rouge">CanContentScroll</code> 判断元素里的控件是否可以滚动，如果元素里的控件可以滚动，那么再判断元素里的控件是不是继承<code class="language-plaintext highlighter-rouge">IScrollInfo</code>如果是的话，嗯，没了，就把 ScrollInfo 赋值。如果里面的控件不是继承<code class="language-plaintext highlighter-rouge">IScrollInfo</code>，那么判断一下他是不是处于列表，如果是的话就拿列表<code class="language-plaintext highlighter-rouge">ItemsPresenter</code>作为ScrollInfo。如果还是拿不到，只好用自己作为<code class="language-plaintext highlighter-rouge">ScrollInfo</code></p>

<p><img src="http://image.acmx.xyz/65fb6078-c169-4ce3-cdd9-e35752d07be0%2F2018313162030.jpg" alt="" /></p>

<p>从这里可以看到 CanContentScroll 如果没有设置，就直接使用这个类，也就是物理滚动就是这个类做的。如果一个元素不在列表内，不继承 IScrollInfo 那么即使设置使用逻辑滚动，实际上也是物理滚动。物理滚动就是元素不知道滚动，所有的移动都是元素无法控制。和物理滚动不同，逻辑的就是元素控制所有滚动。</p>

<h3 id="物理滚动">物理滚动</h3>

<p>下面来告诉大家，物理滚动是如何做，实际上的滚动就是在布局中使用下面的代码，让元素布局在滚动的地方，所以看起来就是元素滚动</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>                  <span class="n">Rect</span> <span class="n">childRect</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">Rect</span><span class="p">(</span><span class="n">child</span><span class="p">.</span><span class="n">DesiredSize</span><span class="p">);</span>
 
                        <span class="k">if</span> <span class="p">(</span><span class="n">IsScrollClient</span><span class="p">)</span>
                        <span class="p">{</span>
                            <span class="n">childRect</span><span class="p">.</span><span class="n">X</span> <span class="p">=</span> <span class="p">-</span><span class="n">HorizontalOffset</span><span class="p">;</span>
                            <span class="n">childRect</span><span class="p">.</span><span class="n">Y</span> <span class="p">=</span> <span class="p">-</span><span class="n">VerticalOffset</span><span class="p">;</span>
                        <span class="p">}</span>
 
                        <span class="c1">//this is needed to stretch the child to arrange space,</span>
                        <span class="n">childRect</span><span class="p">.</span><span class="n">Width</span> <span class="p">=</span> <span class="n">Math</span><span class="p">.</span><span class="nf">Max</span><span class="p">(</span><span class="n">childRect</span><span class="p">.</span><span class="n">Width</span><span class="p">,</span> <span class="n">arrangeSize</span><span class="p">.</span><span class="n">Width</span><span class="p">);</span>
                        <span class="n">childRect</span><span class="p">.</span><span class="n">Height</span> <span class="p">=</span> <span class="n">Math</span><span class="p">.</span><span class="nf">Max</span><span class="p">(</span><span class="n">childRect</span><span class="p">.</span><span class="n">Height</span><span class="p">,</span> <span class="n">arrangeSize</span><span class="p">.</span><span class="n">Height</span><span class="p">);</span>
 
                        <span class="n">child</span><span class="p">.</span><span class="nf">Arrange</span><span class="p">(</span><span class="n">childRect</span><span class="p">);</span>
</code></pre></div></div>

<p><img src="http://image.acmx.xyz/65fb6078-c169-4ce3-cdd9-e35752d07be0%2F2018313201221.jpg" alt="" /></p>

<p>可以看到布局设置反过来的 HorizontalOffset 作为元素的 x 移动，通过这样就可以让元素移动</p>

<p>但是元素如果移动在 ScrollViewer 外面，如何裁剪？实际上就是使用重写了 GetLayoutClip 进行裁剪</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="k">return</span> <span class="k">new</span> <span class="nf">RectangleGeometry</span><span class="p">(</span><span class="k">new</span> <span class="nf">Rect</span><span class="p">(</span><span class="n">RenderSize</span><span class="p">));</span>
</code></pre></div></div>

<p>从代码可以知道，实际上的 ScrollViewer 是不会滚动元素的，滚动元素的是 ScrollViewer 里面的元素，滚动的方式一般都使用在布局的时候设置元素的 X、Y 来让元素滚动。我看了 StackPanel 和其他几个类，都是使用这个方式，因为对比 Translate 的方式，这个方法不会用到 Translate 也就不会在用户修改 Translate 的时候无法移动。另外这个方法是在布局做的，直接计算，如果修改 Translate 还需要在布局重新计算，所以这个方法的性能会比较高。</p>

<h3 id="触摸输入">触摸输入</h3>

<p>那么 ScrollViewer 是如何在触摸的时候获得输入？实际上在触摸的时候用的是 Manipulation ，在判断 PanningMode 给值</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>                    <span class="k">if</span> <span class="p">(</span><span class="n">panningMode</span> <span class="p">==</span> <span class="n">PanningMode</span><span class="p">.</span><span class="n">HorizontalOnly</span><span class="p">)</span>
                    <span class="p">{</span>
                        <span class="n">e</span><span class="p">.</span><span class="n">Mode</span> <span class="p">=</span> <span class="n">ManipulationModes</span><span class="p">.</span><span class="n">TranslateX</span><span class="p">;</span>
                    <span class="p">}</span>
                    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">panningMode</span> <span class="p">==</span> <span class="n">PanningMode</span><span class="p">.</span><span class="n">VerticalOnly</span><span class="p">)</span>
                    <span class="p">{</span>
                        <span class="n">e</span><span class="p">.</span><span class="n">Mode</span> <span class="p">=</span> <span class="n">ManipulationModes</span><span class="p">.</span><span class="n">TranslateY</span><span class="p">;</span>
                    <span class="p">}</span>
                    <span class="k">else</span>
                    <span class="p">{</span>
                        <span class="n">e</span><span class="p">.</span><span class="n">Mode</span> <span class="p">=</span> <span class="n">ManipulationModes</span><span class="p">.</span><span class="n">Translate</span><span class="p">;</span>
                    <span class="p">}</span>
</code></pre></div></div>

<p>所以在 ManipulationDelta 可以拿到移动的值，因为直接拿到的值就是用户希望的路径所以直接设置不需要计算</p>

<p>但是需要倍数 PanningRatio ，如果需要惯性，那么只需要设置惯性就可以。</p>

<p>大概整个源代码只有这些，很多的代码都是在判断边界，还有处理一些用户输入。</p>

<p>在触摸的时候，核心的代码是 ManipulateScroll ，传入了当前的移动和累计的移动、是否水平移动。通过判断当前的移动是否有移动然后乘以倍数，然后通过设置 HorizontalOffset 这几个属性的值，重新布局就可以。</p>

<p>所以所有的代码实际上就是获得输入，然后传入给对应的 ScrollInfo ，通过 ScrollInfo 实现的方法做具体的业务。</p>

<p>不过 ScrollViewer 不是直接传入 ScrollInfo 需要移动的，而且发送命令</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>     
        <span class="k">public</span> <span class="k">void</span> <span class="nf">ScrollToHorizontalOffset</span><span class="p">(</span><span class="kt">double</span> <span class="n">offset</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="kt">double</span> <span class="n">validatedOffset</span> <span class="p">=</span> <span class="n">ScrollContentPresenter</span><span class="p">.</span><span class="nf">ValidateInputOffset</span><span class="p">(</span><span class="n">offset</span><span class="p">,</span> <span class="s">"offset"</span><span class="p">);</span>
 
            <span class="c1">// Queue up the scroll command, which tells the content to scroll.</span>
            <span class="c1">// Will lead to an update of all offsets (both live and deferred).</span>
            <span class="nf">EnqueueCommand</span><span class="p">(</span><span class="n">Commands</span><span class="p">.</span><span class="n">SetHorizontalOffset</span><span class="p">,</span> <span class="n">validatedOffset</span><span class="p">,</span> <span class="k">null</span><span class="p">);</span>
        <span class="p">}</span>
 
</code></pre></div></div>

<p>然后在具体的函数 ExecuteNextCommand 拿出一个个的命令，进行移动</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>     <span class="k">private</span> <span class="kt">bool</span> <span class="nf">ExecuteNextCommand</span><span class="p">()</span>
        <span class="p">{</span>
            <span class="n">IScrollInfo</span> <span class="n">isi</span> <span class="p">=</span> <span class="n">ScrollInfo</span><span class="p">;</span>
 
            <span class="n">Command</span> <span class="n">cmd</span> <span class="p">=</span> <span class="n">_queue</span><span class="p">.</span><span class="nf">Fetch</span><span class="p">();</span>
            <span class="k">switch</span><span class="p">(</span><span class="n">cmd</span><span class="p">.</span><span class="n">Code</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="k">case</span> <span class="n">Commands</span><span class="p">.</span><span class="n">LineUp</span><span class="p">:</span>    <span class="n">isi</span><span class="p">.</span><span class="nf">LineUp</span><span class="p">();</span>    <span class="k">break</span><span class="p">;</span>
                <span class="k">case</span> <span class="n">Commands</span><span class="p">.</span><span class="n">LineDown</span><span class="p">:</span>  <span class="n">isi</span><span class="p">.</span><span class="nf">LineDown</span><span class="p">();</span>  <span class="k">break</span><span class="p">;</span>
                <span class="k">case</span> <span class="n">Commands</span><span class="p">.</span><span class="n">LineLeft</span><span class="p">:</span>  <span class="n">isi</span><span class="p">.</span><span class="nf">LineLeft</span><span class="p">();</span>  <span class="k">break</span><span class="p">;</span>
                <span class="k">case</span> <span class="n">Commands</span><span class="p">.</span><span class="n">LineRight</span><span class="p">:</span> <span class="n">isi</span><span class="p">.</span><span class="nf">LineRight</span><span class="p">();</span> <span class="k">break</span><span class="p">;</span>
                <span class="c1">//去掉差不多的代码</span>
                <span class="k">case</span> <span class="n">Commands</span><span class="p">.</span><span class="n">Invalid</span><span class="p">:</span> <span class="k">return</span> <span class="k">false</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="k">return</span> <span class="k">true</span><span class="p">;</span>
        <span class="p">}</span>
</code></pre></div></div>

<p>在输入的时候可能输入太快，而布局不是立刻进行布局，从代码可以看到，移动的业务就是在布局修改值，但是布局修改不是优先级很高的，但是输入的优先级是很高的，可能在布局的过程就不停输入。所以就需要把输入的命令放入，使用一个函数一个个拿出来，对不同的命令处理，最后再布局。</p>

<p>参见：</p>

<p><a href="http://www.cnblogs.com/TianFang/p/4198731.html">在WPF中实现平滑滚动 - 天方 - 博客园</a></p>

<p><a href="https://blogs.msdn.microsoft.com/bencon/2006/01/06/iscrollinfo-in-avalon-part-i/">IScrollInfo in Avalon part I – BenCon’s WebLog</a></p>

<p><a href="https://blogs.msdn.microsoft.com/bencon/2006/01/07/iscrollinfo-in-avalon-part-ii/">IScrollInfo in Avalon part II – BenCon’s WebLog</a></p>

<p><a href="https://blogs.msdn.microsoft.com/bencon/2006/01/08/iscrollinfo-in-avalon-part-iii/">IScrollInfo in Avalon part III – BenCon’s WebLog</a></p>

<p><a href="https://blogs.msdn.microsoft.com/bencon/2006/12/09/iscrollinfo-tutorial-part-iv/">IScrollInfo tutorial part IV – BenCon’s WebLog</a></p>

<h2 id="其他源代码分析">其他源代码分析</h2>

<p><a href="https://lindexi.gitee.io/post/.net-Framework-%E6%BA%90%E4%BB%A3%E7%A0%81-ScrollViewer.html">.net Framework 源代码 · ScrollViewer</a></p>

<p>[.net源码分析 – List<T> - 布鲁克石 - 博客园](http://www.cnblogs.com/brookshi/p/5353021.html )</T></p>

<p><a href="http://www.cnblogs.com/Zhouyongh/archive/2009/09/10/1564099.html">一站式WPF–依赖属性（DependencyProperty）一 - 周永恒 - 博客园</a></p>

:ET