I"wz<p>本文从代码底层告诉大家，在触摸屏幕之后是如何拿到触摸点并且转换为事件</p>

<!--more-->

<!-- CreateTime:2019/6/15 8:58:54 -->

<!-- csdn -->
<!-- 标签：WPF，触摸，源代码分析 -->

<p>在 WPF 界面框架核心就是交互和渲染，触摸是交互的一部分。在 WPF 是需要使用多个线程来做触摸和渲染，触摸是单独一个线程，这个线程就是只获得触摸，而将触摸转路由是在主线程。</p>

<!-- ![](image/WPF 触摸到事件/WPF 触摸到事件11.png) -->

<p><img src="http://image.acmx.xyz/lindexi%2F2018816193233162" alt="" /></p>

<p>在触摸线程各个模块的关系请看下面</p>

<!-- ![](image/WPF 触摸到事件/WPF 触摸到事件12.png) -->

<p><img src="http://image.acmx.xyz/lindexi%2F201881619392311" alt="" /></p>

<p>从触摸线程转换到主线程，然后从主线程封装为路由事件的模块请看下面</p>

<!-- ![](image/WPF 触摸到事件/WPF 触摸到事件13.png) -->

<p><img src="http://image.acmx.xyz/lindexi%2F2018816194254592" alt="" /></p>

<p>路由事件需要封装触摸消息并且找到命中的元素</p>

<!-- ![](image/WPF 触摸到事件/WPF 触摸到事件14.png) -->

<p><img src="http://image.acmx.xyz/lindexi%2F201881620518558" alt="" /></p>

<p>实际上看到这里，整个触摸就告诉了大家过程，从大的方面已经可以知道过程，触摸是如何转路由。具体代码是如何做的请看下面</p>

<p>在 WPF 需要使用一个线程去获取触摸的信息，这个线程是在 <code class="language-plaintext highlighter-rouge">PenThreadWorker</code> 创建，在 <code class="language-plaintext highlighter-rouge">PenThreadWorker</code> 的构造函数有下面代码</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>			<span class="k">new</span> <span class="nf">Thread</span><span class="p">(</span><span class="k">new</span> <span class="nf">ThreadStart</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="n">ThreadProc</span><span class="p">))</span>
			<span class="p">{</span>
				<span class="n">IsBackground</span> <span class="p">=</span> <span class="k">true</span>
			<span class="p">}.</span><span class="nf">Start</span><span class="p">();</span>
</code></pre></div></div>

<p>通过这个方法就可以创建线程运行 <code class="language-plaintext highlighter-rouge">ThreadProc</code> 这个函数是一个无限循环，请看代码</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">while</span> <span class="p">(!</span><span class="k">this</span><span class="p">.</span><span class="n">__disposed</span><span class="p">)</span>
<span class="p">{</span>
	<span class="c1">// 忽略代码</span>
<span class="p">}</span>
</code></pre></div></div>

<p>这个函数的底层实际上是包括了另一个循环来从 <code class="language-plaintext highlighter-rouge">penimc2_v0400.dll</code> 拿到触摸信息</p>

<p>如果插入的设备有一个，就会运行 <code class="language-plaintext highlighter-rouge">penimc2_v0400.dll</code> 里 <code class="language-plaintext highlighter-rouge">GetPenEvent</code> 拿到触摸的信息。如果有多个就会调用 <code class="language-plaintext highlighter-rouge">GetPenEventMultiple</code> 方法。这里先不用理会底层的实现，只需要知道底层实现的代码大概就是下面代码</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>		<span class="k">internal</span> <span class="k">void</span> <span class="nf">ThreadProc</span><span class="p">()</span>
		<span class="p">{</span>
			<span class="n">Thread</span><span class="p">.</span><span class="n">CurrentThread</span><span class="p">.</span><span class="n">Name</span> <span class="p">=</span> <span class="s">"Stylus Input"</span><span class="p">;</span>
			<span class="k">while</span> <span class="p">(!</span><span class="k">this</span><span class="p">.</span><span class="n">__disposed</span><span class="p">)</span>
			<span class="p">{</span>
				<span class="c1">// 初始化的代码</span>
				<span class="k">for</span> <span class="p">(;;)</span>
				<span class="p">{</span>
					<span class="c1">// 有一个触摸设备，就进入 GetPenEvent 拿到触摸</span>
					<span class="k">if</span> <span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="n">_handles</span><span class="p">.</span><span class="n">Length</span> <span class="p">==</span> <span class="m">1</span><span class="p">)</span>
					<span class="p">{</span>
						<span class="n">UnsafeNativeMethods</span><span class="p">.</span><span class="nf">GetPenEvent</span><span class="p">(</span><span class="err">一些参数</span><span class="p">)</span>
						<span class="n">num2</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span>
					<span class="p">}</span>
					<span class="k">else</span>
					<span class="p">{</span>
						<span class="c1">// 有多个触摸设备，就会进入 GetPenEventMultiple 在用户触摸</span>
						<span class="n">UnsafeNativeMethods</span><span class="p">.</span><span class="nf">GetPenEventMultiple</span><span class="p">(</span><span class="err">参数</span><span class="p">)</span>
					<span class="p">}</span>
					<span class="n">PenContext</span> <span class="n">penContext</span> <span class="p">=</span> <span class="n">xx</span><span class="p">;</span> <span class="c1">// 在触摸对应的 PenContext 是通过判断用户触摸</span>
				
					<span class="k">this</span><span class="p">.</span><span class="nf">FireEvent</span><span class="p">(</span><span class="n">penContext</span><span class="p">,</span> <span class="err">参数</span><span class="p">);</span>
				<span class="p">}</span>
			<span class="p">}</span>
		<span class="p">}</span>
</code></pre></div></div>

<p>通过这个方法可以知道触摸的设备的 id 和触摸的数据，触摸的事件</p>

<p>这里的 GetPenEvent 和 GetPenEventMultiple 其实就是调用 PenImc 的代码，这部分属于更底层的逻辑。如果有兴趣，请看 <a href="https://blog.lindexi.com/post/WPF-%E8%A7%A6%E6%91%B8%E5%BA%95%E5%B1%82-PenImc-%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84.html">WPF 触摸底层 PenImc 是如何工作的</a></p>

<p>在拿到触摸信息之后，会调用 <code class="language-plaintext highlighter-rouge">FireEvent</code> 转换事件，在拿到的信息包括了表示是什么事件，因为触摸的事件是传入一个数值，需要通过这个数值转换为对应的事件</p>

<ul>
  <li>707：PenInRange</li>
  <li>708：PenOutOfRange</li>
  <li>709：PenDown</li>
  <li>710：PenUp</li>
  <li>711：Packets</li>
</ul>

<p>如收到的是 709 事件，就会进入 <code class="language-plaintext highlighter-rouge">FireEvent</code> 在下面代码使用 <code class="language-plaintext highlighter-rouge">penContext.FirePenDown</code> 告诉现在是触摸按下</p>

<p>在 FirePenDown 函数会先判断这个触摸是否初始化，每个触摸都有 StylusPointDescription 这个值是使用 <code class="language-plaintext highlighter-rouge">IPimcContext2</code> 获取 <code class="language-plaintext highlighter-rouge">GetPacketPropertyInfo</code> 拿到，是触摸屏的设备描述信息里告诉程序这个触摸的精度和触摸宽度</p>

<p>在 <code class="language-plaintext highlighter-rouge">penContext</code> 传入事件给 <code class="language-plaintext highlighter-rouge">PenContexts.OnPenDown</code> 这个是在 <code class="language-plaintext highlighter-rouge">PenContexts</code> 的三个主要事件的一个，可以从代码知道都是调用 <code class="language-plaintext highlighter-rouge">ProcessInput</code> 只是第一个参数不相同</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>		<span class="k">internal</span> <span class="k">void</span> <span class="nf">OnPenDown</span><span class="p">(</span><span class="n">PenContext</span> <span class="n">penContext</span><span class="p">,</span> <span class="kt">int</span> <span class="n">tabletDeviceId</span><span class="p">,</span> <span class="kt">int</span> <span class="n">stylusPointerId</span><span class="p">,</span> <span class="kt">int</span><span class="p">[]</span> <span class="n">data</span><span class="p">,</span> <span class="kt">int</span> <span class="n">timestamp</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="c1">// 下面两个函数和这个函数的不同在于 RawStylusActions.Down 其他都是相同</span>
			<span class="k">this</span><span class="p">.</span><span class="nf">ProcessInput</span><span class="p">(</span><span class="n">RawStylusActions</span><span class="p">.</span><span class="n">Down</span><span class="p">,</span> <span class="n">penContext</span><span class="p">,</span> <span class="n">tabletDeviceId</span><span class="p">,</span> <span class="n">stylusPointerId</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">timestamp</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="k">internal</span> <span class="k">void</span> <span class="nf">OnPenUp</span><span class="p">(</span><span class="n">PenContext</span> <span class="n">penContext</span><span class="p">,</span> <span class="kt">int</span> <span class="n">tabletDeviceId</span><span class="p">,</span> <span class="kt">int</span> <span class="n">stylusPointerId</span><span class="p">,</span> <span class="kt">int</span><span class="p">[]</span> <span class="n">data</span><span class="p">,</span> <span class="kt">int</span> <span class="n">timestamp</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="k">this</span><span class="p">.</span><span class="nf">ProcessInput</span><span class="p">(</span><span class="n">RawStylusActions</span><span class="p">.</span><span class="n">Up</span><span class="p">,</span> <span class="n">penContext</span><span class="p">,</span> <span class="n">tabletDeviceId</span><span class="p">,</span> <span class="n">stylusPointerId</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">timestamp</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="k">internal</span> <span class="k">void</span> <span class="nf">OnPackets</span><span class="p">(</span><span class="n">PenContext</span> <span class="n">penContext</span><span class="p">,</span> <span class="kt">int</span> <span class="n">tabletDeviceId</span><span class="p">,</span> <span class="kt">int</span> <span class="n">stylusPointerId</span><span class="p">,</span> <span class="kt">int</span><span class="p">[]</span> <span class="n">data</span><span class="p">,</span> <span class="kt">int</span> <span class="n">timestamp</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="k">this</span><span class="p">.</span><span class="nf">ProcessInput</span><span class="p">(</span><span class="n">RawStylusActions</span><span class="p">.</span><span class="n">Move</span><span class="p">,</span> <span class="n">penContext</span><span class="p">,</span> <span class="n">tabletDeviceId</span><span class="p">,</span> <span class="n">stylusPointerId</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">timestamp</span><span class="p">);</span>
		<span class="p">}</span>
</code></pre></div></div>

<p>上面代码传入的 stylusPointerId 、data 都是从刚才的底层拿到的值，这里的 tabletDeviceId 是从 PenContext 拿到，一个触摸的设备都有设备的 id 也就是 tabletDeviceId 的值。触摸的时候会给这个触摸一个 id 就是 stylusPointerId 通过这个在进行移动的时候就知道是哪个触摸点在移动。这个技术是用来解决多点触摸，如果用户有多个点触摸，就需要使用 stylusPointerId 来拿到这个点之前的做法</p>

<p>先告诉大家调用的顺序，不然大家看到下面忘记了点就不知道我在说的是什么了，本文图片画的实线表示方法在方法内调用了下一个方法，使用虚线表示在外面调用完成这个方法之后再调用下一个方法。</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>	
	<span class="k">void</span> <span class="nf">A</span><span class="p">()</span>
	<span class="p">{</span>
		<span class="nf">B</span><span class="p">();</span> <span class="c1">// A和B连接用实线表示</span>
	<span class="p">}</span>

	<span class="k">void</span> <span class="nf">C</span><span class="p">()</span>
	<span class="p">{</span>
		<span class="nf">A</span><span class="p">();</span>
		<span class="nf">B</span><span class="p">();</span> <span class="c1">// A和B连接需要虚线表示 </span>
	<span class="p">}</span>

</code></pre></div></div>

<!-- ![](image/WPF 触摸到事件/WPF 触摸到事件5.png) -->

<p><img src="http://image.acmx.xyz/lindexi%2F2018815115135159" alt="" /></p>

<p>现在就将事件传入到 ProcessInput 并且告诉 <code class="language-plaintext highlighter-rouge">RawStylusActions</code> 这个函数会调用 <code class="language-plaintext highlighter-rouge">WispLogic</code> 的 ProcessInput 在这里使用函数的原因是为了传入的时候加上 <code class="language-plaintext highlighter-rouge">_inputSource</code> 这里的 <code class="language-plaintext highlighter-rouge">WispLogic</code> 可能是 StylusLogic 现在的代码就到了比较熟悉的 StylusLogic 函数</p>

<blockquote>
  <p>WispLogic 的 Wisp 是 Windows Inking Service Platform 用来在系统和输入设备之间通信</p>
</blockquote>

<p>在 <code class="language-plaintext highlighter-rouge">WispLogic</code> 的 <code class="language-plaintext highlighter-rouge">ProcessInput</code> 会包装输入的参数为 <code class="language-plaintext highlighter-rouge">RawStylusInputReport</code> 现在这个参数还不需要知道是按下还是移动</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>		<span class="k">internal</span> <span class="k">void</span> <span class="nf">ProcessInput</span><span class="p">(</span><span class="n">RawStylusActions</span> <span class="n">actions</span><span class="p">,</span> <span class="n">PenContext</span> <span class="n">penContext</span><span class="p">,</span> <span class="kt">int</span> <span class="n">tabletDeviceId</span><span class="p">,</span> <span class="kt">int</span> <span class="n">stylusDeviceId</span><span class="p">,</span> <span class="kt">int</span><span class="p">[]</span> <span class="n">data</span><span class="p">,</span> <span class="kt">int</span> <span class="n">timestamp</span><span class="p">,</span> <span class="n">PresentationSource</span> <span class="n">inputSource</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="n">RawStylusInputReport</span> <span class="n">inputReport</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">RawStylusInputReport</span><span class="p">(</span><span class="n">InputMode</span><span class="p">.</span><span class="n">Foreground</span><span class="p">,</span> <span class="n">timestamp</span><span class="p">,</span> <span class="n">inputSource</span><span class="p">,</span> <span class="n">penContext</span><span class="p">,</span> <span class="n">actions</span><span class="p">,</span> <span class="n">tabletDeviceId</span><span class="p">,</span> <span class="n">stylusDeviceId</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>
			<span class="k">this</span><span class="p">.</span><span class="nf">ProcessInputReport</span><span class="p">(</span><span class="n">inputReport</span><span class="p">);</span>
		<span class="p">}</span>
</code></pre></div></div>

<p>这里的第一个参数 <code class="language-plaintext highlighter-rouge">InputMode</code> 表示的是当前的应用是不是处于前台</p>

<p>然后调用 <code class="language-plaintext highlighter-rouge">WispLogic</code> 的 <code class="language-plaintext highlighter-rouge">ProcessInput</code> 传入参数，从这里可以看到，如果一个函数的参数太多，建议创建一个类来传参数。微软在这里做的还是不错</p>

<p>在 <code class="language-plaintext highlighter-rouge">ProcessInput</code> 需要继续处理参数，使用 StylusDeviceId 找到 <code class="language-plaintext highlighter-rouge">WispStylusDevice</code> 这个 <code class="language-plaintext highlighter-rouge">WispStylusDevice</code> 是在 <code class="language-plaintext highlighter-rouge">WispLogic</code> 的 <code class="language-plaintext highlighter-rouge">RegisterStylusDeviceCore</code> 注册</p>

<!-- ![](image/WPF 触摸到事件/WPF 触摸到事件4.png) -->

<p><img src="http://image.acmx.xyz/lindexi%2F2018815111230935" alt="" /></p>

<p>在处理完参数会调用 <code class="language-plaintext highlighter-rouge">InvokeStylusPluginCollection</code> 这个函数会回到 PenContexts 请看代码</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>		<span class="k">internal</span> <span class="k">void</span> <span class="nf">InvokeStylusPluginCollection</span><span class="p">(</span><span class="n">RawStylusInputReport</span> <span class="n">inputReport</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">inputReport</span><span class="p">.</span><span class="n">StylusDevice</span> <span class="p">!=</span> <span class="k">null</span><span class="p">)</span>
			<span class="p">{</span>
				<span class="n">inputReport</span><span class="p">.</span><span class="n">PenContext</span><span class="p">.</span><span class="n">Contexts</span><span class="p">.</span><span class="nf">InvokeStylusPluginCollection</span><span class="p">(</span><span class="n">inputReport</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>
</code></pre></div></div>

<!-- ![](image/WPF 触摸到事件/WPF 触摸到事件2.png) -->

<p><img src="http://image.acmx.xyz/lindexi%2F2018815111441251" alt="" /></p>

<p>这里需要告诉大家，从读微软的源代码一个很重要的就是学习微软的写法。在这里这样写是可以做到写出尽量短的代码，将一个功能拆到一个函数。如上面的代码，在 <code class="language-plaintext highlighter-rouge">WispLogic</code> 的 <code class="language-plaintext highlighter-rouge">ProcessInput</code> 将多个参数转换为一个类，然后再调用重载的 <code class="language-plaintext highlighter-rouge">ProcessInput</code> 方法。在重载的 <code class="language-plaintext highlighter-rouge">WispLogic</code> 的 <code class="language-plaintext highlighter-rouge">ProcessInput</code> 只是用来添加参数，添加完成就调用本地的 <code class="language-plaintext highlighter-rouge">InvokeStylusPluginCollection</code> 方法，同时 <code class="language-plaintext highlighter-rouge">InvokeStylusPluginCollection</code> 也只做调用 <code class="language-plaintext highlighter-rouge">PenContexts</code> 的函数</p>

<p>看到这里也许会认为 PenContexts 和 PenContext 相同的，实际上是两个不同的类。</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">internal</span> <span class="k">sealed</span> <span class="k">class</span> <span class="nc">PenContext</span>
<span class="p">{</span>
		<span class="k">internal</span> <span class="nf">PenContext</span><span class="p">(</span> <span class="n">PenContexts</span> <span class="n">contexts</span> <span class="cm">/*忽略参数*/</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="k">this</span><span class="p">.</span><span class="n">_contexts</span> <span class="p">=</span> <span class="n">contexts</span><span class="p">;</span>
			
			<span class="c1">// 忽略代码</span>
		<span class="p">}</span>

		<span class="k">internal</span> <span class="n">PenContexts</span> <span class="n">Contexts</span>
		<span class="p">{</span>
			<span class="p">[</span><span class="n">SecurityCritical</span><span class="p">]</span>
			<span class="k">get</span>
			<span class="p">{</span>
				<span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="n">_contexts</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="k">private</span> <span class="n">PenContexts</span> <span class="n">_contexts</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">internal</span> <span class="k">sealed</span> <span class="k">class</span> <span class="nc">PenContexts</span>
<span class="p">{</span>
	    <span class="c1">// 包含了很多个 PenContext 对一个输入设备创建一个 PenContext 注意这里说的是报给系统的数量，一个物理设备可以报给系统1000000000000个输入</span>
		<span class="k">private</span> <span class="n">PenContext</span><span class="p">[]</span> <span class="n">_contexts</span><span class="p">;</span>

		<span class="c1">// 这个函数调用了会添加 _contexts 的值</span>
		<span class="k">internal</span> <span class="k">void</span> <span class="nf">AddContext</span><span class="p">(</span><span class="kt">uint</span> <span class="n">index</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="c1">// 拿到局部的字段，作为一个变量，可以减少字段的引用</span>
			<span class="c1">// 推荐在一个复杂的类，如果函数用到了字段或属性，就使用局部的变量引用这个字段</span>
			<span class="c1">// 这个写法在框架里面很多使用</span>

			<span class="n">PenContext</span><span class="p">[]</span> <span class="n">array</span> <span class="p">=</span> <span class="n">_contexts</span><span class="p">;</span>
			<span class="n">PenContext</span> <span class="n">penContext</span> <span class="p">=</span> <span class="k">this</span><span class="p">.</span><span class="n">_stylusLogic</span><span class="p">.</span><span class="n">TabletDevices</span><span class="p">[(</span><span class="kt">int</span><span class="p">)</span><span class="n">index</span><span class="p">].</span><span class="n">As</span><span class="p">&lt;</span><span class="n">WispTabletDevice</span><span class="p">&gt;().</span><span class="nf">CreateContext</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="n">_inputSource</span><span class="p">.</span><span class="n">Value</span><span class="p">.</span><span class="n">CriticalHandle</span><span class="p">,</span> <span class="k">this</span><span class="p">);</span>
			<span class="n">array</span><span class="p">[(</span><span class="kt">int</span><span class="p">)</span><span class="n">index</span><span class="p">]</span> <span class="p">=</span> <span class="n">penContext</span><span class="p">;</span>
		<span class="p">}</span>		
<span class="p">}</span>
</code></pre></div></div>

<p>如果想知道 <code class="language-plaintext highlighter-rouge">PenContext</code> 是如何被创建的，请到下一节，因为这里的代码很多</p>

<p>在 PenContexts 的 <code class="language-plaintext highlighter-rouge">InvokeStylusPluginCollection</code> 就是调用 StylusPlugIn 的核心代码。在触摸的过程会调用 StylusPlugIn 是 WPF 提供的快速拿到触摸的方法，如果是从路由事件，需要等待主线程和其他的代码，这样无法做到比较快拿到触摸。</p>

<p>在 WispLogic 和 PenContexts 都有相同的 <code class="language-plaintext highlighter-rouge">InvokeStylusPluginCollection</code> 函数，但是 WispLogic 没有实际代码，请看 WispLogic 的代码</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>		<span class="k">internal</span> <span class="k">void</span> <span class="nf">InvokeStylusPluginCollection</span><span class="p">(</span><span class="n">RawStylusInputReport</span> <span class="n">inputReport</span><span class="p">)</span>
		<span class="p">{</span>
		    <span class="c1">// 忽略代码</span>
			<span class="n">inputReport</span><span class="p">.</span><span class="n">PenContext</span><span class="p">.</span><span class="n">Contexts</span><span class="p">.</span><span class="nf">InvokeStylusPluginCollection</span><span class="p">(</span><span class="n">inputReport</span><span class="p">);</span>
			
		<span class="p">}</span>
</code></pre></div></div>

<p>实际上调用了的过程是回到原来的 PenContexts 如果看了下面的图会比较容易知道这个调用的过程，因为刚刚讲了 <code class="language-plaintext highlighter-rouge">PenContext</code> 担心已经不记得说到 <code class="language-plaintext highlighter-rouge">InvokeStylusPluginCollection</code> 的调用。</p>

<!-- ![](image/WPF 触摸到事件/WPF 触摸到事件2.png) -->

<p><img src="http://image.acmx.xyz/lindexi%2F2018815111441251" alt="" /></p>

<p>在 PenContexts 的 InvokeStylusPluginCollection 函数有一个重要的过程就是找到 <code class="language-plaintext highlighter-rouge">StylusPlugIn</code> 调用</p>

<p>在 PenContexts 有一个数组 <code class="language-plaintext highlighter-rouge">List&lt;StylusPlugInCollection&gt; _plugInCollectionList</code> 只要在界面添加了 <code class="language-plaintext highlighter-rouge">StylusPlugIn</code> 就会添加到这个列表，于是通过下面的方法判断是否存在命中测试，如果存在命中测试就调用对应的类</p>

<p>如我在一个 Grid 添加了 <code class="language-plaintext highlighter-rouge">StylusPlugIn</code> 如果点击了 Grid 所在的范围，那么就会调用对应的类</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>		<span class="k">private</span> <span class="n">StylusPlugInCollection</span> <span class="nf">HittestPlugInCollection</span><span class="p">(</span><span class="n">Point</span> <span class="n">pt</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="k">foreach</span> <span class="p">(</span><span class="n">StylusPlugInCollection</span> <span class="n">stylusPlugInCollection</span> <span class="k">in</span> <span class="k">this</span><span class="p">.</span><span class="n">_plugInCollectionList</span><span class="p">)</span>
			<span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">stylusPlugInCollection</span><span class="p">.</span><span class="nf">IsHit</span><span class="p">(</span><span class="n">pt</span><span class="p">))</span>
				<span class="p">{</span>
					<span class="k">return</span> <span class="n">stylusPlugInCollection</span><span class="p">;</span>
				<span class="p">}</span>
			<span class="p">}</span>
			<span class="k">return</span> <span class="k">null</span><span class="p">;</span>
		<span class="p">}</span>
</code></pre></div></div>

<p>从上面的代码可以知道，找到命中测试的方法是拿到所有的 <code class="language-plaintext highlighter-rouge">StylusPlugIn</code> 判断命中测试，所以如果一个被其他元素挡住的元素命中测试返回 true 就可以成功被调用。</p>

<p>这个是非常重要的，也就是即使在 WPF 命中测试到元素，而在这个元素下面的元素就不会被命中，但是在 <code class="language-plaintext highlighter-rouge">StylusPlugIn</code> 依旧会被命中。这里这样做是为了提高性能，因为不能等 WPF 的布局，如果使用元素的布局因为触摸是在另一个线程，所以需要到主线程才可以做到。</p>

<p>为什么触摸一定要在另一个线程，我可以告诉大家是因为笔迹，在用户的笔迹很重要的就是笔迹的从触摸到显示，主线程经常在做很多的事情无法将整个主线程来计算用户的笔画，所以这里就使用了 <code class="language-plaintext highlighter-rouge">StylusPlugIn</code> 不在主线程，可以用来处理触摸</p>

<p>在 TargetPlugInCollection 函数也就是 InvokeStylusPluginCollection 的核心调用完成之后，如果判断存在值就调用对应的 stylusPlugInCollection 的 FireRawStylusInput 函数，请看 FireRawStylusInput 的实现</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">internal</span> <span class="k">void</span> <span class="nf">FireRawStylusInput</span><span class="p">(</span><span class="n">RawStylusInput</span> <span class="n">args</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="p">&lt;</span> <span class="k">this</span><span class="p">.</span><span class="n">Count</span><span class="p">;</span> <span class="n">i</span><span class="p">++)</span>
	<span class="p">{</span>
		<span class="n">StylusPlugIn</span> <span class="n">stylusPlugIn</span> <span class="p">=</span> <span class="k">this</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="n">args</span><span class="p">.</span><span class="n">CurrentNotifyPlugIn</span> <span class="p">=</span> <span class="n">stylusPlugIn</span><span class="p">;</span>
		<span class="n">stylusPlugIn</span><span class="p">.</span><span class="nf">RawStylusInput</span><span class="p">(</span><span class="n">args</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>这里的 stylusPlugInCollection 也就是经过 TargetPlugInCollection 判断命中测试找到的所有 StylusPlugIn 放在一起，通过调用 <code class="language-plaintext highlighter-rouge">RawStylusInput</code> 的方法调用了 StylusPlugIn 的方法，通过这个方法来调用继承 StylusPlugIn 的类的方法</p>

<!-- ![](image/WPF 触摸到事件/WPF 触摸到事件3.png) -->

<p><img src="http://image.acmx.xyz/lindexi%2F201881511310278" alt="" /></p>

<p>具体 StylusPlugIn 的调用本文就不多讲，在调用完成 InvokeStylusPluginCollection 也就是先告诉了很多类触摸了，现在就到了告诉路由事件的时候了。在 WispLogic 的 ProcessInputReport 函数调用 InvokeStylusPluginCollection 完成就会调用 CoalesceAndQueueStylusEvent 这个方法就是从触摸消息转路由的第一个方法，从上面代码可以说明 StylusPlugIn 的执行是比路由事件快，所以要做到比较快的触摸就需要使用这个方法。更多关于 StylusPlugIn 请看 <a href="https://lindexi.gitee.io/post/WPF-%E9%AB%98%E9%80%9F%E4%B9%A6%E5%86%99-StylusPlugIn-%E5%8E%9F%E7%90%86.html">WPF 高速书写 StylusPlugIn 原理</a></p>

<!-- ![](image/WPF 触摸到事件/WPF 触摸到事件6.png) -->

<p><img src="http://image.acmx.xyz/lindexi%2F2018815113656530" alt="" /></p>

<p>函数 CoalesceAndQueueStylusEvent 主要是添加一些参数，然后调用 QueueStylusEvent 函数将触摸的参数放在 <code class="language-plaintext highlighter-rouge">_queueStylusEvents</code> 也就是一个队列。在触摸线程使用入栈的方式，然后通过 Dispatcher 告诉主线程。</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>		<span class="k">private</span> <span class="k">void</span> <span class="nf">QueueStylusEvent</span><span class="p">(</span><span class="n">RawStylusInputReport</span> <span class="n">report</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="kt">object</span> <span class="n">stylusEventQueueLock</span> <span class="p">=</span> <span class="n">_stylusEventQueueLock</span><span class="p">;</span>
			<span class="k">lock</span><span class="p">(</span><span class="n">stylusEventQueueLock</span><span class="p">)</span>
			<span class="p">{</span>
				<span class="n">_queueStylusEvents</span><span class="p">.</span><span class="nf">Enqueue</span><span class="p">(</span><span class="n">report</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="n">Dispatcher</span><span class="p">.</span><span class="nf">BeginInvoke</span><span class="p">(</span><span class="n">DispatcherPriority</span><span class="p">.</span><span class="n">Input</span><span class="p">,</span> <span class="k">this</span><span class="p">.</span><span class="n">_dlgInputManagerProcessInput</span><span class="p">,</span> <span class="k">null</span><span class="p">);</span>
		<span class="p">}</span>
</code></pre></div></div>

<!-- ![](image/WPF 触摸到事件/WPF 触摸到事件7.png) -->

<p><img src="http://image.acmx.xyz/lindexi%2F2018815114225799" alt="" /></p>

<p>主线程从 <code class="language-plaintext highlighter-rouge">_dlgInputManagerProcessInput</code> 就是调用 <code class="language-plaintext highlighter-rouge">InputManagerProcessInput</code> 方法，是使用出队的方式拿到触摸线程的触摸。上面的图片写了入栈实际上是入队。</p>

<!-- ![](image/WPF 触摸到事件/WPF 触摸到事件9.png) -->

<p><img src="http://image.acmx.xyz/lindexi%2F2018815114937819" alt="" /></p>

<p>在 InputManagerProcessInput 主要就是创建 InputReportEventArgs 然后传入 InputManagerProcessInputEventArgs 通过这个函数调用 <code class="language-plaintext highlighter-rouge">InputManager</code> 的 ProcessInput 从上面图片可以看到是如何调用</p>

<p>这里的 <code class="language-plaintext highlighter-rouge">InputManager</code> 的 ProcessInput 会通过 ProcessStagingArea 转路由事件。</p>

<p>这里有一些细节，如在触摸传入的数据是如何拿出来，如何从触摸的点找到对应的元素进行路由。</p>

<p>在 WispLogic 的 InputManagerProcessInput 就是主线程从<code class="language-plaintext highlighter-rouge">QueueStylusEvent</code>放在<code class="language-plaintext highlighter-rouge">_queueStylusEvents</code>的参数拿出来的函数。下面就是去掉了细节代码</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>		<span class="k">internal</span> <span class="kt">object</span> <span class="nf">InputManagerProcessInput</span><span class="p">(</span><span class="kt">object</span> <span class="n">oInput</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="n">RawStylusInputReport</span> <span class="n">rawStylusInputReport</span> <span class="p">=</span> <span class="k">null</span><span class="p">;</span>
			<span class="n">WispTabletDevice</span> <span class="n">wispTabletDevice</span> <span class="p">=</span> <span class="k">null</span><span class="p">;</span>
			<span class="kt">object</span> <span class="n">stylusEventQueueLock</span> <span class="p">=</span> <span class="k">this</span><span class="p">.</span><span class="n">_stylusEventQueueLock</span><span class="p">;</span>
			<span class="k">lock</span> <span class="p">(</span><span class="n">stylusEventQueueLock</span><span class="p">)</span>
			<span class="p">{</span>
				<span class="n">rawStylusInputReport</span> <span class="p">=</span> <span class="k">this</span><span class="p">.</span><span class="n">_queueStylusEvents</span><span class="p">.</span><span class="nf">Dequeue</span><span class="p">();</span>
				<span class="n">wispTabletDevice</span> <span class="p">=</span> <span class="n">rawStylusInputReport</span><span class="p">.</span><span class="n">StylusDevice</span><span class="p">.</span><span class="n">TabletDevice</span><span class="p">..</span><span class="n">As</span><span class="p">&lt;</span><span class="n">WispTabletDevice</span><span class="p">&gt;();</span>
				<span class="n">InputReportEventArgs</span> <span class="n">inputReportEventArgs</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">InputReportEventArgs</span><span class="p">(</span><span class="k">null</span><span class="p">,</span> <span class="n">rawStylusInputReport</span><span class="p">);</span>
				<span class="n">inputReportEventArgs</span><span class="p">.</span><span class="n">RoutedEvent</span> <span class="p">=</span> <span class="n">InputManager</span><span class="p">.</span><span class="n">PreviewInputReportEvent</span><span class="p">;</span>
				<span class="nf">InputManagerProcessInputEventArgs</span><span class="p">(</span><span class="n">inputReportEventArgs</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>
</code></pre></div></div>

<!-- ![](image/WPF 触摸到事件/WPF 触摸到事件8.png) -->

<p><img src="http://image.acmx.xyz/lindexi%2F2018815115538129" alt="" /></p>

<p>在 InputManagerProcessInputEventArgs 主要就是调用 InputManager 的 ProcessInput 实际是没有代码</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>		<span class="k">internal</span> <span class="k">void</span> <span class="nf">InputManagerProcessInputEventArgs</span><span class="p">(</span><span class="n">InputEventArgs</span> <span class="n">input</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="k">this</span><span class="p">.</span><span class="n">_inputManager</span><span class="p">.</span><span class="n">Value</span><span class="p">.</span><span class="nf">ProcessInput</span><span class="p">(</span><span class="n">input</span><span class="p">);</span>
		<span class="p">}</span>
</code></pre></div></div>

<p>在  ProcessInput 主要是调用了 ProcessStagingArea 找到元素，然后使用 UIElement.RaiseEvent 从触摸到路由</p>

<!-- ![](image/WPF 触摸到事件/WPF 触摸到事件10.png) -->

<p><img src="http://image.acmx.xyz/lindexi%2F201881512418965" alt="" /></p>

<p>在 ProcessStagingArea 函数相对还是比较复杂的，因为  InputManager 负责协调整个 WPF 的输入，包括键盘、鼠标、触摸输入。</p>

<p>因为 InputManager 在 WPF 是非常重要的类，需要重新来讲一下 InputManager 所做的内容。在 WPF 中通过消息循环将不同的消息发送到不同的处理，而 InputManager 就是处理输入相关，这个类会除了从底层的消息和参数转换为路由事件，并且告诉 WPF 触发的是哪个元素的事件。因为 InputManager 是属于整个输入的处理而不是仅触摸，所以本文只告诉大家会在 InputManager 的 ProcessStagingArea 调用 UIElement.RaiseEvent 触发了路由事件。</p>

<p>关于路由事件是如何到触摸对应的元素，就需要大家去看下<a href="https://referencesource.microsoft.com/#PresentationCore/Core/CSharp/System/Windows/Input/InputManager.cs,886d7ccef1bb2675">InputManager</a> 是如何做的，在底层还是调用 MouseDevice 的 GlobalHitTest 方法</p>

<p>下面来告诉大家触摸的初始化</p>

<h2 id="初始化触摸">初始化触摸</h2>

<p>初始化触摸需要从 Window 的创建开始说，在 Window 类的 Visibility 修改时触发 <code class="language-plaintext highlighter-rouge">_OnVisibilityChanged</code> 在这个函数就使用 Dispatcher 调用 ShowHelper 而这个函数就是开始初始化</p>

<p>需要吐槽垃圾微软的函数命名，这里的 <code class="language-plaintext highlighter-rouge">_OnVisibilityChanged</code> 命名一点都不好，建议方法的命名第一个字符大写，不要使用 <code class="language-plaintext highlighter-rouge">_</code> 开始。</p>

<p>在 ShowHelper 可以忽略很多代码，因为这里没有明显初始化触摸，初始化的代码是调用 <code class="language-plaintext highlighter-rouge">SafeCreateWindowDuringShow</code> 调用这个函数可以知道这个函数还不是靠近初始化触摸的代码</p>

<p>中间调用的代码大家可以自己看，这里就直接告诉大家函数调用</p>

<ul>
  <li>Window.CreateSourceWindowDuringShow</li>
  <li>Window.CreateSourceWindow</li>
  <li>HwndSource.HwndSource</li>
  <li>HwndSource.Initialize</li>
  <li>HwndStylusInputProvider.HwndStylusInputProvider</li>
  <li>WispLogic.RegisterHwndForInput</li>
</ul>

<p>在 HwndSource.Initialize 的初始化是进行判断，如果设置了 <code class="language-plaintext highlighter-rouge">Switch.System.Windows.Input.Stylus.DisableStylusAndTouchSupport</code> 就可以根据用户设置打开或不打开，如果是为了学习，建议是打开。这个值默认是 false 也就是打开</p>

<p>然后判断 <code class="language-plaintext highlighter-rouge">StylusLogic.IsPointerStackEnabled</code> 现在在 dotnet framework 4.7 在 win10 可以使用 Pointer 消息，所以创建的是 <code class="language-plaintext highlighter-rouge">HwndPointerInputProvider</code> 本文使用的是 <code class="language-plaintext highlighter-rouge">HwndStylusInputProvider</code> 因为在 Pointer 消息就不用使用本文的逻辑</p>

<p>原来的 WPF 是存在很多的触摸的问题，在 win10 的 UWP 解决了很多的触摸问题的原因是使用了 Pointer 消息。原来的 WPF 是无法收到触摸的消息，需要使用 <code class="language-plaintext highlighter-rouge">penimc2_v0400.dll</code> 使用一个新的线程去拿到触摸的消息，也就是本文在告诉大家的流程。这个方法存在一些问题，参见<a href="https://blog.lindexi.com/post/WPF-%E6%8F%92%E6%8B%94%E8%A7%A6%E6%91%B8%E8%AE%BE%E5%A4%87%E8%A7%A6%E6%91%B8%E5%A4%B1%E6%95%88.html">WPF 插拔触摸设备触摸失效</a>所以建议是使用 Pointer 消息可以解决很多触摸的问题</p>

<p>在 WispLogic.RegisterHwndForInput 就是初始化的函数在开始初始化之前需要 <code class="language-plaintext highlighter-rouge">HwndStylusInputProvider.HwndStylusInputProvider</code> 初始化 StylusLogic 这个类有一个静态属性</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>	<span class="k">internal</span> <span class="k">abstract</span> <span class="k">class</span> <span class="nc">StylusLogic</span>
	<span class="p">{</span>

		<span class="k">internal</span> <span class="k">static</span> <span class="n">StylusLogic</span> <span class="n">CurrentStylusLogic</span>
		<span class="p">{</span>
			<span class="k">get</span>
			<span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">_currentStylusLogic</span> <span class="p">==</span> <span class="k">null</span><span class="p">)</span>
				<span class="p">{</span>
					<span class="n">StylusLogic</span><span class="p">.</span><span class="nf">Initialize</span><span class="p">();</span>
				<span class="p">}</span>
				
				<span class="c1">// 忽略代码</span>

				<span class="k">return</span> <span class="n">_currentStylusLogic</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
</code></pre></div></div>

<p>在 <code class="language-plaintext highlighter-rouge">StylusLogic.Initialize</code> 函数会判断当前是不是使用 Pointer 初始化不同的类</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>       <span class="k">if</span> <span class="p">(</span><span class="n">StylusLogic</span><span class="p">.</span><span class="n">IsPointerStackEnabled</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="c1">// 在 dotnet framework 4.7 之后可以尝试使用 Pointer 消息，这时可以就会进入这个逻辑</span>
			<span class="c1">// 本文不会详细告诉告诉大家 PointerLogic 里面的代码</span>
			<span class="n">StylusLogic</span><span class="p">.</span><span class="n">_currentStylusLogic</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">PointerLogic</span><span class="p">(</span><span class="n">InputManager</span><span class="p">.</span><span class="n">UnsecureCurrent</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">else</span>
		<span class="p">{</span>
			<span class="n">StylusLogic</span><span class="p">.</span><span class="n">_currentStylusLogic</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">WispLogic</span><span class="p">(</span><span class="n">InputManager</span><span class="p">.</span><span class="n">UnsecureCurrent</span><span class="p">);</span>
		<span class="p">}</span>
</code></pre></div></div>

<p>本文不告诉大家 PointerLogic 相关的方法，如何开启 Pointer 消息请看<a href="https://blog.lindexi.com/post/win10-%E6%94%AF%E6%8C%81%E9%BB%98%E8%AE%A4%E6%8A%8A%E8%A7%A6%E6%91%B8%E6%8F%90%E5%8D%87-Pointer-%E6%B6%88%E6%81%AF.html">win10 支持默认把触摸提升鼠标事件 打开 Pointer 消息</a>，这里假如是创建 <code class="language-plaintext highlighter-rouge">WispLogic</code> 就会进入构造，这里只是简单的初始化属性</p>

<p>在 HwndStylusInputProvider.HwndStylusInputProvider 除了创建 StylusLogic 还调用 RegisterHwndForInput 这里传入的是 InputManager HwndSource 通过这两个创建 WispTabletDevices 、 PenContexts 并且通过 IPimcManager2 拿到值</p>

<p>在这个函数调用 <code class="language-plaintext highlighter-rouge">penContexts.Enable()</code> 就可以创建 PenContext 并且使用，如何创建 PenContext 的过程请看下面</p>

<h2 id="创建-pencontext-方法">创建 PenContext 方法</h2>

<p>在触摸的时候很重要的就是 PenContext 在 <a href="https://lindexi.github.io/lindexi/post/WPF-%E6%8F%92%E6%8B%94%E8%A7%A6%E6%91%B8%E8%AE%BE%E5%A4%87%E8%A7%A6%E6%91%B8%E5%A4%B1%E6%95%88.html">WPF 插拔触摸设备触摸失效</a> 有告诉了大家，如果拿到 <code class="language-plaintext highlighter-rouge">TabletDeviceInfo</code> 为空就无法创建 PenContext 那么 这两个有什么联系</p>

<p>创建 PenContext 的核心代码是 WispTabletDevice 类的 CreateContext 创建需要 penContextInfo 而这个值是从 <code class="language-plaintext highlighter-rouge">_penThread.WorkerCreateContext</code> 拿到，在 WispTabletDevice 这个类可以拿到 PenThread 和 tabletInfo 这两个值都是构造传入</p>

<p>在 WispTabletDeviceCollection 是通过 UpdateTablets 更新 <code class="language-plaintext highlighter-rouge">_tablets</code> 这个函数在  HwndStylusInputProvider.HwndStylusInputProvider 就已经调用</p>

<p>在窗口打开的过程就通过 HwndStylusInputProvider.HwndStylusInputProvider 调用 <code class="language-plaintext highlighter-rouge">penContexts.Enable()</code> 创建 PenContext 而 PenContext 的创建需要 PenContextInfo 参数，这个参数需要通过 <code class="language-plaintext highlighter-rouge">_penThread.WorkerCreateContext</code> 创建</p>

<p>在 <code class="language-plaintext highlighter-rouge">PenContexts.Enable</code> 调用 <code class="language-plaintext highlighter-rouge">WispTabletDeviceCollection.CreateContexts</code> 创建 <code class="language-plaintext highlighter-rouge">PenContext[]</code> 在创建数组的过程，也就是在 <code class="language-plaintext highlighter-rouge">WispTabletDeviceCollection.CreateContexts</code> 方法里面会调用 <code class="language-plaintext highlighter-rouge">WispTabletDevice.CreateContext</code> 方法创建具体的 <code class="language-plaintext highlighter-rouge">PenContext</code> 而在  <code class="language-plaintext highlighter-rouge">WispTabletDevice.CreateContext</code> 方法里面就需要 PenContextInfo 的辅助才能创建</p>

<p>调用 <code class="language-plaintext highlighter-rouge">_penThread.WorkerCreateContext</code> 不是直接在主线程运行而是在 <code class="language-plaintext highlighter-rouge">PenThreadWorker</code> 的 Stylus Input 线程运行。</p>

<p>调用 <code class="language-plaintext highlighter-rouge">_penThread.WorkerCreateContext</code> 时，先在 <code class="language-plaintext highlighter-rouge">_workerOperation</code> 创建 <code class="language-plaintext highlighter-rouge">WorkerOperationCreateContext</code> 然后释放 <code class="language-plaintext highlighter-rouge">_pimcResetHandle</code> 等待 Stylus Input 线程运行。</p>

<p>在 Stylus Input 线程会在 <code class="language-plaintext highlighter-rouge">GetPenEventMultiple</code> 或 <code class="language-plaintext highlighter-rouge">GetPenEventMultiple</code>  等待 <code class="language-plaintext highlighter-rouge">_pimcResetHandle</code> 只有在用户触摸或释放 <code class="language-plaintext highlighter-rouge">_pimcResetHandle</code> 线程才会继续</p>

<!-- ![](image/WPF 触摸到事件/WPF 触摸到事件0.png) -->

<p><img src="http://image.acmx.xyz/lindexi%2F2018810171441731" alt="" /></p>

<p>这样就创建了 penContext 但是这时还需要将 penContext 加入到 PenThreadWorker 加入的方法是调用 <code class="language-plaintext highlighter-rouge">PenContext.Enable</code> 通过下面的流程调用 PenThreadWorker.WorkerAddPenContext 添加</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code> 	<span class="n">System</span><span class="p">.</span><span class="n">Windows</span><span class="p">.</span><span class="n">Input</span><span class="p">.</span><span class="n">PenThreadWorker</span><span class="p">.</span><span class="n">WorkerAddPenContext</span>
 	<span class="n">System</span><span class="p">.</span><span class="n">Windows</span><span class="p">.</span><span class="n">Input</span><span class="p">.</span><span class="n">PenThread</span><span class="p">.</span><span class="n">AddPenContext</span>
 	<span class="n">System</span><span class="p">.</span><span class="n">Windows</span><span class="p">.</span><span class="n">Input</span><span class="p">.</span><span class="n">PenThreadPool</span><span class="p">.</span><span class="n">GetPenThreadForPenContextHelper</span>
 	<span class="n">System</span><span class="p">.</span><span class="n">Windows</span><span class="p">.</span><span class="n">Input</span><span class="p">.</span><span class="n">PenThreadPool</span><span class="p">.</span><span class="n">GetPenThreadForPenContext</span>

</code></pre></div></div>

<p>在 <code class="language-plaintext highlighter-rouge">PenThreadWorker.WorkerAddPenContext</code> 实际上是添加 <code class="language-plaintext highlighter-rouge">_workerOperation</code> 的一个值 <code class="language-plaintext highlighter-rouge">WorkerOperationAddContext</code> 进行添加，也是通过释放 <code class="language-plaintext highlighter-rouge">_pimcResetHandle</code> 让获得输入的线程运行</p>

<p>在 <code class="language-plaintext highlighter-rouge">WorkerOperationAddContext</code> 会调用 <code class="language-plaintext highlighter-rouge">PenThreadWorker.AddPenContext</code> 作为实际添加，通过 <code class="language-plaintext highlighter-rouge">PenThreadWorker.AddPenContext</code> 会从 PenContext 创建 <code class="language-plaintext highlighter-rouge">_handles</code> 在触摸线程就是通过判断 <code class="language-plaintext highlighter-rouge">_handles</code> 数量调用不同的函数</p>

<p>在创建 PenContext 时需要知道创建 PenContext 数量，通过 <code class="language-plaintext highlighter-rouge">WispTabletDeviceCollection.CreateContexts</code> 遍历从 <code class="language-plaintext highlighter-rouge">UpdateTablets</code> 更新的 <code class="language-plaintext highlighter-rouge">_tablets</code> 进行创建。</p>

<p>创建 PenContext 的过程是比较复杂，所以本渣就画了图</p>

<!-- ![](image/WPF 触摸到事件/WPF 触摸到事件1.png) -->

<p><img src="http://image.acmx.xyz/lindexi%2F2018810175638248" alt="" /></p>

<p>图片的实线就是表示直接在方法内调用，而虚线表示是在这个方法执行完的下一步，也就是不是方法直接调用。</p>

<p>创建 PenContext 需要 penContextInfo 是从 WorkerOperationCreateContext 拿到，底层是调用 IPimcTablet2 拿到需要的值</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>	<span class="k">internal</span> <span class="k">interface</span> <span class="nc">IPimcTablet2</span>
	<span class="p">{</span>
		<span class="c1">// 其他代码</span>

		<span class="k">void</span> <span class="nf">CreateContext</span><span class="p">(</span><span class="n">IntPtr</span> <span class="n">handle</span><span class="p">,</span> <span class="p">[</span><span class="nf">MarshalAs</span><span class="p">(</span><span class="n">UnmanagedType</span><span class="p">.</span><span class="n">Bool</span><span class="p">)]</span> <span class="kt">bool</span> <span class="n">fEnable</span><span class="p">,</span> <span class="kt">uint</span> <span class="n">timeout</span><span class="p">,</span> <span class="k">out</span> <span class="n">IPimcContext2</span> <span class="n">IPimcContext</span><span class="p">,</span> <span class="k">out</span> <span class="kt">int</span> <span class="n">key</span><span class="p">,</span> <span class="k">out</span> <span class="kt">long</span> <span class="n">commHandle</span><span class="p">);</span>
	<span class="p">}</span>
</code></pre></div></div>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>					<span class="c1">// 下面 _pimcTablet 是 IPimcTablet2</span>
					<span class="k">this</span><span class="p">.</span><span class="n">_pimcTablet</span><span class="p">.</span><span class="nf">CreateContext</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="n">_hwnd</span><span class="p">,</span> <span class="k">true</span><span class="p">,</span> <span class="m">250u</span><span class="p">,</span> <span class="k">out</span> <span class="kt">var</span> <span class="n">pimcContext</span><span class="p">,</span> <span class="k">out</span> <span class="kt">var</span> <span class="n">contextId</span><span class="p">,</span> <span class="k">out</span> <span class="kt">var</span> <span class="n">num</span><span class="p">);</span>
					<span class="n">PenContextInfo</span> <span class="n">result</span><span class="p">;</span><span class="c1">// 这是结构体</span>
					<span class="n">result</span><span class="p">.</span><span class="n">ContextId</span> <span class="p">=</span> <span class="n">contextId</span><span class="p">;</span>
					<span class="n">result</span><span class="p">.</span><span class="n">PimcContext</span> <span class="p">=</span> <span class="k">new</span> <span class="n">SecurityCriticalDataClass</span><span class="p">&lt;</span><span class="n">IPimcContext2</span><span class="p">&gt;(</span><span class="n">pimcContext</span><span class="p">);</span>
					<span class="n">result</span><span class="p">.</span><span class="n">CommHandle</span> <span class="p">=</span> <span class="k">new</span> <span class="n">SecurityCriticalDataClass</span><span class="p">&lt;</span><span class="n">IntPtr</span><span class="p">&gt;(</span><span class="k">new</span> <span class="nf">IntPtr</span><span class="p">(</span><span class="n">num</span><span class="p">));</span>
					<span class="n">result</span><span class="p">.</span><span class="n">WispContextKey</span> <span class="p">=</span> <span class="n">UnsafeNativeMethods</span><span class="p">.</span><span class="nf">QueryWispContextKey</span><span class="p">(</span><span class="n">pimcContext</span><span class="p">);</span>
					<span class="k">this</span><span class="p">.</span><span class="n">_result</span> <span class="p">=</span> <span class="n">result</span><span class="p">;</span>
</code></pre></div></div>

<p>这里很重要的两个值是 <code class="language-plaintext highlighter-rouge">IPimcContext</code> 和 <code class="language-plaintext highlighter-rouge">commHandle</code> 在创建 PenContext 主要就需要这两个值，在 PenContext 的字段是 <code class="language-plaintext highlighter-rouge">_pimcContext</code> <code class="language-plaintext highlighter-rouge">_commHandle</code> 在上面的获得触摸的过程就需要这两个值</p>

<p>触摸的代码很重要就是拿到 <code class="language-plaintext highlighter-rouge">_handle</code> 的值，这个值在 <code class="language-plaintext highlighter-rouge">PenThreadWorker.AddPenContext</code> 创建，实际就是拿 PenContext 的值，请看代码</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>		<span class="k">internal</span> <span class="kt">bool</span> <span class="nf">AddPenContext</span><span class="p">(</span><span class="n">PenContext</span> <span class="n">penContext</span><span class="p">)</span>
		<span class="p">{</span>
		 	<span class="kt">var</span> <span class="n">list</span> <span class="p">=</span> <span class="n">_penContexts</span><span class="p">;</span>	
		 	<span class="n">list</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="n">penContext</span><span class="p">);</span>
			<span class="n">UnsafeNativeMethods</span><span class="p">.</span><span class="nf">CheckedLockWispObjectFromGit</span><span class="p">(</span><span class="n">penContext</span><span class="p">.</span><span class="n">WispContextKey</span><span class="p">);</span>
			<span class="n">_pimcContexts</span> <span class="p">=</span> <span class="k">new</span> <span class="n">IPimcContext2</span><span class="p">[</span><span class="n">list</span><span class="p">.</span><span class="n">Count</span><span class="p">];</span>
			<span class="n">_penContexts</span> <span class="p">=</span> <span class="k">new</span> <span class="n">WeakReference</span><span class="p">[</span><span class="n">list</span><span class="p">.</span><span class="n">Count</span><span class="p">];</span>
			<span class="n">_handles</span> <span class="p">=</span> <span class="k">new</span> <span class="n">IntPtr</span><span class="p">[</span><span class="n">list</span><span class="p">.</span><span class="n">Count</span><span class="p">];</span>
			<span class="n">_wispContextKeys</span> <span class="p">=</span> <span class="k">new</span> <span class="kt">uint</span><span class="p">[</span><span class="n">list</span><span class="p">.</span><span class="n">Count</span><span class="p">];</span>
			<span class="k">foreach</span><span class="p">(</span><span class="kt">var</span> <span class="n">temp</span> <span class="k">in</span> <span class="n">list</span><span class="p">)</span>
			<span class="p">{</span>				
				<span class="n">_handles</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="p">=</span> <span class="n">temp</span><span class="p">.</span><span class="n">CommHandle</span><span class="p">;</span>
				<span class="n">_pimcContexts</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="p">=</span> <span class="n">temp</span><span class="p">.</span><span class="n">_pimcContext</span><span class="p">.</span><span class="n">Value</span><span class="p">;</span>
				<span class="n">_penContexts</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">WeakReference</span><span class="p">(</span><span class="n">temp</span><span class="p">);</span>
				<span class="n">_wispContextKeys</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="p">=</span> <span class="n">temp</span><span class="p">.</span><span class="n">WispContextKey</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
</code></pre></div></div>

<h3 id="创建触摸线程方法">创建触摸线程方法</h3>

<p>触摸线程是 PenThreadWorker 里面的创建，创建的线程名是 <code class="language-plaintext highlighter-rouge">Stylus Input</code> 在一个 UI 显示窗口的线程只有一个 <code class="language-plaintext highlighter-rouge">Stylus Input</code> 线程</p>

<p>创建的调用堆栈如下</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="n">PresentationCore</span><span class="p">.</span><span class="n">dll</span><span class="p">!</span><span class="n">System</span><span class="p">.</span><span class="n">Windows</span><span class="p">.</span><span class="n">Input</span><span class="p">.</span><span class="n">PenThreadWorker</span><span class="p">..</span><span class="nf">ctor</span><span class="p">()</span>  
 <span class="n">PresentationCore</span><span class="p">.</span><span class="n">dll</span><span class="p">!</span><span class="n">System</span><span class="p">.</span><span class="n">Windows</span><span class="p">.</span><span class="n">Input</span><span class="p">.</span><span class="n">PenThread</span><span class="p">..</span><span class="nf">ctor</span><span class="p">()</span>  
 <span class="n">PresentationCore</span><span class="p">.</span><span class="n">dll</span><span class="p">!</span><span class="n">System</span><span class="p">.</span><span class="n">Windows</span><span class="p">.</span><span class="n">Input</span><span class="p">.</span><span class="n">PenThreadPool</span><span class="p">.</span><span class="nf">GetPenThreadForPenContextHelper</span><span class="p">(</span><span class="n">System</span><span class="p">.</span><span class="n">Windows</span><span class="p">.</span><span class="n">Input</span><span class="p">.</span><span class="n">PenContext</span> <span class="n">penContext</span><span class="p">)</span>  
 <span class="n">PresentationCore</span><span class="p">.</span><span class="n">dll</span><span class="p">!</span><span class="n">System</span><span class="p">.</span><span class="n">Windows</span><span class="p">.</span><span class="n">Input</span><span class="p">.</span><span class="n">PenThreadPool</span><span class="p">.</span><span class="nf">GetPenThreadForPenContext</span><span class="p">(</span><span class="n">System</span><span class="p">.</span><span class="n">Windows</span><span class="p">.</span><span class="n">Input</span><span class="p">.</span><span class="n">PenContext</span> <span class="n">penContext</span><span class="p">)</span>  
 <span class="n">PresentationCore</span><span class="p">.</span><span class="n">dll</span><span class="p">!</span><span class="n">System</span><span class="p">.</span><span class="n">Windows</span><span class="p">.</span><span class="n">Input</span><span class="p">.</span><span class="n">StylusWisp</span><span class="p">.</span><span class="n">WispTabletDeviceCollection</span><span class="p">.</span><span class="nf">UpdateTabletsImpl</span><span class="p">()</span>  
 <span class="n">PresentationCore</span><span class="p">.</span><span class="n">dll</span><span class="p">!</span><span class="n">System</span><span class="p">.</span><span class="n">Windows</span><span class="p">.</span><span class="n">Input</span><span class="p">.</span><span class="n">StylusWisp</span><span class="p">.</span><span class="n">WispTabletDeviceCollection</span><span class="p">.</span><span class="nf">UpdateTablets</span><span class="p">()</span>  
 <span class="n">PresentationCore</span><span class="p">.</span><span class="n">dll</span><span class="p">!</span><span class="n">System</span><span class="p">.</span><span class="n">Windows</span><span class="p">.</span><span class="n">Input</span><span class="p">.</span><span class="n">StylusWisp</span><span class="p">.</span><span class="n">WispTabletDeviceCollection</span><span class="p">..</span><span class="nf">ctor</span><span class="p">()</span>  
 <span class="n">PresentationCore</span><span class="p">.</span><span class="n">dll</span><span class="p">!</span><span class="n">System</span><span class="p">.</span><span class="n">Windows</span><span class="p">.</span><span class="n">Input</span><span class="p">.</span><span class="n">StylusWisp</span><span class="p">.</span><span class="n">WispLogic</span><span class="p">.</span><span class="nf">get_WispTabletDevices</span><span class="p">()</span>  
 <span class="n">PresentationCore</span><span class="p">.</span><span class="n">dll</span><span class="p">!</span><span class="n">System</span><span class="p">.</span><span class="n">Windows</span><span class="p">.</span><span class="n">Input</span><span class="p">.</span><span class="n">StylusWisp</span><span class="p">.</span><span class="n">WispLogic</span><span class="p">.</span><span class="nf">RegisterHwndForInput</span><span class="p">(</span><span class="n">System</span><span class="p">.</span><span class="n">Windows</span><span class="p">.</span><span class="n">Input</span><span class="p">.</span><span class="n">InputManager</span> <span class="n">inputManager</span><span class="p">,</span> <span class="n">System</span><span class="p">.</span><span class="n">Windows</span><span class="p">.</span><span class="n">PresentationSource</span> <span class="n">inputSource</span><span class="p">)</span>  
 <span class="n">PresentationCore</span><span class="p">.</span><span class="n">dll</span><span class="p">!</span><span class="n">System</span><span class="p">.</span><span class="n">Windows</span><span class="p">.</span><span class="n">Interop</span><span class="p">.</span><span class="n">HwndStylusInputProvider</span><span class="p">..</span><span class="nf">ctor</span><span class="p">(</span><span class="n">System</span><span class="p">.</span><span class="n">Windows</span><span class="p">.</span><span class="n">Interop</span><span class="p">.</span><span class="n">HwndSource</span> <span class="n">source</span><span class="p">)</span>  
 <span class="n">PresentationCore</span><span class="p">.</span><span class="n">dll</span><span class="p">!</span><span class="n">System</span><span class="p">.</span><span class="n">Windows</span><span class="p">.</span><span class="n">Interop</span><span class="p">.</span><span class="n">HwndSource</span><span class="p">.</span><span class="nf">Initialize</span><span class="p">(</span><span class="n">System</span><span class="p">.</span><span class="n">Windows</span><span class="p">.</span><span class="n">Interop</span><span class="p">.</span><span class="n">HwndSourceParameters</span> <span class="n">parameters</span><span class="p">)</span>  
 <span class="n">PresentationCore</span><span class="p">.</span><span class="n">dll</span><span class="p">!</span><span class="n">System</span><span class="p">.</span><span class="n">Windows</span><span class="p">.</span><span class="n">Interop</span><span class="p">.</span><span class="n">HwndSource</span><span class="p">..</span><span class="nf">ctor</span><span class="p">(</span><span class="n">System</span><span class="p">.</span><span class="n">Windows</span><span class="p">.</span><span class="n">Interop</span><span class="p">.</span><span class="n">HwndSourceParameters</span> <span class="n">parameters</span><span class="p">)</span>  
 <span class="n">PresentationFramework</span><span class="p">.</span><span class="n">dll</span><span class="p">!</span><span class="n">System</span><span class="p">.</span><span class="n">Windows</span><span class="p">.</span><span class="n">Window</span><span class="p">.</span><span class="nf">CreateSourceWindow</span><span class="p">(</span><span class="kt">bool</span> <span class="n">duringShow</span><span class="p">)</span>  
 <span class="n">PresentationFramework</span><span class="p">.</span><span class="n">dll</span><span class="p">!</span><span class="n">System</span><span class="p">.</span><span class="n">Windows</span><span class="p">.</span><span class="n">Window</span><span class="p">.</span><span class="nf">CreateSourceWindowDuringShow</span><span class="p">()</span>  
 <span class="n">PresentationFramework</span><span class="p">.</span><span class="n">dll</span><span class="p">!</span><span class="n">System</span><span class="p">.</span><span class="n">Windows</span><span class="p">.</span><span class="n">Window</span><span class="p">.</span><span class="nf">SafeCreateWindowDuringShow</span><span class="p">()</span>  
 <span class="n">PresentationFramework</span><span class="p">.</span><span class="n">dll</span><span class="p">!</span><span class="n">System</span><span class="p">.</span><span class="n">Windows</span><span class="p">.</span><span class="n">Window</span><span class="p">.</span><span class="nf">ShowHelper</span><span class="p">(</span><span class="kt">object</span> <span class="n">booleanBox</span><span class="p">)</span>  
 <span class="n">WindowsBase</span><span class="p">.</span><span class="n">dll</span><span class="p">!</span><span class="n">System</span><span class="p">.</span><span class="n">Windows</span><span class="p">.</span><span class="n">Threading</span><span class="p">.</span><span class="n">ExceptionWrapper</span><span class="p">.</span><span class="nf">InternalRealCall</span><span class="p">(</span><span class="n">System</span><span class="p">.</span><span class="n">Delegate</span> <span class="n">callback</span><span class="p">,</span> <span class="kt">object</span> <span class="n">args</span><span class="p">,</span> <span class="kt">int</span> <span class="n">numArgs</span><span class="p">)</span>  
 <span class="n">WindowsBase</span><span class="p">.</span><span class="n">dll</span><span class="p">!</span><span class="n">System</span><span class="p">.</span><span class="n">Windows</span><span class="p">.</span><span class="n">Threading</span><span class="p">.</span><span class="n">ExceptionWrapper</span><span class="p">.</span><span class="nf">TryCatchWhen</span><span class="p">(</span><span class="kt">object</span> <span class="n">source</span><span class="p">,</span> <span class="n">System</span><span class="p">.</span><span class="n">Delegate</span> <span class="n">callback</span><span class="p">,</span> <span class="kt">object</span> <span class="n">args</span><span class="p">,</span> <span class="kt">int</span> <span class="n">numArgs</span><span class="p">,</span> <span class="n">System</span><span class="p">.</span><span class="n">Delegate</span> <span class="n">catchHandler</span><span class="p">)</span>  
 <span class="n">WindowsBase</span><span class="p">.</span><span class="n">dll</span><span class="p">!</span><span class="n">System</span><span class="p">.</span><span class="n">Windows</span><span class="p">.</span><span class="n">Threading</span><span class="p">.</span><span class="n">Dispatcher</span><span class="p">.</span><span class="nf">WrappedInvoke</span><span class="p">(</span><span class="n">System</span><span class="p">.</span><span class="n">Delegate</span> <span class="n">callback</span><span class="p">,</span> <span class="kt">object</span> <span class="n">args</span><span class="p">,</span> <span class="kt">int</span> <span class="n">numArgs</span><span class="p">,</span> <span class="n">System</span><span class="p">.</span><span class="n">Delegate</span> <span class="n">catchHandler</span><span class="p">)</span>  
 <span class="n">WindowsBase</span><span class="p">.</span><span class="n">dll</span><span class="p">!</span><span class="n">System</span><span class="p">.</span><span class="n">Windows</span><span class="p">.</span><span class="n">Threading</span><span class="p">.</span><span class="n">DispatcherOperation</span><span class="p">.</span><span class="nf">InvokeImpl</span><span class="p">()</span>  
 <span class="n">WindowsBase</span><span class="p">.</span><span class="n">dll</span><span class="p">!</span><span class="n">System</span><span class="p">.</span><span class="n">Windows</span><span class="p">.</span><span class="n">Threading</span><span class="p">.</span><span class="n">DispatcherOperation</span><span class="p">.</span><span class="nf">InvokeInSecurityContext</span><span class="p">(</span><span class="kt">object</span> <span class="n">state</span><span class="p">)</span>  
 <span class="n">WindowsBase</span><span class="p">.</span><span class="n">dll</span><span class="p">!</span><span class="n">MS</span><span class="p">.</span><span class="n">Internal</span><span class="p">.</span><span class="n">CulturePreservingExecutionContext</span><span class="p">.</span><span class="nf">CallbackWrapper</span><span class="p">(</span><span class="kt">object</span> <span class="n">obj</span><span class="p">)</span>  
 <span class="n">mscorlib</span><span class="p">.</span><span class="n">dll</span><span class="p">!</span><span class="n">System</span><span class="p">.</span><span class="n">Threading</span><span class="p">.</span><span class="n">ExecutionContext</span><span class="p">.</span><span class="nf">RunInternal</span><span class="p">(</span><span class="n">System</span><span class="p">.</span><span class="n">Threading</span><span class="p">.</span><span class="n">ExecutionContext</span> <span class="n">executionContext</span><span class="p">,</span> <span class="n">System</span><span class="p">.</span><span class="n">Threading</span><span class="p">.</span><span class="n">ContextCallback</span> <span class="n">callback</span><span class="p">,</span> <span class="kt">object</span> <span class="n">state</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">preserveSyncCtx</span><span class="p">)</span>  
 <span class="n">mscorlib</span><span class="p">.</span><span class="n">dll</span><span class="p">!</span><span class="n">System</span><span class="p">.</span><span class="n">Threading</span><span class="p">.</span><span class="n">ExecutionContext</span><span class="p">.</span><span class="nf">Run</span><span class="p">(</span><span class="n">System</span><span class="p">.</span><span class="n">Threading</span><span class="p">.</span><span class="n">ExecutionContext</span> <span class="n">executionContext</span><span class="p">,</span> <span class="n">System</span><span class="p">.</span><span class="n">Threading</span><span class="p">.</span><span class="n">ContextCallback</span> <span class="n">callback</span><span class="p">,</span> <span class="kt">object</span> <span class="n">state</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">preserveSyncCtx</span><span class="p">)</span>  
 <span class="n">mscorlib</span><span class="p">.</span><span class="n">dll</span><span class="p">!</span><span class="n">System</span><span class="p">.</span><span class="n">Threading</span><span class="p">.</span><span class="n">ExecutionContext</span><span class="p">.</span><span class="nf">Run</span><span class="p">(</span><span class="n">System</span><span class="p">.</span><span class="n">Threading</span><span class="p">.</span><span class="n">ExecutionContext</span> <span class="n">executionContext</span><span class="p">,</span> <span class="n">System</span><span class="p">.</span><span class="n">Threading</span><span class="p">.</span><span class="n">ContextCallback</span> <span class="n">callback</span><span class="p">,</span> <span class="kt">object</span> <span class="n">state</span><span class="p">)</span>  
 <span class="n">WindowsBase</span><span class="p">.</span><span class="n">dll</span><span class="p">!</span><span class="n">MS</span><span class="p">.</span><span class="n">Internal</span><span class="p">.</span><span class="n">CulturePreservingExecutionContext</span><span class="p">.</span><span class="nf">Run</span><span class="p">(</span><span class="n">MS</span><span class="p">.</span><span class="n">Internal</span><span class="p">.</span><span class="n">CulturePreservingExecutionContext</span> <span class="n">executionContext</span><span class="p">,</span> <span class="n">System</span><span class="p">.</span><span class="n">Threading</span><span class="p">.</span><span class="n">ContextCallback</span> <span class="n">callback</span><span class="p">,</span> <span class="kt">object</span> <span class="n">state</span><span class="p">)</span>  
 <span class="n">WindowsBase</span><span class="p">.</span><span class="n">dll</span><span class="p">!</span><span class="n">System</span><span class="p">.</span><span class="n">Windows</span><span class="p">.</span><span class="n">Threading</span><span class="p">.</span><span class="n">DispatcherOperation</span><span class="p">.</span><span class="nf">Invoke</span><span class="p">()</span>  
 <span class="n">WindowsBase</span><span class="p">.</span><span class="n">dll</span><span class="p">!</span><span class="n">System</span><span class="p">.</span><span class="n">Windows</span><span class="p">.</span><span class="n">Threading</span><span class="p">.</span><span class="n">Dispatcher</span><span class="p">.</span><span class="nf">ProcessQueue</span><span class="p">()</span>  
 <span class="n">WindowsBase</span><span class="p">.</span><span class="n">dll</span><span class="p">!</span><span class="n">System</span><span class="p">.</span><span class="n">Windows</span><span class="p">.</span><span class="n">Threading</span><span class="p">.</span><span class="n">Dispatcher</span><span class="p">.</span><span class="nf">WndProcHook</span><span class="p">(</span><span class="n">System</span><span class="p">.</span><span class="n">IntPtr</span> <span class="n">hwnd</span><span class="p">,</span> <span class="kt">int</span> <span class="n">msg</span><span class="p">,</span> <span class="n">System</span><span class="p">.</span><span class="n">IntPtr</span> <span class="n">wParam</span><span class="p">,</span> <span class="n">System</span><span class="p">.</span><span class="n">IntPtr</span> <span class="n">lParam</span><span class="p">,</span> <span class="k">ref</span> <span class="kt">bool</span> <span class="n">handled</span><span class="p">)</span>  
 <span class="n">WindowsBase</span><span class="p">.</span><span class="n">dll</span><span class="p">!</span><span class="n">MS</span><span class="p">.</span><span class="n">Win32</span><span class="p">.</span><span class="n">HwndWrapper</span><span class="p">.</span><span class="nf">WndProc</span><span class="p">(</span><span class="n">System</span><span class="p">.</span><span class="n">IntPtr</span> <span class="n">hwnd</span><span class="p">,</span> <span class="kt">int</span> <span class="n">msg</span><span class="p">,</span> <span class="n">System</span><span class="p">.</span><span class="n">IntPtr</span> <span class="n">wParam</span><span class="p">,</span> <span class="n">System</span><span class="p">.</span><span class="n">IntPtr</span> <span class="n">lParam</span><span class="p">,</span> <span class="k">ref</span> <span class="kt">bool</span> <span class="n">handled</span><span class="p">)</span>  
 <span class="n">WindowsBase</span><span class="p">.</span><span class="n">dll</span><span class="p">!</span><span class="n">MS</span><span class="p">.</span><span class="n">Win32</span><span class="p">.</span><span class="n">HwndSubclass</span><span class="p">.</span><span class="nf">DispatcherCallbackOperation</span><span class="p">(</span><span class="kt">object</span> <span class="n">o</span><span class="p">)</span>  
 <span class="n">WindowsBase</span><span class="p">.</span><span class="n">dll</span><span class="p">!</span><span class="n">System</span><span class="p">.</span><span class="n">Windows</span><span class="p">.</span><span class="n">Threading</span><span class="p">.</span><span class="n">ExceptionWrapper</span><span class="p">.</span><span class="nf">InternalRealCall</span><span class="p">(</span><span class="n">System</span><span class="p">.</span><span class="n">Delegate</span> <span class="n">callback</span><span class="p">,</span> <span class="kt">object</span> <span class="n">args</span><span class="p">,</span> <span class="kt">int</span> <span class="n">numArgs</span><span class="p">)</span>  
 <span class="n">WindowsBase</span><span class="p">.</span><span class="n">dll</span><span class="p">!</span><span class="n">System</span><span class="p">.</span><span class="n">Windows</span><span class="p">.</span><span class="n">Threading</span><span class="p">.</span><span class="n">ExceptionWrapper</span><span class="p">.</span><span class="nf">TryCatchWhen</span><span class="p">(</span><span class="kt">object</span> <span class="n">source</span><span class="p">,</span> <span class="n">System</span><span class="p">.</span><span class="n">Delegate</span> <span class="n">callback</span><span class="p">,</span> <span class="kt">object</span> <span class="n">args</span><span class="p">,</span> <span class="kt">int</span> <span class="n">numArgs</span><span class="p">,</span> <span class="n">System</span><span class="p">.</span><span class="n">Delegate</span> <span class="n">catchHandler</span><span class="p">)</span>  
 <span class="n">WindowsBase</span><span class="p">.</span><span class="n">dll</span><span class="p">!</span><span class="n">System</span><span class="p">.</span><span class="n">Windows</span><span class="p">.</span><span class="n">Threading</span><span class="p">.</span><span class="n">Dispatcher</span><span class="p">.</span><span class="nf">WrappedInvoke</span><span class="p">(</span><span class="n">System</span><span class="p">.</span><span class="n">Delegate</span> <span class="n">callback</span><span class="p">,</span> <span class="kt">object</span> <span class="n">args</span><span class="p">,</span> <span class="kt">int</span> <span class="n">numArgs</span><span class="p">,</span> <span class="n">System</span><span class="p">.</span><span class="n">Delegate</span> <span class="n">catchHandler</span><span class="p">)</span>  
 <span class="n">WindowsBase</span><span class="p">.</span><span class="n">dll</span><span class="p">!</span><span class="n">System</span><span class="p">.</span><span class="n">Windows</span><span class="p">.</span><span class="n">Threading</span><span class="p">.</span><span class="n">Dispatcher</span><span class="p">.</span><span class="nf">LegacyInvokeImpl</span><span class="p">(</span><span class="n">System</span><span class="p">.</span><span class="n">Windows</span><span class="p">.</span><span class="n">Threading</span><span class="p">.</span><span class="n">DispatcherPriority</span> <span class="n">priority</span><span class="p">,</span> <span class="n">System</span><span class="p">.</span><span class="n">TimeSpan</span> <span class="n">timeout</span><span class="p">,</span> <span class="n">System</span><span class="p">.</span><span class="n">Delegate</span> <span class="n">method</span><span class="p">,</span> <span class="kt">object</span> <span class="n">args</span><span class="p">,</span> <span class="kt">int</span> <span class="n">numArgs</span><span class="p">)</span>  
 <span class="n">WindowsBase</span><span class="p">.</span><span class="n">dll</span><span class="p">!</span><span class="n">System</span><span class="p">.</span><span class="n">Windows</span><span class="p">.</span><span class="n">Threading</span><span class="p">.</span><span class="n">Dispatcher</span><span class="p">.</span><span class="nf">Invoke</span><span class="p">(</span><span class="n">System</span><span class="p">.</span><span class="n">Windows</span><span class="p">.</span><span class="n">Threading</span><span class="p">.</span><span class="n">DispatcherPriority</span> <span class="n">priority</span><span class="p">,</span> <span class="n">System</span><span class="p">.</span><span class="n">Delegate</span> <span class="n">method</span><span class="p">,</span> <span class="kt">object</span> <span class="n">arg</span><span class="p">)</span>  
 <span class="n">WindowsBase</span><span class="p">.</span><span class="n">dll</span><span class="p">!</span><span class="n">MS</span><span class="p">.</span><span class="n">Win32</span><span class="p">.</span><span class="n">HwndSubclass</span><span class="p">.</span><span class="nf">SubclassWndProc</span><span class="p">(</span><span class="n">System</span><span class="p">.</span><span class="n">IntPtr</span> <span class="n">hwnd</span><span class="p">,</span> <span class="kt">int</span> <span class="n">msg</span><span class="p">,</span> <span class="n">System</span><span class="p">.</span><span class="n">IntPtr</span> <span class="n">wParam</span><span class="p">,</span> <span class="n">System</span><span class="p">.</span><span class="n">IntPtr</span> <span class="n">lParam</span><span class="p">)</span>  
 <span class="p">[</span><span class="err">托管到本机的转换</span><span class="p">]</span>
 <span class="n">WindowsBase</span><span class="p">.</span><span class="n">dll</span><span class="p">!</span><span class="n">System</span><span class="p">.</span><span class="n">Windows</span><span class="p">.</span><span class="n">Threading</span><span class="p">.</span><span class="n">Dispatcher</span><span class="p">.</span><span class="nf">TranslateAndDispatchMessage</span><span class="p">(</span><span class="k">ref</span> <span class="n">System</span><span class="p">.</span><span class="n">Windows</span><span class="p">.</span><span class="n">Interop</span><span class="p">.</span><span class="n">MSG</span> <span class="n">msg</span><span class="p">)</span>  
 <span class="n">WindowsBase</span><span class="p">.</span><span class="n">dll</span><span class="p">!</span><span class="n">System</span><span class="p">.</span><span class="n">Windows</span><span class="p">.</span><span class="n">Threading</span><span class="p">.</span><span class="n">Dispatcher</span><span class="p">.</span><span class="nf">PushFrameImpl</span><span class="p">(</span><span class="n">System</span><span class="p">.</span><span class="n">Windows</span><span class="p">.</span><span class="n">Threading</span><span class="p">.</span><span class="n">DispatcherFrame</span> <span class="n">frame</span><span class="p">)</span>  
 <span class="n">WindowsBase</span><span class="p">.</span><span class="n">dll</span><span class="p">!</span><span class="n">System</span><span class="p">.</span><span class="n">Windows</span><span class="p">.</span><span class="n">Threading</span><span class="p">.</span><span class="n">Dispatcher</span><span class="p">.</span><span class="nf">PushFrame</span><span class="p">(</span><span class="n">System</span><span class="p">.</span><span class="n">Windows</span><span class="p">.</span><span class="n">Threading</span><span class="p">.</span><span class="n">DispatcherFrame</span> <span class="n">frame</span><span class="p">)</span>  
 <span class="n">WindowsBase</span><span class="p">.</span><span class="n">dll</span><span class="p">!</span><span class="n">System</span><span class="p">.</span><span class="n">Windows</span><span class="p">.</span><span class="n">Threading</span><span class="p">.</span><span class="n">Dispatcher</span><span class="p">.</span><span class="nf">Run</span><span class="p">()</span>  
 <span class="n">PresentationFramework</span><span class="p">.</span><span class="n">dll</span><span class="p">!</span><span class="n">System</span><span class="p">.</span><span class="n">Windows</span><span class="p">.</span><span class="n">Application</span><span class="p">.</span><span class="nf">RunDispatcher</span><span class="p">(</span><span class="kt">object</span> <span class="n">ignore</span><span class="p">)</span>  
 <span class="n">PresentationFramework</span><span class="p">.</span><span class="n">dll</span><span class="p">!</span><span class="n">System</span><span class="p">.</span><span class="n">Windows</span><span class="p">.</span><span class="n">Application</span><span class="p">.</span><span class="nf">RunInternal</span><span class="p">(</span><span class="n">System</span><span class="p">.</span><span class="n">Windows</span><span class="p">.</span><span class="n">Window</span> <span class="n">window</span><span class="p">)</span>  
 <span class="n">PresentationFramework</span><span class="p">.</span><span class="n">dll</span><span class="p">!</span><span class="n">System</span><span class="p">.</span><span class="n">Windows</span><span class="p">.</span><span class="n">Application</span><span class="p">.</span><span class="nf">Run</span><span class="p">(</span><span class="n">System</span><span class="p">.</span><span class="n">Windows</span><span class="p">.</span><span class="n">Window</span> <span class="n">window</span><span class="p">)</span>  
 <span class="n">PresentationFramework</span><span class="p">.</span><span class="n">dll</span><span class="p">!</span><span class="n">System</span><span class="p">.</span><span class="n">Windows</span><span class="p">.</span><span class="n">Application</span><span class="p">.</span><span class="nf">Run</span><span class="p">()</span>  
</code></pre></div></div>

<p>从窗口的 VisibilityChanged 开始，在这个方法调用了 <code class="language-plaintext highlighter-rouge">Window.ShowHelper</code> 方法</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="n">PenThreadWorker</span><span class="p">..</span><span class="nf">ctor</span><span class="p">()</span>  
 <span class="n">PenThread</span><span class="p">..</span><span class="nf">ctor</span><span class="p">()</span>  
 <span class="n">PenThreadPool</span><span class="p">.</span><span class="nf">GetPenThreadForPenContextHelper</span><span class="p">(</span><span class="n">PenContext</span> <span class="n">penContext</span><span class="p">)</span>  
 <span class="n">PenThreadPool</span><span class="p">.</span><span class="nf">GetPenThreadForPenContext</span><span class="p">(</span><span class="n">PenContext</span> <span class="n">penContext</span><span class="p">)</span>  
 <span class="n">WispTabletDeviceCollection</span><span class="p">.</span><span class="nf">UpdateTabletsImpl</span><span class="p">()</span>  
 <span class="n">WispTabletDeviceCollection</span><span class="p">.</span><span class="nf">UpdateTablets</span><span class="p">()</span>  
 <span class="n">WispTabletDeviceCollection</span><span class="p">..</span><span class="nf">ctor</span><span class="p">()</span>  
 <span class="n">WispLogic</span><span class="p">.</span><span class="nf">get_WispTabletDevices</span><span class="p">()</span>  
 <span class="n">WispLogic</span><span class="p">.</span><span class="nf">RegisterHwndForInput</span><span class="p">(</span><span class="n">InputManager</span> <span class="n">inputManager</span><span class="p">,</span> <span class="n">PresentationSource</span> <span class="n">inputSource</span><span class="p">)</span>  
 <span class="n">HwndStylusInputProvider</span><span class="p">..</span><span class="nf">ctor</span><span class="p">(</span><span class="n">HwndSource</span> <span class="n">source</span><span class="p">)</span>  
 <span class="n">HwndSource</span><span class="p">.</span><span class="nf">Initialize</span><span class="p">(</span><span class="n">HwndSourceParameters</span> <span class="n">parameters</span><span class="p">)</span>  
 <span class="n">HwndSource</span><span class="p">..</span><span class="nf">ctor</span><span class="p">(</span><span class="n">HwndSourceParameters</span> <span class="n">parameters</span><span class="p">)</span>  

 <span class="n">PresentationFramework</span><span class="p">.</span><span class="n">dll</span><span class="p">!</span><span class="n">System</span><span class="p">.</span><span class="n">Windows</span><span class="p">.</span><span class="n">Window</span><span class="p">.</span><span class="nf">CreateSourceWindow</span><span class="p">(</span><span class="kt">bool</span> <span class="n">duringShow</span><span class="p">)</span>  
 <span class="n">PresentationFramework</span><span class="p">.</span><span class="n">dll</span><span class="p">!</span><span class="n">System</span><span class="p">.</span><span class="n">Windows</span><span class="p">.</span><span class="n">Window</span><span class="p">.</span><span class="nf">CreateSourceWindowDuringShow</span><span class="p">()</span>  
 <span class="n">PresentationFramework</span><span class="p">.</span><span class="n">dll</span><span class="p">!</span><span class="n">System</span><span class="p">.</span><span class="n">Windows</span><span class="p">.</span><span class="n">Window</span><span class="p">.</span><span class="nf">ShowHelper</span><span class="p">(</span><span class="kt">object</span> <span class="n">booleanBox</span><span class="p">)</span>  
</code></pre></div></div>

<p>在 HwndStylusInputProvider 的构造方法会使用下面代码拿到两个单例</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>			<span class="n">InputManager</span> <span class="n">inputManager</span> <span class="p">=</span> <span class="n">InputManager</span><span class="p">.</span><span class="n">Current</span><span class="p">;</span>
			<span class="n">_stylusLogic</span> <span class="p">=</span> <span class="n">StylusLogic</span><span class="p">.</span><span class="n">GetCurrentStylusLogicAs</span><span class="p">&lt;</span><span class="n">WispLogic</span><span class="p">&gt;();</span>
</code></pre></div></div>

<p>在 <code class="language-plaintext highlighter-rouge">_stylusLogic</code> 的 RegisterHwndForInput 方法里面会用到 WispTabletDevices 属性，这个属性在这个单例一开始没有初始化，需要在获取的方法初始化</p>

<p>在WispTabletDevices属性获取的时候，第一次没有创建，需要走初始化的方法</p>

<p>在初始化方法调用 WispTabletDeviceCollection 的构造方法，在 WispTabletDeviceCollection 的 UpdateTablets 方法会尝试从 PenThreadPool 获取触摸线程</p>

<p>在 PenThreadPool 初始化的时候将会创建 PenThread 属性</p>

<p>在 PenThread 的构造函数将会创建 PenThreadWorker 属性</p>

<h2 id="如何保证每个界面线程都有触摸线程">如何保证每个界面线程都有触摸线程</h2>

<p>在 HwndStylusInputProvider 的构造函数会获取 <code class="language-plaintext highlighter-rouge">StylusLogic.GetCurrentStylusLogicAs&lt;WispLogic&gt;()</code> 这个方法在没有初始化的时候将会调用初始化，在这里的代码将会创建触摸线程</p>

<p>在 GetCurrentStylusLogicAs 方法会获取 <code class="language-plaintext highlighter-rouge">StylusLogic.CurrentStylusLogic</code> 属性，这个属性是静态的属性</p>

<p>在 <code class="language-plaintext highlighter-rouge">_currentStylusLogic</code> 字段标记了 <a href="https://docs.microsoft.com/en-us/dotnet/api/system.threadstaticattribute?view=netframework-4.8">ThreadStaticAttribute</a> 在每个线程都是独立的，所以新的界面线程进来的时候获取到的值是空的，需要初始化同时在初始化之后下一次获取 WispLogic.WispTabletDevices 属性就可以找到值，不需要重新初始化</p>

<p>线程静态的字段博客 <a href="https://blog.lindexi.com/post/dotnet-%E7%BA%BF%E7%A8%8B%E9%9D%99%E6%80%81%E5%AD%97%E6%AE%B5.html">dotnet 线程静态字段</a></p>

<p>这样在每个 UI 线程都有自己独立的 StylusLogic 也就有独立的线程</p>

<p>课件</p>

<p><a href="https://r302.cc/DKzkRX"><img src="http://image.acmx.xyz/lindexi%2F20181113105010622" alt="" /></a></p>

<p>更多触摸请看 <a href="https://blog.lindexi.com/post/WPF-%E8%A7%A6%E6%91%B8%E7%9B%B8%E5%85%B3.html">WPF 触摸相关</a></p>

<p>参见：<a href="https://blog.csdn.net/tanmengwen/article/details/8128992">WPF应用程序中输入系统介绍 - CSDN博客</a></p>

<p><a href="https://www.cnblogs.com/Zhouyongh/archive/2009/11/30/1613628.html">一站式WPF–Window（一） - 周永恒 - 博客园</a></p>

<p><a href="https://lindexi.gitee.io/post/WPF-%E9%AB%98%E9%80%9F%E4%B9%A6%E5%86%99-StylusPlugIn-%E5%8E%9F%E7%90%86.html">WPF 高速书写 StylusPlugIn 原理</a></p>

<p><a href="https://blog.lindexi.com/post/win10-%E6%94%AF%E6%8C%81%E9%BB%98%E8%AE%A4%E6%8A%8A%E8%A7%A6%E6%91%B8%E6%8F%90%E5%8D%87-Pointer-%E6%B6%88%E6%81%AF.html">win10 支持默认把触摸提升鼠标事件 打开 Pointer 消息</a></p>

<p><a href="https://lindexi.gitee.io/post/WPF-%E7%A6%81%E7%94%A8%E5%AE%9E%E6%97%B6%E8%A7%A6%E6%91%B8.html">WPF 禁用实时触摸</a></p>

:ET