I"x2<p>本文告诉大家如何在使用 .net remoting 的时候，抛出异常。</p>

<!--more-->

<!-- CreateTime:2019/9/24 15:39:50 -->

<!-- 标签：.net remoting,rpc,wpf -->

<div id="toc"></div>

<p>所有在远程软件运行的类，如果需要传输到本地，都需要继承 MarshalByRefObject 或其他可以序列化的类。</p>

<p>在 .net Framework 4.0 就默认指定只反序列化基础类型，如果需要反序列化其他的类型，那么就需要设置<code class="language-plaintext highlighter-rouge">TypeFilterLevel</code>，设置的方法是在使用下面代码</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>      <span class="k">public</span> <span class="k">static</span> <span class="n">IChannel</span> <span class="nf">CreatChannel</span><span class="p">(</span><span class="kt">string</span> <span class="n">port</span> <span class="p">=</span> <span class="s">""</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="kt">string</span><span class="p">.</span><span class="nf">IsNullOrEmpty</span><span class="p">(</span><span class="n">port</span><span class="p">))</span>
            <span class="p">{</span>
                <span class="n">port</span> <span class="p">=</span> <span class="n">Guid</span><span class="p">.</span><span class="nf">NewGuid</span><span class="p">().</span><span class="nf">ToString</span><span class="p">(</span><span class="s">"N"</span><span class="p">);</span>
            <span class="p">}</span>

            <span class="kt">var</span> <span class="n">serverProvider</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">SoapServerFormatterSinkProvider</span><span class="p">();</span>
            <span class="kt">var</span> <span class="n">clientProvider</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">SoapClientFormatterSinkProvider</span><span class="p">();</span>
            <span class="n">serverProvider</span><span class="p">.</span><span class="n">TypeFilterLevel</span> <span class="p">=</span> <span class="n">TypeFilterLevel</span><span class="p">.</span><span class="n">Full</span><span class="p">;</span>
            <span class="n">IDictionary</span> <span class="n">props</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">Hashtable</span><span class="p">();</span>
            <span class="n">props</span><span class="p">[</span><span class="s">"portName"</span><span class="p">]</span> <span class="p">=</span> <span class="n">port</span><span class="p">.</span><span class="nf">ToString</span><span class="p">();</span>

            <span class="k">return</span> <span class="k">new</span> <span class="nf">IpcChannel</span><span class="p">(</span><span class="n">props</span><span class="p">,</span> <span class="n">clientProvider</span><span class="p">,</span> <span class="n">serverProvider</span><span class="p">);</span>
        <span class="p">}</span>
</code></pre></div></div>

<p>但是设置了TypeFilterLevel不是对所有的类型都可以进行转换，如果不小心直接在调用方法抛出异常，那么会因为无法反序列，让本地拿不到</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="c1">// 远程</span>

 <span class="k">public</span> <span class="k">void</span> <span class="nf">Foo</span><span class="p">()</span>
 <span class="p">{</span>
 	<span class="k">throw</span> <span class="k">new</span> <span class="nf">CsdnNotFoundException</span><span class="p">();</span>
 <span class="p">}</span>

 <span class="k">public</span> <span class="k">class</span> <span class="nc">CsdnNotFoundException</span> <span class="p">:</span> <span class="n">Exception</span>
 <span class="p">{</span>
 	<span class="k">public</span> <span class="nf">CsdnNotFoundException</span><span class="p">(</span><span class="kt">string</span> <span class="n">str</span><span class="p">)</span> <span class="p">:</span>
 	       <span class="k">base</span><span class="p">(</span><span class="n">str</span><span class="p">)</span>
 	<span class="p">{</span>

 	<span class="p">}</span>       
 <span class="p">}</span>
</code></pre></div></div>

<p>这时本地会提示<code class="language-plaintext highlighter-rouge">System.Runtime.Serialization.SerializationException</code>程序无法序列。</p>

<p>如果需要在 .net remoting 使用异常，那么需要自己创建一个异常，继承 RemotingException</p>

<h2 id="反序列">反序列</h2>

<p>因为默认的 RemotingException 没有反序列，所以需要添加 Serializable 特性</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="p">[</span><span class="n">Serializable</span><span class="p">]</span>
 <span class="k">public</span> <span class="k">class</span> <span class="nc">CsdnNotFoundException</span> <span class="p">:</span> <span class="n">RemotingException</span>
 <span class="p">{</span>
 	<span class="k">public</span> <span class="nf">CsdnNotFoundException</span><span class="p">(</span><span class="kt">string</span> <span class="n">str</span><span class="p">)</span> <span class="p">:</span>
 	       <span class="k">base</span><span class="p">(</span><span class="n">str</span><span class="p">)</span>
 	<span class="p">{</span>

 	<span class="p">}</span>       
 <span class="p">}</span>
</code></pre></div></div>

<p>微软建议继承<code class="language-plaintext highlighter-rouge">ISerializable</code>，标记特性</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="p">[</span><span class="n">Serializable</span><span class="p">]</span>
 <span class="k">public</span> <span class="k">class</span> <span class="nc">CsdnNotFoundException</span> <span class="p">:</span> <span class="n">RemotingException</span><span class="p">,</span> <span class="n">ISerializable</span>
 <span class="p">{</span>
 	<span class="k">public</span> <span class="nf">CsdnNotFoundException</span><span class="p">(</span><span class="kt">string</span> <span class="n">str</span><span class="p">)</span> <span class="p">:</span>
 	       <span class="k">base</span><span class="p">(</span><span class="n">str</span><span class="p">)</span>
 	<span class="p">{</span>

 	<span class="p">}</span>       
 <span class="p">}</span>
</code></pre></div></div>

<p>如果直接运行，会发现报告<code class="language-plaintext highlighter-rouge">System.Runtime.Serialization.SerializationException:“未找到反序列化“lindexi.Csdn.CsdnNotFoundException”类型对象的构造函数</code></p>

<p>解决方法是创建一个构造函数，写入这个函数就不需要再写其他的代码。</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        <span class="k">protected</span> <span class="nf">CsdnNotFoundException</span><span class="p">([</span><span class="n">NotNull</span><span class="p">]</span> <span class="n">SerializationInfo</span> <span class="n">info</span><span class="p">,</span> <span class="n">StreamingContext</span> <span class="n">context</span><span class="p">)</span> <span class="p">:</span> <span class="k">base</span><span class="p">(</span><span class="n">info</span><span class="p">,</span>
            <span class="n">context</span><span class="p">)</span>
        <span class="p">{</span>
        <span class="p">}</span>
</code></pre></div></div>

<p>如果有一些特殊的属性需要自己设置，建议创建一个默认构造函数，和两个方法，因为使用上面的方法不会序列化自己定义的属性。</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="p">[</span><span class="n">Serializable</span><span class="p">]</span>
 <span class="k">public</span> <span class="k">class</span> <span class="nc">CsdnNotFoundException</span> <span class="p">:</span> <span class="n">RemotingException</span><span class="p">,</span> <span class="n">ISerializable</span>
 <span class="p">{</span>
    <span class="k">public</span> <span class="nf">CsdnNotFoundException</span><span class="p">()</span>
    <span class="p">{</span>
    	<span class="c1">//默认构造，可以在反射创建</span>
    <span class="p">}</span>

 	<span class="k">public</span> <span class="nf">CsdnNotFoundException</span><span class="p">(</span><span class="kt">string</span> <span class="n">str</span><span class="p">)</span> <span class="p">:</span>
 	       <span class="k">base</span><span class="p">(</span><span class="n">str</span><span class="p">)</span>
 	<span class="p">{</span>

 	<span class="p">}</span>      

 	      <span class="k">protected</span> <span class="nf">CsdnNotFoundException</span><span class="p">([</span><span class="n">NotNull</span><span class="p">]</span> <span class="n">SerializationInfo</span> <span class="n">info</span><span class="p">,</span> <span class="n">StreamingContext</span> <span class="n">context</span><span class="p">)</span> 
 	      <span class="c1">//: base(info, context) 不使用基类的原因是基类会报告 找不到 ClassName 和其他很多的坑</span>
        <span class="p">{</span>
            <span class="c1">//反序列化创建</span>

            <span class="n">Message</span> <span class="p">=</span> <span class="p">(</span><span class="kt">string</span><span class="p">)</span> <span class="n">info</span><span class="p">.</span><span class="nf">GetValue</span><span class="p">(</span><span class="n">MessageSerialization</span><span class="p">,</span> <span class="k">typeof</span><span class="p">(</span><span class="kt">string</span><span class="p">));</span>
        <span class="p">}</span> 

        <span class="c1">// 重写消息，用于在构造设置值</span>
        <span class="k">public</span> <span class="k">override</span> <span class="kt">string</span> <span class="n">Message</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="p">}</span>

        <span class="c1">// 用于在构造拿到消息的值</span>
        <span class="k">private</span> <span class="k">const</span> <span class="kt">string</span> <span class="n">MessageSerialization</span> <span class="p">=</span> <span class="s">"Message"</span><span class="p">;</span>

        <span class="c1">// 重写这个方法，在序列化调用</span>
        <span class="k">public</span> <span class="k">override</span> <span class="k">void</span> <span class="nf">GetObjectData</span><span class="p">(</span><span class="n">SerializationInfo</span> <span class="n">info</span><span class="p">,</span> <span class="n">StreamingContext</span> <span class="n">context</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">info</span><span class="p">.</span><span class="nf">AddValue</span><span class="p">(</span><span class="n">MessageSerialization</span><span class="p">,</span> <span class="n">Message</span><span class="p">);</span>
        <span class="p">}</span>
 <span class="p">}</span>
</code></pre></div></div>

<p>在 GetObjectData 拿到必要的属性，这个需要自己把需要的属性写入。然后在构造函数重写<code class="language-plaintext highlighter-rouge">[NotNull] SerializationInfo info, StreamingContext context</code>方法的，可以拿到值</p>

<p>因为上面的代码用到 Message ，需要重写这个属性，因为默认是只读，不能在构造函数设置。</p>

<p>是不是觉得很复杂，实际上简单的方法是通过 json 在GetObjectData把类转换为json，在构造转换为类。</p>

<h2 id="iserializable">ISerializable</h2>

<p>那么为什么在使用 Serializable 特性还需要继承 ISerializable ，因为继承 ISerializable 就可以在一个构造函数<code class="language-plaintext highlighter-rouge">xx([NotNull] SerializationInfo info, StreamingContext context)</code>进行处理和处理如何序列化。处理如何序列化可以提高性能，因为自己知道哪些需要序列化，哪些不需要。</p>

<p>关于 ISerializable 请看 <a href="https://stackoverflow.com/questions/810974/what-is-the-point-of-the-iserializable-interface">c# - What is the point of the ISerializable interface? - Stack Overflow</a></p>

<p><a href="https://msdn.microsoft.com/en-us/library/s9fyb186(v=vs.100).aspx">How to: Create an Exception Type That Can be Thrown by Remote Objects</a></p>

<p><img src="https://i.loli.net/2018/04/08/5ac9ffb44217b.jpg" alt="" /></p>

<p>我的博客即将搬运同步至腾讯云+社区，邀请大家一同入驻：https://cloud.tencent.com/developer/support-plan?invite_code=19bm8i8js1ezb</p>

:ET