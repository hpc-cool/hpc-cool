I"p(<p>小伙伴们都知道有 Tuple 但是很少有小伙伴只有原来从一个类转换为一个 Tuple 的方式如此简洁，在 C# 最新版本里面提供了一组语法糖，可以便捷给任意的类扩展转换为元组的能力</p>

<!--more-->

<!-- CreateTime:3/30/2020 8:21:18 AM -->

<p>先来看看下面这段有趣的代码</p>

<!-- ![](image/C# 里面很少人知道但很好用的 Tuple 转换/C# 里面很少人知道但很好用的 Tuple 转换0.png) -->

<p><img src="http://image.acmx.xyz/lindexi%2F2020330838122221.jpg" alt="" /></p>

<p>我可以将 Lindexi 类解析为 <code class="language-plaintext highlighter-rouge">(string name, string doubi)</code> 的元组，只需要 Lindexi 存在Deconstruct方法，存在这个方法的类不需要继承任何接口，只需要方法名是 Deconstruct 参数全部都是 out 的就可以</p>

<p>如上面例子里面的代码</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="k">class</span> <span class="nc">Lindexi</span>
    <span class="p">{</span>
        <span class="k">public</span> <span class="kt">string</span> <span class="n">Name</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="p">}</span> <span class="p">=</span> <span class="s">"林德熙"</span><span class="p">;</span>
        <span class="k">public</span> <span class="kt">string</span> <span class="n">Doubi</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="p">}</span> <span class="p">=</span> <span class="s">"逗比"</span><span class="p">;</span>

        <span class="k">public</span> <span class="k">void</span> <span class="nf">Deconstruct</span><span class="p">(</span><span class="k">out</span> <span class="kt">string</span> <span class="n">name</span><span class="p">,</span> <span class="k">out</span> <span class="kt">string</span> <span class="n">doubi</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">name</span> <span class="p">=</span> <span class="n">Name</span><span class="p">;</span>
            <span class="n">doubi</span> <span class="p">=</span> <span class="n">Doubi</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
</code></pre></div></div>

<p>存在 Deconstruct 方法将会在编译的时候，通过 Roslyn 语法分析，生成有趣的辅助代码</p>

<p>这段代码我放在 <a href="https://github.com/lindexi/lindexi_gd/tree/6520ba9e38df9aa88821794f0130e03c8bd4a899/BepirquwiKedoucawji">github</a> 欢迎小伙伴访问</p>

<p>这个语法糖在 Roslyn 上是如何用的？其实非常简单，上面代码其实可以分为两句代码做到</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>            <span class="n">lindexi</span><span class="p">.</span><span class="nf">Deconstruct</span><span class="p">(</span><span class="k">out</span> <span class="kt">var</span> <span class="n">v1</span><span class="p">,</span> <span class="k">out</span> <span class="kt">var</span> <span class="n">v2</span><span class="p">);</span>
            <span class="kt">var</span> <span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">doubi</span><span class="p">)</span> <span class="p">=</span> <span class="p">(</span><span class="n">v1</span><span class="p">,</span> <span class="n">v2</span><span class="p">);</span>
</code></pre></div></div>

<p>这里的 v1 和 v2 就是临时用的变量，通过 Roslyn 预编译可以知道这个类 lindexi 存在 Deconstruct 方法，又知道期望的 Tuple 需要几个参数，这样就能做到在将这个有趣的语法转换为原有的代码了</p>

<p>为什么我知道 Roslyn 是如何玩的？原因是看了 IL 代码就知道</p>

<pre><code class="language-IL">    IL_0007: ldloc.0      // lindexi
    IL_0008: ldloca.s     V_3
    IL_000a: ldloca.s     V_4
    IL_000c: callvirt     instance void BepirquwiKedoucawji.Lindexi::Deconstruct(string&amp;, string&amp;)
    IL_0011: nop
    IL_0012: ldloc.3      // V_3
    IL_0013: stloc.1      // name
    IL_0014: ldloc.s      V_4
    IL_0016: stloc.2      // doubi
</code></pre>

<p>刚才也说到只要存在对应的方法就可以，那么扩展方法算不算？其实扩展方法也可以</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="k">class</span> <span class="nc">Lindexi</span>
    <span class="p">{</span>
        <span class="k">public</span> <span class="kt">string</span> <span class="n">Name</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="p">}</span> <span class="p">=</span> <span class="s">"林德熙"</span><span class="p">;</span>
        <span class="k">public</span> <span class="kt">string</span> <span class="n">Doubi</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="p">}</span> <span class="p">=</span> <span class="s">"逗比"</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">static</span> <span class="k">class</span> <span class="nc">Extension</span>
    <span class="p">{</span>
        <span class="k">public</span> <span class="k">static</span> <span class="k">void</span> <span class="nf">Deconstruct</span><span class="p">(</span><span class="k">this</span> <span class="n">Lindexi</span> <span class="n">lindexi</span><span class="p">,</span> <span class="k">out</span> <span class="kt">string</span> <span class="n">name</span><span class="p">,</span> <span class="k">out</span> <span class="kt">string</span> <span class="n">doubi</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">name</span> <span class="p">=</span> <span class="n">lindexi</span><span class="p">.</span><span class="n">Name</span><span class="p">;</span>
            <span class="n">doubi</span> <span class="p">=</span> <span class="n">lindexi</span><span class="p">.</span><span class="n">Doubi</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
</code></pre></div></div>

<p>现在我修改为扩展方法了，也可以看到程序是能跑起来的，因为从 IL 代码上可以看到只有 IL_000c 这句代码更改了调用方法</p>

<pre><code class="language-IL">    IL_0007: ldloc.0      // lindexi
    IL_0008: ldloca.s     V_3
    IL_000a: ldloca.s     V_4
    IL_000c: call         void BepirquwiKedoucawji.Extension::Deconstruct(class BepirquwiKedoucawji.Lindexi, string&amp;, string&amp;)
    IL_0011: nop
    IL_0012: ldloc.3      // V_3
    IL_0013: stloc.1      // name
    IL_0014: ldloc.s      V_4
    IL_0016: stloc.2      // doubi
</code></pre>

<p>上面代码放在 <a href="https://github.com/lindexi/lindexi_gd/tree/a04bb6212b8260dfd916f4a6a01c8dd409f90945/BepirquwiKedoucawji">github</a> 欢迎小伙伴访问</p>

<p>也就是我可以将现有的任何一个类，改造 Tuple 解析，如我可以给一个 <code class="language-plaintext highlighter-rouge">List&lt;int&gt;</code> 解析为将每个元素拼为字符串，同时返回他的元素有多少个请看代码</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="k">static</span> <span class="k">class</span> <span class="nc">Extension</span>
    <span class="p">{</span>
        <span class="k">public</span> <span class="k">static</span> <span class="k">void</span> <span class="nf">Deconstruct</span><span class="p">(</span><span class="k">this</span> <span class="n">List</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">&gt;</span> <span class="n">list</span><span class="p">,</span> <span class="k">out</span> <span class="kt">string</span> <span class="n">name</span><span class="p">,</span> <span class="k">out</span> <span class="kt">int</span> <span class="n">count</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">name</span> <span class="p">=</span> <span class="kt">string</span><span class="p">.</span><span class="nf">Join</span><span class="p">(</span><span class="s">","</span><span class="p">,</span> <span class="n">list</span><span class="p">);</span>
            <span class="n">count</span> <span class="p">=</span> <span class="n">list</span><span class="p">.</span><span class="n">Count</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
</code></pre></div></div>

<p>添加上面代码就可以愉快写出小伙伴很难看懂的代码</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        <span class="k">static</span> <span class="k">void</span> <span class="nf">Main</span><span class="p">(</span><span class="kt">string</span><span class="p">[]</span> <span class="n">args</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="kt">var</span> <span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">count</span><span class="p">)</span> <span class="p">=</span> <span class="k">new</span> <span class="n">List</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">&gt;()</span> <span class="p">{</span> <span class="m">1</span><span class="p">,</span> <span class="m">2</span><span class="p">,</span> <span class="m">3</span> <span class="p">};</span>
            <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="s">$"</span><span class="p">{</span><span class="n">name</span><span class="p">}</span><span class="s"> </span><span class="p">{</span><span class="n">count</span><span class="p">}</span><span class="s">"</span><span class="p">);</span>
        <span class="p">}</span>
</code></pre></div></div>

<p>上面代码放在 <a href="https://github.com/lindexi/lindexi_gd/tree/be040e9621357efd61d02b3469911e336fd3e40a/BepirquwiKedoucawji">github</a> 欢迎小伙伴访问</p>

<p><a href="https://docs.microsoft.com/en-us/dotnet/csharp/deconstruct">Deconstructing tuples and other types</a></p>

:ET