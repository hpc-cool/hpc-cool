I"<p>将对象的状态信息转换为可以存储或传输的形式的过程。在序列化期间，对象将其当前状态写入到临时或持久性存储区。以后，可以通过从存储区中读取或反序列化对象的状态，重新创建该对象。</p>

<!--more-->

<!-- CreateTime:2018/8/10 19:16:50 -->

<div id="toc"></div>

<p>.NET Framework 提供了两个序列化技术：</p>

<ul>
  <li>
    <p>二进制序列化保持类型保真，这对于多次调用应用程序时保持对象状态非常有用。例如，通过将对象序列化到剪贴板，可在不同的应用程序之间共享对象。您可以将对象序列化到流、磁盘、内存和网络等。远程处理使用序列化，“按值”在计算机或应用程序域之间传递对象。</p>
  </li>
  <li>
    <p>XML 序列化只序列化公共属性和字段，并且不保持类型保真。当您希望提供或使用数据而不限制使用该数据的应用程序时，这一点非常有用。</p>
  </li>
</ul>

<h2 id="binary">Binary</h2>

<p>首先需要定义一个类，这个类作为保存的类，需要使用特性 Serializable</p>

<p><img src="http://image.acmx.xyz/AwCCAwMAItoFADbzBgABAAQArj4BAGZDAgBo6AkA6Nk%3D%2F2017420192248.jpg" alt="" /></p>

<p>然后使用 <code class="language-plaintext highlighter-rouge">binaryFormatter</code> 他可以写入流</p>

<p>创建一个文件夹，返回和People类，就可以把他保存在本地</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>             <span class="n">BinaryFormatter</span> <span class="n">binaryFormatter</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">BinaryFormatter</span><span class="p">();</span>
            <span class="n">FileStream</span> <span class="n">stream</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">FileStream</span><span class="p">(</span><span class="s">"./file"</span><span class="p">,</span> <span class="n">FileMode</span><span class="p">.</span><span class="n">Create</span><span class="p">);</span>
            <span class="n">binaryFormatter</span><span class="p">.</span><span class="nf">Serialize</span><span class="p">(</span><span class="n">stream</span><span class="p">,</span> <span class="n">people</span><span class="p">);</span>
</code></pre></div></div>

<p>这就是序列化，如果需要从保存的文件拿出来，可以参见下面代码：</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>             <span class="k">using</span> <span class="p">(</span><span class="n">FileStream</span> <span class="n">stream</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">FileStream</span><span class="p">(</span><span class="s">"./file"</span><span class="p">,</span> <span class="n">FileMode</span><span class="p">.</span><span class="n">Open</span><span class="p">))</span>
            <span class="p">{</span>
                <span class="n">people</span> <span class="p">=</span> <span class="p">(</span><span class="n">People</span><span class="p">)</span> <span class="n">binaryFormatter</span><span class="p">.</span><span class="nf">Deserialize</span><span class="p">(</span><span class="n">stream</span><span class="p">);</span>
                <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="n">people</span><span class="p">.</span><span class="n">Name</span><span class="p">);</span>
            <span class="p">}</span>
</code></pre></div></div>

<p>可以看到代码都是使用命令行不是使用通用程序</p>

<h2 id="xml序列化">XML序列化</h2>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>               <span class="n">XmlSerializer</span> <span class="n">xmlSerializer</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">XmlSerializer</span><span class="p">(</span><span class="k">typeof</span><span class="p">(</span><span class="n">People</span><span class="p">));</span>

            <span class="k">using</span> <span class="p">(</span><span class="n">FileStream</span> <span class="n">stream</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">FileStream</span><span class="p">(</span><span class="s">"./file"</span><span class="p">,</span> <span class="n">FileMode</span><span class="p">.</span><span class="n">Create</span><span class="p">))</span>
            <span class="p">{</span>
                <span class="n">xmlSerializer</span><span class="p">.</span><span class="nf">Serialize</span><span class="p">(</span><span class="n">stream</span><span class="p">,</span> <span class="n">people</span><span class="p">);</span>
            <span class="p">}</span>

            <span class="k">using</span> <span class="p">(</span><span class="n">FileStream</span> <span class="n">stream</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">FileStream</span><span class="p">(</span><span class="s">"./file"</span><span class="p">,</span> <span class="n">FileMode</span><span class="p">.</span><span class="n">Open</span><span class="p">))</span>
            <span class="p">{</span>
                <span class="n">people</span> <span class="p">=</span> <span class="p">(</span><span class="n">People</span><span class="p">)</span><span class="n">xmlSerializer</span><span class="p">.</span><span class="nf">Deserialize</span><span class="p">(</span><span class="n">stream</span><span class="p">);</span>
                <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="n">people</span><span class="p">);</span>
            <span class="p">}</span>
</code></pre></div></div>

<p>如果有一些属性需要不显示，也就是不放在文件，可以参见：<a href="https://msdn.microsoft.com/zh-cn/library/83y7df3e(v=vs.90).aspx">https://msdn.microsoft.com/zh-cn/library/83y7df3e(v=vs.90).aspx</a></p>

<p>XmlSerializer 创建 C# 文件并将其编译为 .dll 文件，以执行此序列化。
为了提高性能，XML 序列化基础结构动态生成程序集，以便对指定类型进行序列化和反序列化。该基础结构将找到并重新使用这些程序集。仅当使用以下构造函数时，才会发生此行为：</p>

<p>XmlSerializer.XmlSerializer(Type)</p>

<p>XmlSerializer.XmlSerializer(Type, String)</p>

<p>如果使用任何其他构造函数，则将生成同一个程序集的多个版本，这些版本始终不予卸载</p>

<p>Yaml序列化</p>

<p>首先搜索 YamlDotNet ，安装</p>

<p><img src="http://image.acmx.xyz/AwCCAwMAItoFADbzBgABAAQArj4BAGZDAgBo6AkA6Nk%3D%2F201742019318.jpg" alt="" /></p>

<p>这里使用参见 http://www.cnblogs.com/RicCC/archive/2010/03/01/serialization-data-format.html</p>

<p>参见：</p>

<p><a href="https://blog.lindexi.com/post/win10-uwp-json.html">win10 uwp json</a></p>

<p><a href="https://blog.lindexi.com/post/win10-uwp-%E8%AF%BB%E5%86%99XML.html">win10 uwp 读写XML</a></p>

:ET