I"״<p>在 WPF 触摸应用中，插入触摸设备，即可在应用里面使用上插入的触摸设备。在 WPF 使用触摸设备的触摸时，需要获取到触摸设备的信息，才能实现触摸</p>

<!--more-->

<!-- CreateTime:2021/5/24 18:58:18 -->

<!-- 标签：WPF，WPF源代码 -->
<!-- 发布 -->

<h2 id="获取触摸设备插入">获取触摸设备插入</h2>

<p>在 WPF 中，通过 Windows 消息获取触摸设备插入事件，在 <code class="language-plaintext highlighter-rouge">src\Microsoft.DotNet.Wpf\src\PresentationCore\System\Windows\Input\Stylus\Wisp\WispLogic.cs</code> 的 HandleMessage 将获取 Windows 消息，代码如下</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        <span class="k">internal</span> <span class="k">override</span> <span class="k">void</span> <span class="nf">HandleMessage</span><span class="p">(</span><span class="n">WindowMessage</span> <span class="n">msg</span><span class="p">,</span> <span class="n">IntPtr</span> <span class="n">wParam</span><span class="p">,</span> <span class="n">IntPtr</span> <span class="n">lParam</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">switch</span> <span class="p">(</span><span class="n">msg</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="c1">// 忽略代码</span>
                <span class="k">case</span> <span class="n">WindowMessage</span><span class="p">.</span><span class="n">WM_TABLET_ADDED</span><span class="p">:</span>
                    <span class="nf">OnTabletAdded</span><span class="p">((</span><span class="kt">uint</span><span class="p">)</span><span class="n">NativeMethods</span><span class="p">.</span><span class="nf">IntPtrToInt32</span><span class="p">(</span><span class="n">wParam</span><span class="p">));</span>
                    <span class="k">break</span><span class="p">;</span>

                <span class="k">case</span> <span class="n">WindowMessage</span><span class="p">.</span><span class="n">WM_TABLET_DELETED</span><span class="p">:</span>
                    <span class="nf">OnTabletRemovedImpl</span><span class="p">((</span><span class="kt">uint</span><span class="p">)</span><span class="n">NativeMethods</span><span class="p">.</span><span class="nf">IntPtrToInt32</span><span class="p">(</span><span class="n">wParam</span><span class="p">),</span> <span class="n">isInternalCall</span><span class="p">:</span> <span class="k">true</span><span class="p">);</span>
                    <span class="k">break</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
</code></pre></div></div>

<p>在 WPF 框架，使用 <a href="https://docs.microsoft.com/en-us/windows/win32/tablet/wm-tablet-added?WT.mc_id=WD-MVP-5003260">WM_TABLET_ADDED</a> 和 <a href="https://docs.microsoft.com/en-us/windows/win32/tablet/wm-tablet-deleted?WT.mc_id=WD-MVP-5003260">WM_TABLET_DELETED</a> 消息获取设备的插入和删除事件</p>

<p>如上面代码，在设备插入时，将会调用 OnTabletAdded 方法。如 <a href="https://docs.microsoft.com/en-us/windows/win32/tablet/wm-tablet-added?WT.mc_id=WD-MVP-5003260">WM_TABLET_ADDED 官方文档</a>描述，以上代码获取的参数是 Wisptis 的 Index 序号。这是因为用户可以插入多个触摸设备，通过传入序号可以拿到插入的设备</p>

<p>在 WPF 中，每次插入触摸设备，都会重新更新所有的触摸设备的信息，而不是只更新插入的设备。在 OnTabletAdded 方法里面，将会调用 GetDeviceCount 方法，在 GetDeviceCount 方法里面将通过 PenThread 的 WorkerGetTabletsInfo 更新所有触摸设备的信息，代码如下</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        <span class="k">private</span> <span class="k">void</span> <span class="nf">OnTabletAdded</span><span class="p">(</span><span class="kt">uint</span> <span class="n">wisptisIndex</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">lock</span> <span class="p">(</span><span class="n">__penContextsLock</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="n">WispTabletDeviceCollection</span> <span class="n">tabletDeviceCollection</span> <span class="p">=</span> <span class="n">WispTabletDevices</span><span class="p">;</span>
                <span class="c1">// 忽略代码</span>

                <span class="c1">// Update the last known device count.</span>
                <span class="n">_lastKnownDeviceCount</span> <span class="p">=</span> <span class="nf">GetDeviceCount</span><span class="p">();</span>

                <span class="kt">uint</span> <span class="n">tabletIndex</span> <span class="p">=</span> <span class="n">UInt32</span><span class="p">.</span><span class="n">MaxValue</span><span class="p">;</span>
                <span class="c1">// HandleTabletAdded returns true if we need to update contexts due to a change in tablet devices.</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">tabletDeviceCollection</span><span class="p">.</span><span class="nf">HandleTabletAdded</span><span class="p">(</span><span class="n">wisptisIndex</span><span class="p">,</span> <span class="k">ref</span> <span class="n">tabletIndex</span><span class="p">))</span>
                <span class="p">{</span>
                        <span class="c1">// Update all contexts with this new tablet device.</span>
                        <span class="k">foreach</span> <span class="p">(</span><span class="n">PenContexts</span> <span class="n">contexts</span> <span class="k">in</span> <span class="n">__penContextsMap</span><span class="p">.</span><span class="n">Values</span><span class="p">)</span>
                        <span class="p">{</span>
                            <span class="n">contexts</span><span class="p">.</span><span class="nf">AddContext</span><span class="p">(</span><span class="n">tabletIndex</span><span class="p">);</span>
                        <span class="p">}</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="k">private</span> <span class="kt">int</span> <span class="nf">GetDeviceCount</span><span class="p">()</span>
        <span class="p">{</span>
            <span class="n">PenThread</span> <span class="n">penThread</span> <span class="p">=</span> <span class="k">null</span><span class="p">;</span>

            <span class="c1">// Get a PenThread by mimicking a subset of the code in TabletDeviceCollection.UpdateTablets().</span>
            <span class="n">TabletDeviceCollection</span> <span class="n">tabletDeviceCollection</span> <span class="p">=</span> <span class="n">TabletDevices</span><span class="p">;</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">tabletDeviceCollection</span> <span class="p">!=</span> <span class="k">null</span> <span class="p">&amp;&amp;</span> <span class="n">tabletDeviceCollection</span><span class="p">.</span><span class="n">Count</span> <span class="p">&gt;</span> <span class="m">0</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="n">penThread</span> <span class="p">=</span> <span class="n">tabletDeviceCollection</span><span class="p">[</span><span class="m">0</span><span class="p">].</span><span class="n">As</span><span class="p">&lt;</span><span class="n">WispTabletDevice</span><span class="p">&gt;().</span><span class="n">PenThread</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="k">if</span> <span class="p">(</span><span class="n">penThread</span> <span class="p">!=</span> <span class="k">null</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="c1">// Use the PenThread to get the full, unfiltered tablets info to see how many there are.</span>
                <span class="n">TabletDeviceInfo</span><span class="p">[]</span> <span class="n">tabletdevices</span> <span class="p">=</span> <span class="n">penThread</span><span class="p">.</span><span class="nf">WorkerGetTabletsInfo</span><span class="p">();</span>
                <span class="k">return</span> <span class="n">tabletdevices</span><span class="p">.</span><span class="n">Length</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="k">else</span>
            <span class="p">{</span>
                <span class="c1">// if there's no PenThread yet, return "unknown"</span>
                <span class="k">return</span> <span class="p">-</span><span class="m">1</span><span class="p">;</span>
            <span class="p">}</span>
<span class="p">}</span> <span class="c1">// WPF 代码格式化就是这样</span>
</code></pre></div></div>

<p>以上代码调用 WorkerGetTabletsInfo 方法实际的获取触摸信息逻辑是放在触摸线程，上面代码需要先获取触摸线程 PenThread 然后调用触摸线程类的 WorkerGetTabletsInfo 方法，在这个方法里面执行逻辑</p>

<h2 id="触摸线程">触摸线程</h2>

<p>在 <a href="https://blog.lindexi.com/post/WPF-%E8%A7%A6%E6%91%B8%E5%88%B0%E4%BA%8B%E4%BB%B6.html">WPF 触摸到事件</a> 博客里面告诉大家，在 WPF 框架，为了让触摸的性能足够强，将触摸的获取放在独立的进程里面</p>

<p>在获取触摸信息时，也需要调度到触摸线程执行。在 WPF 中，通过 PenThread 类的相关方法可以调度到触摸线程</p>

<p>在调用 WorkerGetTabletsInfo 方法时，进入 WorkerGetTabletsInfo 方法依然是主线程，里面代码如下</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        <span class="k">internal</span> <span class="n">TabletDeviceInfo</span><span class="p">[]</span> <span class="nf">WorkerGetTabletsInfo</span><span class="p">()</span>
        <span class="p">{</span>
            <span class="c1">// Set data up for this call</span>
            <span class="n">WorkerOperationGetTabletsInfo</span> <span class="n">getTablets</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">WorkerOperationGetTabletsInfo</span><span class="p">();</span>
            
            <span class="k">lock</span><span class="p">(</span><span class="n">_workerOperationLock</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="n">_workerOperation</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="n">getTablets</span><span class="p">);</span>
            <span class="p">}</span>

            <span class="c1">// Kick thread to do this work.</span>
            <span class="n">MS</span><span class="p">.</span><span class="n">Win32</span><span class="p">.</span><span class="n">Penimc</span><span class="p">.</span><span class="n">UnsafeNativeMethods</span><span class="p">.</span><span class="nf">RaiseResetEvent</span><span class="p">(</span><span class="n">_pimcResetHandle</span><span class="p">.</span><span class="n">Value</span><span class="p">);</span>

            <span class="c1">// Wait for this work to be completed.</span>
            <span class="n">getTablets</span><span class="p">.</span><span class="n">DoneEvent</span><span class="p">.</span><span class="nf">WaitOne</span><span class="p">();</span>
            <span class="n">getTablets</span><span class="p">.</span><span class="n">DoneEvent</span><span class="p">.</span><span class="nf">Close</span><span class="p">();</span>
        
            <span class="k">return</span> <span class="n">getTablets</span><span class="p">.</span><span class="n">TabletDevicesInfo</span><span class="p">;</span>
        <span class="p">}</span>
</code></pre></div></div>

<p>实际上以上代码是放在 PenThreadWorker.cs 文件中，在 WPF 的触摸线程设计上，触摸线程是一个循环，将会等待 PenImc 层发送触摸消息，或者等待 <code class="language-plaintext highlighter-rouge">_pimcResetHandle</code> 锁被释放。如上面代码，先插入 WorkerOperationGetTabletsInfo 到 <code class="language-plaintext highlighter-rouge">_workerOperation</code> 列表中，然后调用 RaiseResetEvent 方法释放 <code class="language-plaintext highlighter-rouge">_pimcResetHandle</code> 对象。触摸线程将会因为 <code class="language-plaintext highlighter-rouge">_pimcResetHandle</code> 被释放而跳出循环，然后获取 <code class="language-plaintext highlighter-rouge">_workerOperation</code> 列表里面的项，进行执行逻辑</p>

<p>主线程将会在 <code class="language-plaintext highlighter-rouge">getTablets.DoneEvent.WaitOne</code> 方法里面进入锁，等待触摸线程执行 WorkerOperationGetTabletsInfo 完成之后释放这个锁，才能让主线程继续执行</p>

<p>触摸线程的循环逻辑代码大概如下</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        <span class="k">internal</span> <span class="k">void</span> <span class="nf">ThreadProc</span><span class="p">()</span>
        <span class="p">{</span>
            <span class="n">Thread</span><span class="p">.</span><span class="n">CurrentThread</span><span class="p">.</span><span class="n">Name</span> <span class="p">=</span> <span class="s">"Stylus Input"</span><span class="p">;</span>
            <span class="k">while</span> <span class="p">(!</span><span class="n">__disposed</span><span class="p">)</span>
            <span class="p">{</span>
                    <span class="c1">// 忽略代码</span>
                    <span class="n">WorkerOperation</span><span class="p">[]</span> <span class="n">workerOps</span> <span class="p">=</span> <span class="k">null</span><span class="p">;</span>

                    <span class="k">lock</span><span class="p">(</span><span class="n">_workerOperationLock</span><span class="p">)</span>
                    <span class="p">{</span>
                        <span class="k">if</span> <span class="p">(</span><span class="n">_workerOperation</span><span class="p">.</span><span class="n">Count</span> <span class="p">&gt;</span> <span class="m">0</span><span class="p">)</span>
                        <span class="p">{</span>
                            <span class="n">workerOps</span> <span class="p">=</span> <span class="n">_workerOperation</span><span class="p">.</span><span class="nf">ToArray</span><span class="p">();</span>
                            <span class="n">_workerOperation</span><span class="p">.</span><span class="nf">Clear</span><span class="p">();</span>
                        <span class="p">}</span>
                    <span class="p">}</span>

                    <span class="k">if</span> <span class="p">(</span><span class="n">workerOps</span> <span class="p">!=</span> <span class="k">null</span><span class="p">)</span>
                    <span class="p">{</span>
                        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span><span class="p">=</span><span class="m">0</span><span class="p">;</span> <span class="n">j</span><span class="p">&lt;</span><span class="n">workerOps</span><span class="p">.</span><span class="n">Length</span><span class="p">;</span> <span class="n">j</span><span class="p">++)</span>
                        <span class="p">{</span>
                            <span class="n">workerOps</span><span class="p">[</span><span class="n">j</span><span class="p">].</span><span class="nf">DoWork</span><span class="p">();</span>
                        <span class="p">}</span>
                        <span class="n">workerOps</span> <span class="p">=</span> <span class="k">null</span><span class="p">;</span>
                    <span class="p">}</span>

                    <span class="c1">// 这是第二层循环</span>
                    <span class="k">while</span> <span class="p">(</span><span class="k">true</span><span class="p">)</span>
                    <span class="p">{</span>
                            <span class="c1">// 忽略代码</span>

                    	    <span class="k">if</span> <span class="p">(!</span><span class="n">MS</span><span class="p">.</span><span class="n">Win32</span><span class="p">.</span><span class="n">Penimc</span><span class="p">.</span><span class="n">UnsafeNativeMethods</span><span class="p">.</span><span class="nf">GetPenEvent</span><span class="p">(</span>
                                <span class="n">_handles</span><span class="p">[</span><span class="m">0</span><span class="p">],</span> <span class="n">_pimcResetHandle</span><span class="p">.</span><span class="n">Value</span><span class="p">,</span>
                                <span class="k">out</span> <span class="n">evt</span><span class="p">,</span> <span class="k">out</span> <span class="n">stylusPointerId</span><span class="p">,</span>
                                <span class="k">out</span> <span class="n">cPackets</span><span class="p">,</span> <span class="k">out</span> <span class="n">cbPacket</span><span class="p">,</span> <span class="k">out</span> <span class="n">pPackets</span><span class="p">))</span>
                            <span class="p">{</span>
                                <span class="k">break</span><span class="p">;</span>
                            <span class="p">}</span>
                    <span class="p">}</span>
            <span class="p">}</span>
</code></pre></div></div>

<p>默认 WPF 的触摸线程都会在第二层循环，在 GetPenEvent 方法里面等待 PenImc 发送触摸消息或等待 <code class="language-plaintext highlighter-rouge">_pimcResetHandle</code> 释放。在跳出第二层循环，将会去获取 <code class="language-plaintext highlighter-rouge">_workerOperation</code> 的项，然后执行</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>                    <span class="n">WorkerOperation</span><span class="p">[]</span> <span class="n">workerOps</span> <span class="p">=</span> <span class="k">null</span><span class="p">;</span>

                    <span class="k">lock</span><span class="p">(</span><span class="n">_workerOperationLock</span><span class="p">)</span>
                    <span class="p">{</span>
                        <span class="k">if</span> <span class="p">(</span><span class="n">_workerOperation</span><span class="p">.</span><span class="n">Count</span> <span class="p">&gt;</span> <span class="m">0</span><span class="p">)</span>
                        <span class="p">{</span>
                            <span class="n">workerOps</span> <span class="p">=</span> <span class="n">_workerOperation</span><span class="p">.</span><span class="nf">ToArray</span><span class="p">();</span>
                            <span class="n">_workerOperation</span><span class="p">.</span><span class="nf">Clear</span><span class="p">();</span>
                        <span class="p">}</span>
                    <span class="p">}</span>

                    <span class="k">if</span> <span class="p">(</span><span class="n">workerOps</span> <span class="p">!=</span> <span class="k">null</span><span class="p">)</span>
                    <span class="p">{</span>
                        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span><span class="p">=</span><span class="m">0</span><span class="p">;</span> <span class="n">j</span><span class="p">&lt;</span><span class="n">workerOps</span><span class="p">.</span><span class="n">Length</span><span class="p">;</span> <span class="n">j</span><span class="p">++)</span>
                        <span class="p">{</span>
                            <span class="n">workerOps</span><span class="p">[</span><span class="n">j</span><span class="p">].</span><span class="nf">DoWork</span><span class="p">();</span>
                        <span class="p">}</span>
                        <span class="n">workerOps</span> <span class="p">=</span> <span class="k">null</span><span class="p">;</span>
                    <span class="p">}</span>
</code></pre></div></div>

<h2 id="获取触摸信息">获取触摸信息</h2>

<p>在调用 WorkerOperationGetTabletsInfo 的 DoWork 方法时，将会在触摸线程获取触摸设备信息</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        <span class="k">private</span> <span class="k">class</span> <span class="nc">WorkerOperationGetTabletsInfo</span> <span class="p">:</span> <span class="n">WorkerOperation</span>
        <span class="p">{</span>
            <span class="k">internal</span> <span class="n">TabletDeviceInfo</span><span class="p">[]</span> <span class="n">TabletDevicesInfo</span>
            <span class="p">{</span>
                <span class="k">get</span> <span class="p">{</span> <span class="k">return</span> <span class="n">_tabletDevicesInfo</span><span class="p">;}</span>
            <span class="p">}</span>

            <span class="c1">/////////////////////////////////////////////////////////////////////////</span>
            <span class="c1">/// &lt;summary&gt;</span>
            <span class="c1">///     Returns the list of TabletDeviceInfo structs that contain information</span>
            <span class="c1">///     about all of the TabletDevices on the system.</span>
            <span class="c1">/// &lt;/summary&gt;</span>
            <span class="k">protected</span> <span class="k">override</span> <span class="k">void</span> <span class="nf">OnDoWork</span><span class="p">()</span>
            <span class="p">{</span>
                <span class="k">try</span>
                <span class="p">{</span>
                    <span class="c1">// create new collection of tablets</span>
                    <span class="n">MS</span><span class="p">.</span><span class="n">Win32</span><span class="p">.</span><span class="n">Penimc</span><span class="p">.</span><span class="n">IPimcManager3</span> <span class="n">pimcManager</span> <span class="p">=</span> <span class="n">MS</span><span class="p">.</span><span class="n">Win32</span><span class="p">.</span><span class="n">Penimc</span><span class="p">.</span><span class="n">UnsafeNativeMethods</span><span class="p">.</span><span class="n">PimcManager</span><span class="p">;</span>
                    <span class="kt">uint</span> <span class="n">cTablets</span><span class="p">;</span>
                    <span class="n">pimcManager</span><span class="p">.</span><span class="nf">GetTabletCount</span><span class="p">(</span><span class="k">out</span> <span class="n">cTablets</span><span class="p">);</span>

                    <span class="n">TabletDeviceInfo</span><span class="p">[]</span> <span class="n">tablets</span> <span class="p">=</span> <span class="k">new</span> <span class="n">TabletDeviceInfo</span><span class="p">[</span><span class="n">cTablets</span><span class="p">];</span>

                    <span class="k">for</span> <span class="p">(</span> <span class="kt">uint</span> <span class="n">iTablet</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">iTablet</span> <span class="p">&lt;</span> <span class="n">cTablets</span><span class="p">;</span> <span class="n">iTablet</span><span class="p">++</span> <span class="p">)</span>
                    <span class="p">{</span>
                        <span class="n">MS</span><span class="p">.</span><span class="n">Win32</span><span class="p">.</span><span class="n">Penimc</span><span class="p">.</span><span class="n">IPimcTablet3</span> <span class="n">pimcTablet</span><span class="p">;</span>
                        <span class="n">pimcManager</span><span class="p">.</span><span class="nf">GetTablet</span><span class="p">(</span><span class="n">iTablet</span><span class="p">,</span> <span class="k">out</span> <span class="n">pimcTablet</span><span class="p">);</span>

                        <span class="n">tablets</span><span class="p">[</span><span class="n">iTablet</span><span class="p">]</span> <span class="p">=</span> <span class="n">PenThreadWorker</span><span class="p">.</span><span class="nf">GetTabletInfoHelper</span><span class="p">(</span><span class="n">pimcTablet</span><span class="p">);</span>
                    <span class="p">}</span>

                    <span class="c1">// Set result data and signal we are done.</span>
                    <span class="n">_tabletDevicesInfo</span> <span class="p">=</span> <span class="n">tablets</span><span class="p">;</span>
                <span class="p">}</span>
                <span class="k">catch</span> <span class="p">(</span><span class="n">Exception</span> <span class="n">e</span><span class="p">)</span> <span class="nf">when</span> <span class="p">(</span><span class="n">PenThreadWorker</span><span class="p">.</span><span class="nf">IsKnownException</span><span class="p">(</span><span class="n">e</span><span class="p">))</span>
                <span class="p">{</span>
                    <span class="n">Debug</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="s">"WorkerOperationGetTabletsInfo.OnDoWork failed due to: {0}{1}"</span><span class="p">,</span> <span class="n">Environment</span><span class="p">.</span><span class="n">NewLine</span><span class="p">,</span> <span class="n">e</span><span class="p">.</span><span class="nf">ToString</span><span class="p">());</span>
                <span class="p">}</span>
            <span class="p">}</span>

            <span class="n">TabletDeviceInfo</span><span class="p">[]</span> <span class="n">_tabletDevicesInfo</span> <span class="p">=</span> <span class="n">Array</span><span class="p">.</span><span class="n">Empty</span><span class="p">&lt;</span><span class="n">TabletDeviceInfo</span><span class="p">&gt;();</span>
        <span class="p">}</span>
</code></pre></div></div>

<p>上面代码的 IPimcManager3 接口是一个 COM 接口，实际逻辑是在 PenImc 层进行定义，在 PenImcRcw.cs 引用，代码如下</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="p">[</span>
    <span class="n">ComImport</span><span class="p">,</span>
    <span class="nf">Guid</span><span class="p">(</span><span class="n">PimcConstants</span><span class="p">.</span><span class="n">IPimcManager3IID</span><span class="p">),</span>
    <span class="nf">InterfaceType</span><span class="p">(</span><span class="n">ComInterfaceType</span><span class="p">.</span><span class="n">InterfaceIsIUnknown</span><span class="p">)</span>
    <span class="p">]</span>
    <span class="k">interface</span> <span class="nc">IPimcManager3</span>
    <span class="p">{</span>
        <span class="k">void</span> <span class="nf">GetTabletCount</span><span class="p">(</span><span class="k">out</span> <span class="n">UInt32</span> <span class="n">count</span><span class="p">);</span>
        <span class="k">void</span> <span class="nf">GetTablet</span><span class="p">(</span><span class="n">UInt32</span> <span class="n">tablet</span><span class="p">,</span> <span class="k">out</span> <span class="n">IPimcTablet3</span> <span class="n">IPimcTablet</span><span class="p">);</span>
    <span class="p">}</span>
</code></pre></div></div>

<p>在 PenImc 层的 PenImc.idl 文件里面，定义了公开的接口</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">[</span>
	<span class="kt">object</span><span class="p">,</span>
	<span class="nf">uuid</span><span class="p">(</span><span class="n">BD2C38C2</span><span class="p">-</span><span class="n">E064</span><span class="p">-</span><span class="m">41D0</span><span class="p">-</span><span class="n">A999</span><span class="p">-</span><span class="m">940F526219</span><span class="n">C2</span><span class="p">),</span>
	<span class="n">nonextensible</span><span class="p">,</span>
	<span class="nf">helpstring</span><span class="p">(</span><span class="s">"IPimcManager3 Interface"</span><span class="p">),</span>
	<span class="nf">pointer_default</span><span class="p">(</span><span class="n">unique</span><span class="p">)</span>
<span class="p">]</span>
<span class="k">interface</span> <span class="nc">IPimcManager3</span> <span class="p">:</span> <span class="n">IUnknown</span> <span class="p">{</span>
    <span class="p">[</span><span class="nf">helpstring</span><span class="p">(</span><span class="s">"method GetTabletCount"</span><span class="p">)]</span> <span class="n">HRESULT</span> <span class="nf">GetTabletCount</span><span class="p">([</span><span class="k">out</span><span class="p">]</span> <span class="n">ULONG</span><span class="p">*</span> <span class="n">pcTablets</span><span class="p">);</span>
    <span class="p">[</span><span class="nf">helpstring</span><span class="p">(</span><span class="s">"method GetTablet"</span><span class="p">)</span>     <span class="p">]</span> <span class="n">HRESULT</span> <span class="nf">GetTablet</span><span class="p">([</span><span class="k">in</span><span class="p">]</span> <span class="n">ULONG</span> <span class="n">iTablet</span><span class="p">,</span> <span class="p">[</span><span class="k">out</span><span class="p">]</span> <span class="n">IPimcTablet3</span><span class="p">**</span> <span class="n">ppTablet</span><span class="p">);</span>
<span class="p">};</span>
</code></pre></div></div>

<p>在 WPF 中，在 C# 代码使用的不是最底层的方法，也就是 <code class="language-plaintext highlighter-rouge">BD2C38C2-E064-41D0-A999-940F526219C2</code> 组件只是 WPF 用的，而不是系统等给的接口</p>

<p>实际调用底层的代码是在 PenImc 层的 C++ 代码，但 PenImc 层的 C++ 代码只是一层转发调用而已，换句话说，如果使用 C# 调用底层的系统的组件也是完全可以的</p>

<p>如上面代码通过 GetTabletCount 方法获取当前的触摸设备，此方法是通过 COM 调用到在 PenImc.idl 文件定义的 GetTabletCount 获取的，实际定义的代码是 PimcManager.cpp 文件的 GetTabletCount 方法</p>

<pre><code class="language-C++">STDMETHODIMP CPimcManager::GetTabletCount(__out ULONG* pcTablets)
{
    DHR;

    ULONG cTablets = 0;

    LoadWisptis(); // Try to load wisptis via the surrogate object.
    
    // we will return 0 in the case that there is no stylus since mouse is not considered a stylus anymore
    if (m_fLoadedWisptis)
    {
        CHR(m_pMgrS-&gt;GetTabletCount(&amp;cTablets));
    }
    
    *pcTablets = cTablets;
    
CLEANUP:
    RHR;
}
</code></pre>

<p>以上代码里面用到了一些宏，如 <code class="language-plaintext highlighter-rouge">DHR</code> 的含义是定义 HRESULT 变量，代码如下</p>

<pre><code class="language-C++">#define DHR                                         \
    HRESULT hr = S_OK;
</code></pre>

<p>而 <code class="language-plaintext highlighter-rouge">CHR</code> 表示的是判断 HRESULT 的值，如果失败了，将会调用 <code class="language-plaintext highlighter-rouge">CLEANUP</code> 标签的内容。在 <code class="language-plaintext highlighter-rouge">CHR</code> 里面用到 goto 的方法</p>

<pre><code class="language-C++">#define CHR(hr_op)                                  \
    {                                               \
        hr = hr_op;                                 \
        if (FAILED(hr))                             \
            goto CLEANUP;                           \
    }
</code></pre>

<p>上面代码的 <code class="language-plaintext highlighter-rouge">RHR</code> 表示的是返回 HRESULT 变量</p>

<pre><code class="language-C++">#define RHR                                         \
    return hr;
</code></pre>

<p>因此以上代码实际就是如下代码</p>

<pre><code class="language-C++">STDMETHODIMP CPimcManager::GetTabletCount(__out ULONG* pcTablets)
{
    HRESULT hr = S_OK;

    ULONG cTablets = 0;

    LoadWisptis(); // Try to load wisptis via the surrogate object.
    
    // we will return 0 in the case that there is no stylus since mouse is not considered a stylus anymore
    if (m_fLoadedWisptis)
    {
        hr = m_pMgrS-&gt;GetTabletCount(&amp;cTablets);
        if (FAILED(hr))
        {
            goto CLEANUP;
        }
    }
    
    *pcTablets = cTablets;
    
CLEANUP:
    return hr;
}
</code></pre>

<p>通过上面代码可以看到，实际调用的是 <code class="language-plaintext highlighter-rouge">m_pMgrS</code> 的 GetTabletCount 方法，也就是如下代码定义的方法</p>

<pre><code class="language-C++">    MIDL_INTERFACE("764DE8AA-1867-47C1-8F6A-122445ABD89A")
    ITabletManager : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetDefaultTablet( 
            /* [out] */ __RPC__deref_out_opt ITablet **ppTablet) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetTabletCount( 
            /* [out] */ __RPC__out ULONG *pcTablets) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetTablet( 
            /* [in] */ ULONG iTablet,
            /* [out] */ __RPC__deref_out_opt ITablet **ppTablet) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetTabletContextById( 
            /* [in] */ TABLET_CONTEXT_ID tcid,
            /* [out] */ __RPC__deref_out_opt ITabletContext **ppContext) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetCursorById( 
            /* [in] */ CURSOR_ID cid,
            /* [out] */ __RPC__deref_out_opt ITabletCursor **ppCursor) = 0;
        
    };
</code></pre>

<p>可以看到这是一个 COM 接口调用，实际使用的就是系统提供的 <a href="https://docs.microsoft.com/en-us/windows/win32/tablet/itabletmanager?WT.mc_id=WD-MVP-5003260">ITabletManager</a> 组件</p>

<p>在底层系统组件，先调用 <a href="https://docs.microsoft.com/en-us/windows/win32/tablet/itabletmanager-gettabletcount?WT.mc_id=WD-MVP-5003260">ITabletManager 的 GetTabletCount 方法</a> 获取触摸设备数量，然后遍历触摸设备序号拿到 ITablet 对象</p>

<p>在 C# 代码里面的逻辑如下</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>                    <span class="n">pimcManager</span><span class="p">.</span><span class="nf">GetTabletCount</span><span class="p">(</span><span class="k">out</span> <span class="n">cTablets</span><span class="p">);</span>

                    <span class="n">TabletDeviceInfo</span><span class="p">[]</span> <span class="n">tablets</span> <span class="p">=</span> <span class="k">new</span> <span class="n">TabletDeviceInfo</span><span class="p">[</span><span class="n">cTablets</span><span class="p">];</span>

                    <span class="k">for</span> <span class="p">(</span> <span class="kt">uint</span> <span class="n">iTablet</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">iTablet</span> <span class="p">&lt;</span> <span class="n">cTablets</span><span class="p">;</span> <span class="n">iTablet</span><span class="p">++</span> <span class="p">)</span>
                    <span class="p">{</span>
                        <span class="n">MS</span><span class="p">.</span><span class="n">Win32</span><span class="p">.</span><span class="n">Penimc</span><span class="p">.</span><span class="n">IPimcTablet3</span> <span class="n">pimcTablet</span><span class="p">;</span>
                        <span class="n">pimcManager</span><span class="p">.</span><span class="nf">GetTablet</span><span class="p">(</span><span class="n">iTablet</span><span class="p">,</span> <span class="k">out</span> <span class="n">pimcTablet</span><span class="p">);</span>

                        <span class="n">tablets</span><span class="p">[</span><span class="n">iTablet</span><span class="p">]</span> <span class="p">=</span> <span class="n">PenThreadWorker</span><span class="p">.</span><span class="nf">GetTabletInfoHelper</span><span class="p">(</span><span class="n">pimcTablet</span><span class="p">);</span>
                    <span class="p">}</span>
</code></pre></div></div>

<p>这里的 pimcManager.GetTablet 方法将会调用到 PimcManager.cpp 的 GetTablet 方法</p>

<pre><code class="language-C++">STDMETHODIMP CPimcManager::GetTablet(ULONG iTablet, __deref_out IPimcTablet3** ppTablet)
{
    DHR;

    switch (iTablet)
    {
        case RELEASE_MANAGER_EXT:
        {
            CHR(m_managerLock.Unlock());
        }
        break;
        default:
        {
            CHR(GetTabletImpl(iTablet, ppTablet));
        }
    }

CLEANUP:
    RHR;
}

STDMETHODIMP CPimcManager::GetTabletImpl(ULONG iTablet, __deref_out IPimcTablet3** ppTablet)
{
    DHR;
    LoadWisptis(); // Make sure wisptis has been loaded! (Can happen when handling OnTabletAdded message)
    
    CComPtr&lt;ITablet&gt;            pTabS;
    CComObject&lt;CPimcTablet&gt; *   pTabC;

    // Can only call if we have real tablet hardware which means wisptis must be loaded!
    CHR(m_fLoadedWisptis ? S_OK : E_UNEXPECTED);
    CHR(CComObject&lt;CPimcTablet&gt;::CreateInstance(&amp;pTabC));
    CHR(pTabC-&gt;QueryInterface(IID_IPimcTablet3, (void**)ppTablet));
    CHR(m_pMgrS-&gt;GetTablet(iTablet, &amp;pTabS));
    CHR(pTabC-&gt;Init(m_fLoadedWisptis?pTabS:NULL, this));

CLEANUP:
    RHR;
}
</code></pre>

<p>本质调用的是 <code class="language-plaintext highlighter-rouge">m_pMgrS</code> 的 GetTablet 方法，也就是系统提供的 <a href="https://docs.microsoft.com/en-us/previous-versions/windows/desktop/legacy/aa373683(v=vs.85)">ITabletManager 的 GetTablet 方法</a> 获取 ITablet 接口。只是在 C++ 代码里面，将 ITablet 接口再做一层封装，返回给 C# 的是 IPimcTablet3 接口</p>

<p>接下来就是通过 PenThreadWorker 的 GetTabletInfoHelper 方法获取触摸信息</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        <span class="k">private</span> <span class="k">static</span> <span class="n">TabletDeviceInfo</span> <span class="nf">GetTabletInfoHelper</span><span class="p">(</span><span class="n">IPimcTablet3</span> <span class="n">pimcTablet</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">TabletDeviceInfo</span> <span class="n">tabletInfo</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">TabletDeviceInfo</span><span class="p">();</span>

            <span class="n">tabletInfo</span><span class="p">.</span><span class="n">PimcTablet</span> <span class="p">=</span> <span class="k">new</span> <span class="n">SecurityCriticalDataClass</span><span class="p">&lt;</span><span class="n">IPimcTablet3</span><span class="p">&gt;(</span><span class="n">pimcTablet</span><span class="p">);</span>
            <span class="n">pimcTablet</span><span class="p">.</span><span class="nf">GetKey</span><span class="p">(</span><span class="k">out</span> <span class="n">tabletInfo</span><span class="p">.</span><span class="n">Id</span><span class="p">);</span>
            <span class="n">pimcTablet</span><span class="p">.</span><span class="nf">GetName</span><span class="p">(</span><span class="k">out</span> <span class="n">tabletInfo</span><span class="p">.</span><span class="n">Name</span><span class="p">);</span>
            <span class="n">pimcTablet</span><span class="p">.</span><span class="nf">GetPlugAndPlayId</span><span class="p">(</span><span class="k">out</span> <span class="n">tabletInfo</span><span class="p">.</span><span class="n">PlugAndPlayId</span><span class="p">);</span>
            <span class="kt">int</span> <span class="n">iTabletWidth</span><span class="p">,</span> <span class="n">iTabletHeight</span><span class="p">,</span> <span class="n">iDisplayWidth</span><span class="p">,</span> <span class="n">iDisplayHeight</span><span class="p">;</span>
            <span class="n">pimcTablet</span><span class="p">.</span><span class="nf">GetTabletAndDisplaySize</span><span class="p">(</span><span class="k">out</span> <span class="n">iTabletWidth</span><span class="p">,</span> <span class="k">out</span> <span class="n">iTabletHeight</span><span class="p">,</span> <span class="k">out</span> <span class="n">iDisplayWidth</span><span class="p">,</span> <span class="k">out</span> <span class="n">iDisplayHeight</span><span class="p">);</span>
            <span class="n">tabletInfo</span><span class="p">.</span><span class="n">SizeInfo</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">TabletDeviceSizeInfo</span><span class="p">(</span><span class="k">new</span> <span class="nf">Size</span><span class="p">(</span><span class="n">iTabletWidth</span><span class="p">,</span> <span class="n">iTabletHeight</span><span class="p">),</span>
                                                           <span class="k">new</span> <span class="nf">Size</span><span class="p">(</span><span class="n">iDisplayWidth</span><span class="p">,</span> <span class="n">iDisplayHeight</span><span class="p">));</span>
            <span class="kt">int</span> <span class="n">caps</span><span class="p">;</span>
            <span class="n">pimcTablet</span><span class="p">.</span><span class="nf">GetHardwareCaps</span><span class="p">(</span><span class="k">out</span> <span class="n">caps</span><span class="p">);</span>
            <span class="n">tabletInfo</span><span class="p">.</span><span class="n">HardwareCapabilities</span> <span class="p">=</span> <span class="p">(</span><span class="n">TabletHardwareCapabilities</span><span class="p">)</span><span class="n">caps</span><span class="p">;</span>
            <span class="kt">int</span> <span class="n">deviceType</span><span class="p">;</span>
            <span class="n">pimcTablet</span><span class="p">.</span><span class="nf">GetDeviceType</span><span class="p">(</span><span class="k">out</span> <span class="n">deviceType</span><span class="p">);</span>
            <span class="n">tabletInfo</span><span class="p">.</span><span class="n">DeviceType</span> <span class="p">=</span> <span class="p">(</span><span class="n">TabletDeviceType</span><span class="p">)(</span><span class="n">deviceType</span> <span class="p">-</span><span class="m">1</span><span class="p">);</span>

            <span class="c1">// </span>
            <span class="c1">// REENTRANCY NOTE: Let a PenThread do this work to avoid reentrancy!</span>
            <span class="c1">//                  The IPimcTablet3 object is created in the pen thread. If we access it from the UI thread,</span>
            <span class="c1">//                  COM will set up message pumping which will cause reentrancy here.</span>
            <span class="nf">InitializeSupportedStylusPointProperties</span><span class="p">(</span><span class="n">pimcTablet</span><span class="p">,</span> <span class="n">tabletInfo</span><span class="p">);</span>
            <span class="n">tabletInfo</span><span class="p">.</span><span class="n">StylusDevicesInfo</span> <span class="p">=</span> <span class="nf">GetStylusDevicesInfo</span><span class="p">(</span><span class="n">pimcTablet</span><span class="p">);</span>

            
            <span class="c1">// Obtain the WispTabletKey for future use in locking the WISP tablet.</span>
            <span class="n">tabletInfo</span><span class="p">.</span><span class="n">WispTabletKey</span> <span class="p">=</span> <span class="n">MS</span><span class="p">.</span><span class="n">Win32</span><span class="p">.</span><span class="n">Penimc</span><span class="p">.</span><span class="n">UnsafeNativeMethods</span><span class="p">.</span><span class="nf">QueryWispTabletKey</span><span class="p">(</span><span class="n">pimcTablet</span><span class="p">);</span>

            
            <span class="c1">// If the manager has not already been created and locked, we will lock it here.  This is the first opportunity</span>
            <span class="c1">// we will have to lock the manager as it will have been created on the thread to instantiate the first tablet.</span>
            <span class="n">MS</span><span class="p">.</span><span class="n">Win32</span><span class="p">.</span><span class="n">Penimc</span><span class="p">.</span><span class="n">UnsafeNativeMethods</span><span class="p">.</span><span class="nf">SetWispManagerKey</span><span class="p">(</span><span class="n">pimcTablet</span><span class="p">);</span>

            <span class="n">MS</span><span class="p">.</span><span class="n">Win32</span><span class="p">.</span><span class="n">Penimc</span><span class="p">.</span><span class="n">UnsafeNativeMethods</span><span class="p">.</span><span class="nf">LockWispManager</span><span class="p">();</span>

            <span class="k">return</span> <span class="n">tabletInfo</span><span class="p">;</span>
        <span class="p">}</span>
</code></pre></div></div>

<p>实际调用的就是 <a href="https://docs.microsoft.com/en-us/windows/win32/tablet/itablet?WT.mc_id=WD-MVP-5003260">ITablet 接口</a> 的方法</p>

<p>以上代码的 <code class="language-plaintext highlighter-rouge">pimcTablet.GetKey</code> 方法是在 C++ 层封装的，而不是系统提供的</p>

<pre><code class="language-C++">STDMETHODIMP CPimcTablet::GetKey(__out INT * pKey)
{
    DHR;
    CHR(pKey ? S_OK : E_INVALIDARG);
    *pKey = (INT)PtrToInt(m_pTabS.p);
CLEANUP:
    RHR;
}

    CComPtr&lt;ITablet&gt;      m_pTabS;
</code></pre>

<p>在 WPF 框架，获取的方法本质就是通过 Tablet PC 系统组件获取</p>

<p>更多触摸请看 <a href="https://blog.lindexi.com/post/WPF-%E8%A7%A6%E6%91%B8%E7%9B%B8%E5%85%B3.html">WPF 触摸相关</a></p>

:ET